= Database Schema Property Testing
:toc:
:toclevels: 2

== Overview

This document describes the property-based testing strategy for verifying that our database migration system produces correct and consistent results across PostgreSQL, MySQL, and SQLite.

Property-based testing generates random inputs and verifies that certain invariants (properties) always hold. This complements our existing integration tests by:

1. Testing with a much wider range of inputs than hand-written tests
2. Finding edge cases we might not think of
3. Verifying algebraic properties of operations
4. Ensuring cross-database consistency

== Properties to Verify

=== 1. Cross-Database Schema Equivalence

**Property**: The same `MigrationPlan` produces logically equivalent schemas in all 3 databases.

Given:
- A randomly generated table definition
- The same `MigrationPlan` executed against PostgreSQL, MySQL, and SQLite

Then:
- The introspected schemas, after normalization, should be equivalent

This accounts for expected type mapping differences (e.g., `BOOLEAN` in PostgreSQL maps to `INTEGER` in SQLite).

=== 2. Roundtrip Consistency

**Property**: A schema definition survives the roundtrip through SQL generation and execution.

```
Table Definition â†’ SQL Generation â†’ Execute â†’ Introspect â†’ Normalized Schema
```

The normalized schema should match the original definition in terms of:
- Column names
- Base types (normalized)
- Nullability
- Primary key designation
- Index presence and uniqueness

=== 3. Operation Algebra

Certain sequences of operations should produce predictable results:

[cols="1,2"]
|===
| Property | Description

| `AddColumn(x) + DropColumn(x) = no-op`
| Adding then dropping a column leaves schema unchanged

| `AddIndex(x) + DropIndex(x) = no-op`
| Adding then dropping an index leaves schema unchanged

| `RenameColumn(aâ†’b) + RenameColumn(bâ†’a) = identity`
| Renaming back and forth restores original state
|===

=== 4. SQL Validity (Fuzzing)

**Property**: Generated SQL is always syntactically valid and executes without errors.

Test with edge cases:
- Empty strings as defaults
- Strings containing single quotes (`it's`)
- Unicode characters in defaults (`æ—¥æœ¬èªž`, `emoji ðŸŽ‰`)
- Reserved SQL keywords as identifiers (`select`, `table`, `user`)
- Maximum-length identifiers (63 characters for PostgreSQL)
- Whitespace and special characters

=== 5. Constraint Enforcement

**Property**: Database constraints actually enforce their rules.

- `PRIMARY KEY` rejects duplicate values
- `UNIQUE` indexes reject duplicate values
- `NOT NULL` rejects NULL inserts

== Schema Normalization Strategy

To compare schemas across different databases, we normalize database-specific types to base types:

[cols="1,1,1,1"]
|===
| Base Type | PostgreSQL | MySQL | SQLite

| `integer`
| `integer`, `int4`
| `int`
| `INTEGER`

| `bigint`
| `bigint`, `int8`
| `bigint`
| `INTEGER`

| `string`
| `varchar`, `character varying`
| `varchar`
| `TEXT`

| `text`
| `text`
| `text`
| `TEXT`

| `boolean`
| `boolean`
| `tinyint`
| `INTEGER`

| `float`
| `double precision`
| `double`
| `REAL`

| `decimal`
| `numeric`, `decimal`
| `decimal`
| `REAL`

| `datetime`
| `timestamp`, `timestamp without time zone`
| `datetime`
| `TEXT`

| `binary`
| `bytea`
| `blob`
| `BLOB`

| `json`
| `jsonb`
| `json`
| `TEXT`
|===

== Edge Cases to Test

=== Identifiers

- Empty string (should error)
- Single character: `a`
- Reserved words: `select`, `table`, `from`, `where`, `user`, `order`, `group`
- Numbers at start: `123abc` (invalid)
- Underscores: `my_column`, `_private`
- Maximum length: 63 characters (PostgreSQL limit)
- Unicode: `æ—¥æœ¬èªž_column`

=== Default Values

- Empty string: `""`
- Single quotes: `"it's a test"`
- Double quotes: `"say \"hello\""`
- Backslash: `"path\\to\\file"`
- Unicode: `"æ—¥æœ¬èªž"`, `"emoji ðŸŽ‰"`
- Newlines: `"line1\nline2"`
- Tab characters: `"col1\tcol2"`
- NULL keyword as string: `"NULL"`
- Numeric strings: `"123"`, `"-456.78"`

=== Numeric Values

- Zero: `0`
- Negative: `-1`, `-999999`
- Large values: `9223372036854775807` (max int64)
- Decimals: `123.456`, `0.001`, `999.999999`

=== Boolean Values

- `true` â†’ maps to `1` in SQLite/MySQL
- `false` â†’ maps to `0` in SQLite/MySQL

== File Structure

Property tests should be organized into multiple files for clarity and maintainability:

[source]
----
packages/go/src/migrate/
â”œâ”€â”€ property_generators.go       # DDL generators (columns, tables, operations)
â”œâ”€â”€ property_normalize.go        # Schema normalization functions
â”œâ”€â”€ property_normalize_test.go   # Unit tests for normalization logic
â”œâ”€â”€ property_crossdb_test.go     # Cross-database equivalence tests
â”œâ”€â”€ property_roundtrip_test.go   # Roundtrip consistency tests
â”œâ”€â”€ property_algebra_test.go     # Operation algebra tests
â”œâ”€â”€ property_fuzz_test.go        # SQL validity fuzzing tests
â”œâ”€â”€ property_constraint_test.go  # Constraint enforcement tests
----

=== File Descriptions

==== `property_generators.go`

Non-test file containing DDL generators for property tests:

[source,go]
----
package migrate

import "github.com/portsql/portsql/proptest"

// Column generators
func generateRandomColumn(g *proptest.Generator) ddl.Column
func generateRandomColumnType(g *proptest.Generator) ddl.ColumnType
func generateRandomDefault(g *proptest.Generator, colType ddl.ColumnType) any

// Table generators
func generateRandomTable(g *proptest.Generator) *ddl.TableBuilder
func generateRandomTableName(g *proptest.Generator) string

// Operation generators
func generateRandomAlterOp(g *proptest.Generator, existingCols []string) ddl.AlterOp
func generateRandomAddColumn(g *proptest.Generator) ddl.AlterOp
func generateRandomDropColumn(g *proptest.Generator, existingCols []string) ddl.AlterOp

// Index generators
func generateRandomIndex(g *proptest.Generator, columns []string) ddl.Index
----

==== `property_normalize.go`

Non-test file containing schema normalization logic:

[source,go]
----
package migrate

// NormalizedColumn represents a database-agnostic column
type NormalizedColumn struct {
    Name       string
    BaseType   string  // "integer", "string", "boolean", etc.
    Nullable   bool
    IsPrimary  bool
    HasDefault bool
}

// NormalizedTable represents a database-agnostic table schema
type NormalizedTable struct {
    Name    string
    Columns []NormalizedColumn
    Indexes []NormalizedIndex
}

// Normalization functions
func normalizePostgresColumn(col ColumnInfo) NormalizedColumn
func normalizeMySQLColumn(col MySQLColumnInfo) NormalizedColumn
func normalizeSQLiteColumn(col SQLiteColumnInfo) NormalizedColumn

func normalizePostgresType(pgType string) string
func normalizeMySQLType(mysqlType string) string
func normalizeSQLiteType(sqliteType string) string
----

==== `property_normalize_test.go`

Unit tests for normalization logic (no database required):

[source,go]
----
package migrate

// Test type normalization
func TestNormalizePostgresType_Integer(t *testing.T)
func TestNormalizePostgresType_Varchar(t *testing.T)
func TestNormalizeMySQLType_TinyInt(t *testing.T)
func TestNormalizeSQLiteType_Text(t *testing.T)

// Test column normalization
func TestNormalizeColumn_Nullable(t *testing.T)
func TestNormalizeColumn_PrimaryKey(t *testing.T)

// Property: normalization is idempotent
func TestProperty_NormalizationIdempotent(t *testing.T)
----

==== `property_crossdb_test.go`

Cross-database equivalence property tests:

[source,go]
----
//go:build integration

package migrate

// Main property: same MigrationPlan â†’ equivalent schemas
func TestProperty_CrossDB_CreateTable_Equivalent(t *testing.T)
func TestProperty_CrossDB_AlterTable_Equivalent(t *testing.T)

// Helper: run migration on all 3 databases and compare
func runOnAllDatabases(t *testing.T, plan *MigrationPlan) (pg, mysql, sqlite NormalizedTable)
func assertSchemasEquivalent(t *testing.T, pg, mysql, sqlite NormalizedTable)
----

==== `property_roundtrip_test.go`

Roundtrip consistency property tests:

[source,go]
----
//go:build integration

package migrate

// Property: Definition â†’ SQL â†’ Execute â†’ Introspect â‰ˆ Definition
func TestProperty_Roundtrip_Postgres_CreateTable(t *testing.T)
func TestProperty_Roundtrip_MySQL_CreateTable(t *testing.T)
func TestProperty_Roundtrip_SQLite_CreateTable(t *testing.T)

// Property: random columns survive roundtrip
func TestProperty_Roundtrip_Postgres_RandomColumns(t *testing.T)
func TestProperty_Roundtrip_MySQL_RandomColumns(t *testing.T)
func TestProperty_Roundtrip_SQLite_RandomColumns(t *testing.T)
----

==== `property_algebra_test.go`

Operation algebra property tests:

[source,go]
----
//go:build integration

package migrate

// Property: AddColumn(x) + DropColumn(x) = no-op
func TestProperty_Algebra_AddDropColumn_NoOp(t *testing.T)

// Property: AddIndex(x) + DropIndex(x) = no-op
func TestProperty_Algebra_AddDropIndex_NoOp(t *testing.T)

// Property: RenameColumn(aâ†’b) + RenameColumn(bâ†’a) = identity
func TestProperty_Algebra_RenameRename_Identity(t *testing.T)

// Property: Operations are commutative when independent
func TestProperty_Algebra_IndependentOps_Commutative(t *testing.T)
----

==== `property_fuzz_test.go`

SQL validity fuzzing tests:

[source,go]
----
//go:build integration

package migrate

// Property: Generated SQL is always valid (never syntax errors)
func TestProperty_Fuzz_Postgres_ValidSQL(t *testing.T)
func TestProperty_Fuzz_MySQL_ValidSQL(t *testing.T)
func TestProperty_Fuzz_SQLite_ValidSQL(t *testing.T)

// Property: Edge case identifiers are properly quoted
func TestProperty_Fuzz_ReservedWordIdentifiers(t *testing.T)

// Property: Edge case defaults are properly escaped
func TestProperty_Fuzz_SpecialCharDefaults(t *testing.T)

// Property: Unicode in identifiers/defaults works
func TestProperty_Fuzz_UnicodeValues(t *testing.T)
----

==== `property_constraint_test.go`

Constraint enforcement property tests:

[source,go]
----
//go:build integration

package migrate

// Property: PRIMARY KEY rejects duplicates
func TestProperty_Constraint_PrimaryKey_RejectsDuplicates(t *testing.T)

// Property: UNIQUE index rejects duplicates
func TestProperty_Constraint_Unique_RejectsDuplicates(t *testing.T)

// Property: NOT NULL rejects NULL values
func TestProperty_Constraint_NotNull_RejectsNull(t *testing.T)

// Property: DEFAULT is applied when value omitted
func TestProperty_Constraint_Default_Applied(t *testing.T)
----

== Implementation Plan

1. **Build proptest package**: Generic property testing framework with seeded generators âœ“
2. **Create DDL generators** (`property_generators.go`): Random column, table, and operation generators
3. **Implement normalization** (`property_normalize.go`): Functions to normalize introspected schemas
4. **Unit test normalization** (`property_normalize_test.go`): Verify normalization logic without databases
5. **Write property tests**: One file per property category
6. **Run against all databases**: Execute with `-tags=integration`

== Running Property Tests

Once implemented:

[source,bash]
----
# Run all property tests
go test -v ./migrate/... -tags=integration -run "TestProperty_"

# Run with specific seed for reproducibility
PROPTEST_SEED=12345 go test -v ./migrate/... -tags=integration -run "TestProperty_"
----

== Failure Debugging

When a property test fails:

1. The test logs the random seed used
2. Re-run with that seed to reproduce: `PROPTEST_SEED=<seed>`
3. The failing input is logged for inspection
4. Fix the bug and verify the seed now passes
