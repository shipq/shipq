package codegen

import (
	"strings"
	"testing"

	"github.com/portsql/portsql/src/query"
)

func TestGenerateQueriesPackage(t *testing.T) {
	queries := []CompiledQuery{
		{
			Name: "GetUserByEmail",
			SQL:  `SELECT "users"."id", "users"."name", "users"."email" FROM "users" WHERE ("users"."email" = $1)`,
			Params: []ParamInfo{
				{Name: "email", GoType: "string"},
			},
			Results: []ResultInfo{
				{Name: "id", GoType: "int64"},
				{Name: "name", GoType: "string"},
				{Name: "email", GoType: "string"},
			},
		},
		{
			Name: "ListRecentPosts",
			SQL:  `SELECT "posts"."id", "posts"."title" FROM "posts" ORDER BY "posts"."created_at" DESC LIMIT $1`,
			Params: []ParamInfo{
				{Name: "limit", GoType: "int64"},
			},
			Results: []ResultInfo{
				{Name: "id", GoType: "int64"},
				{Name: "title", GoType: "string"},
			},
		},
	}

	code, err := GenerateQueriesPackage(queries, "queries")
	if err != nil {
		t.Fatalf("GenerateQueriesPackage failed: %v", err)
	}

	codeStr := string(code)

	// Check header
	if !strings.Contains(codeStr, "// Code generated by portsql. DO NOT EDIT.") {
		t.Error("missing generated header")
	}
	if !strings.Contains(codeStr, "package queries") {
		t.Error("missing package declaration")
	}

	// Check GetUserByEmail
	if !strings.Contains(codeStr, "GetUserByEmailSQL") {
		t.Error("missing GetUserByEmailSQL constant")
	}
	if !strings.Contains(codeStr, "GetUserByEmailParams") {
		t.Error("missing GetUserByEmailParams struct")
	}
	if !strings.Contains(codeStr, "GetUserByEmailResult") {
		t.Error("missing GetUserByEmailResult struct")
	}
	if !strings.Contains(codeStr, "Email string") {
		t.Error("missing Email field in params")
	}

	// Check ListRecentPosts
	if !strings.Contains(codeStr, "ListRecentPostsSQL") {
		t.Error("missing ListRecentPostsSQL constant")
	}
	if !strings.Contains(codeStr, "ListRecentPostsParams") {
		t.Error("missing ListRecentPostsParams struct")
	}
	if !strings.Contains(codeStr, "Limit int64") {
		t.Error("missing Limit field in params")
	}
}

func TestGenerateQueriesWithTimeType(t *testing.T) {
	queries := []CompiledQuery{
		{
			Name: "GetUserWithTimestamp",
			SQL:  `SELECT "users"."id", "users"."created_at" FROM "users"`,
			Results: []ResultInfo{
				{Name: "id", GoType: "int64"},
				{Name: "created_at", GoType: "time.Time"},
			},
		},
	}

	code, err := GenerateQueriesPackage(queries, "queries")
	if err != nil {
		t.Fatalf("GenerateQueriesPackage failed: %v", err)
	}

	codeStr := string(code)

	// Should import time
	if !strings.Contains(codeStr, `"time"`) {
		t.Error("missing time import")
	}
	if !strings.Contains(codeStr, "CreatedAt time.Time") {
		t.Error("missing CreatedAt field with time.Time type")
	}
}

func TestGenerateQueriesUpdateNoResult(t *testing.T) {
	queries := []CompiledQuery{
		{
			Name: "UpdateUserName",
			SQL:  `UPDATE "users" SET "name" = $1 WHERE ("users"."id" = $2)`,
			Params: []ParamInfo{
				{Name: "name", GoType: "string"},
				{Name: "id", GoType: "int64"},
			},
			// No Results for UPDATE
		},
	}

	code, err := GenerateQueriesPackage(queries, "queries")
	if err != nil {
		t.Fatalf("GenerateQueriesPackage failed: %v", err)
	}

	codeStr := string(code)

	// Should have SQL and Params but no Result
	if !strings.Contains(codeStr, "UpdateUserNameSQL") {
		t.Error("missing UpdateUserNameSQL constant")
	}
	if !strings.Contains(codeStr, "UpdateUserNameParams") {
		t.Error("missing UpdateUserNameParams struct")
	}
	if strings.Contains(codeStr, "UpdateUserNameResult") {
		t.Error("should not have UpdateUserNameResult struct for UPDATE query")
	}
}

func TestExtractResultInfo(t *testing.T) {
	ast := &query.AST{
		Kind: query.SelectQuery,
		FromTable: query.TableRef{
			Name: "users",
		},
		SelectCols: []query.SelectExpr{
			{Expr: query.ColumnExpr{Column: query.Int64Column{Table: "users", Name: "id"}}},
			{Expr: query.ColumnExpr{Column: query.StringColumn{Table: "users", Name: "name"}}},
			{Expr: query.ColumnExpr{Column: query.StringColumn{Table: "users", Name: "email"}}, Alias: "user_email"},
		},
	}

	results := ExtractResultInfo(ast)

	if len(results) != 3 {
		t.Fatalf("expected 3 results, got %d", len(results))
	}

	// Check first column
	if results[0].Name != "id" {
		t.Errorf("expected name 'id', got %q", results[0].Name)
	}
	if results[0].GoType != "int64" {
		t.Errorf("expected type 'int64', got %q", results[0].GoType)
	}

	// Check aliased column
	if results[2].Name != "user_email" {
		t.Errorf("expected name 'user_email', got %q", results[2].Name)
	}
}

func TestExtractParamInfo(t *testing.T) {
	// Create an AST with ParamExprs in the expressions
	ast := &query.AST{
		Kind: query.SelectQuery,
		FromTable: query.TableRef{
			Name: "users",
		},
		SelectCols: []query.SelectExpr{
			{Expr: query.ColumnExpr{Column: query.Int64Column{Table: "users", Name: "id"}}},
		},
		Where: query.BinaryExpr{
			Left:  query.ColumnExpr{Column: query.StringColumn{Table: "users", Name: "email"}},
			Op:    query.OpEq,
			Right: query.ParamExpr{Name: "email", GoType: "string"},
		},
		Limit: query.ParamExpr{Name: "limit", GoType: "int64"},
	}

	params := ExtractParamInfo(ast)

	if len(params) != 2 {
		t.Fatalf("expected 2 params, got %d", len(params))
	}

	// Check email param
	foundEmail := false
	foundLimit := false
	for _, p := range params {
		if p.Name == "email" && p.GoType == "string" {
			foundEmail = true
		}
		if p.Name == "limit" && p.GoType == "int64" {
			foundLimit = true
		}
	}

	if !foundEmail {
		t.Error("expected to find email param")
	}
	if !foundLimit {
		t.Error("expected to find limit param")
	}
}

func TestFormatSQLString(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		contains string
	}{
		{
			name:     "simple",
			input:    `SELECT * FROM users`,
			contains: "`SELECT * FROM users`",
		},
		{
			name:     "with quotes",
			input:    `SELECT "id" FROM "users"`,
			contains: "`SELECT \"id\" FROM \"users\"`",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := formatSQLString(tt.input)
			if result != tt.contains {
				t.Errorf("expected %s, got %s", tt.contains, result)
			}
		})
	}
}
