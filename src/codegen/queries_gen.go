package codegen

import (
	"bytes"
	"fmt"
	"go/format"
	"sort"
	"strings"

	"github.com/portsql/portsql/src/query"
)

// CompiledQuery holds the compiled information for a single query.
type CompiledQuery struct {
	Name    string
	SQL     string
	Params  []ParamInfo
	Results []ResultInfo
}

// ParamInfo describes a query parameter.
type ParamInfo struct {
	Name   string
	GoType string
}

// ResultInfo describes a result column.
type ResultInfo struct {
	Name   string
	GoType string
}

// GenerateQueriesPackage generates the queries.go file from compiled queries.
func GenerateQueriesPackage(queries []CompiledQuery, packageName string) ([]byte, error) {
	var buf bytes.Buffer

	// Collect imports
	imports := make(map[string]bool)
	for _, q := range queries {
		for _, p := range q.Params {
			if imp := goTypeImport(p.GoType); imp != "" {
				imports[imp] = true
			}
		}
		for _, r := range q.Results {
			if imp := goTypeImport(r.GoType); imp != "" {
				imports[imp] = true
			}
		}
	}

	// Sort queries by name for deterministic output
	sort.Slice(queries, func(i, j int) bool {
		return queries[i].Name < queries[j].Name
	})

	// Write header
	buf.WriteString("// Code generated by portsql. DO NOT EDIT.\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	// Write imports if needed
	if len(imports) > 0 {
		buf.WriteString("import (\n")
		importList := make([]string, 0, len(imports))
		for imp := range imports {
			importList = append(importList, imp)
		}
		sort.Strings(importList)
		for _, imp := range importList {
			buf.WriteString(fmt.Sprintf("\t%q\n", imp))
		}
		buf.WriteString(")\n\n")
	}

	// Generate each query
	for _, q := range queries {
		// SQL constant
		buf.WriteString(fmt.Sprintf("// %sSQL contains the compiled SQL for %s.\n", q.Name, q.Name))
		buf.WriteString(fmt.Sprintf("const %sSQL = %s\n\n", q.Name, formatSQLString(q.SQL)))

		// Params struct (if any)
		if len(q.Params) > 0 {
			buf.WriteString(fmt.Sprintf("// %sParams contains the parameters for %s.\n", q.Name, q.Name))
			buf.WriteString(fmt.Sprintf("type %sParams struct {\n", q.Name))
			for _, p := range q.Params {
				fieldName := toPascalCase(p.Name)
				buf.WriteString(fmt.Sprintf("\t%s %s\n", fieldName, p.GoType))
			}
			buf.WriteString("}\n\n")
		}

		// Result struct (if any)
		if len(q.Results) > 0 {
			buf.WriteString(fmt.Sprintf("// %sResult contains a single result row for %s.\n", q.Name, q.Name))
			buf.WriteString(fmt.Sprintf("type %sResult struct {\n", q.Name))
			for _, r := range q.Results {
				fieldName := toPascalCase(r.Name)
				buf.WriteString(fmt.Sprintf("\t%s %s\n", fieldName, r.GoType))
			}
			buf.WriteString("}\n\n")
		}
	}

	// Format the code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return buf.Bytes(), fmt.Errorf("failed to format generated code: %w", err)
	}

	return formatted, nil
}

// goTypeImport returns the import path needed for a Go type, or empty string if none.
func goTypeImport(goType string) string {
	if strings.Contains(goType, "time.Time") {
		return "time"
	}
	if strings.Contains(goType, "json.RawMessage") {
		return "encoding/json"
	}
	return ""
}

// formatSQLString formats SQL as a Go string literal.
func formatSQLString(sql string) string {
	// Use backticks for multi-line or complex SQL
	if strings.Contains(sql, "\n") || strings.Contains(sql, `"`) {
		// Escape backticks by using string concatenation
		if strings.Contains(sql, "`") {
			// Fall back to double-quoted string with escaping
			escaped := strings.ReplaceAll(sql, `\`, `\\`)
			escaped = strings.ReplaceAll(escaped, `"`, `\"`)
			escaped = strings.ReplaceAll(escaped, "\n", `\n`)
			return fmt.Sprintf(`"%s"`, escaped)
		}
		return fmt.Sprintf("`%s`", sql)
	}
	// Simple single-line SQL
	return fmt.Sprintf("`%s`", sql)
}

// ExtractResultInfo extracts result column information from a SELECT query AST.
func ExtractResultInfo(ast *query.AST) []ResultInfo {
	if ast.Kind != query.SelectQuery {
		return nil
	}

	var results []ResultInfo
	for _, sel := range ast.SelectCols {
		name := ""
		goType := "interface{}"

		// Determine name
		if sel.Alias != "" {
			name = sel.Alias
		} else {
			// Try to extract from expression
			switch e := sel.Expr.(type) {
			case query.ColumnExpr:
				name = e.Column.ColumnName()
				goType = e.Column.GoType()
			case query.AggregateExpr:
				// Aggregates need an alias or we use the function name
				if sel.Alias == "" {
					name = strings.ToLower(string(e.Func))
				}
				// Determine type based on aggregate
				switch e.Func {
				case query.AggCount:
					goType = "int64"
				case query.AggSum, query.AggAvg:
					// Type depends on the argument
					if col, ok := e.Arg.(query.ColumnExpr); ok {
						goType = col.Column.GoType()
					} else {
						goType = "float64"
					}
				case query.AggMin, query.AggMax:
					if col, ok := e.Arg.(query.ColumnExpr); ok {
						goType = col.Column.GoType()
					}
				}
			default:
				// For other expressions, need an alias
				continue
			}
		}

		// Get Go type from column expression
		if goType == "interface{}" {
			switch e := sel.Expr.(type) {
			case query.ColumnExpr:
				goType = e.Column.GoType()
			}
		}

		if name != "" {
			results = append(results, ResultInfo{
				Name:   name,
				GoType: goType,
			})
		}
	}

	return results
}

// ExtractParamInfo extracts parameter information from the AST by walking
// all expressions and collecting ParamExpr instances.
func ExtractParamInfo(ast *query.AST) []ParamInfo {
	var params []ParamInfo
	seen := make(map[string]bool)

	// Helper to collect params from an expression
	var collectFromExpr func(expr query.Expr)
	collectFromExpr = func(expr query.Expr) {
		if expr == nil {
			return
		}

		switch e := expr.(type) {
		case query.ParamExpr:
			if !seen[e.Name] {
				params = append(params, ParamInfo{
					Name:   e.Name,
					GoType: e.GoType,
				})
				seen[e.Name] = true
			}
		case query.BinaryExpr:
			collectFromExpr(e.Left)
			collectFromExpr(e.Right)
		case query.UnaryExpr:
			collectFromExpr(e.Expr)
		case query.FuncExpr:
			for _, arg := range e.Args {
				collectFromExpr(arg)
			}
		case query.ListExpr:
			for _, val := range e.Values {
				collectFromExpr(val)
			}
		case query.AggregateExpr:
			collectFromExpr(e.Arg)
		case query.SubqueryExpr:
			collectFromAST(e.Query, &params, seen)
		case query.ExistsExpr:
			collectFromAST(e.Subquery, &params, seen)
		}
	}

	collectFromAST(ast, &params, seen)
	return params
}

// collectFromAST walks an AST and collects all params.
func collectFromAST(ast *query.AST, params *[]ParamInfo, seen map[string]bool) {
	if ast == nil {
		return
	}

	// Helper to collect params from an expression
	var collectFromExpr func(expr query.Expr)
	collectFromExpr = func(expr query.Expr) {
		if expr == nil {
			return
		}

		switch e := expr.(type) {
		case query.ParamExpr:
			if !seen[e.Name] {
				*params = append(*params, ParamInfo{
					Name:   e.Name,
					GoType: e.GoType,
				})
				seen[e.Name] = true
			}
		case query.BinaryExpr:
			collectFromExpr(e.Left)
			collectFromExpr(e.Right)
		case query.UnaryExpr:
			collectFromExpr(e.Expr)
		case query.FuncExpr:
			for _, arg := range e.Args {
				collectFromExpr(arg)
			}
		case query.ListExpr:
			for _, val := range e.Values {
				collectFromExpr(val)
			}
		case query.AggregateExpr:
			collectFromExpr(e.Arg)
		case query.SubqueryExpr:
			collectFromAST(e.Query, params, seen)
		case query.ExistsExpr:
			collectFromAST(e.Subquery, params, seen)
		}
	}

	// Walk SELECT columns
	for _, sel := range ast.SelectCols {
		collectFromExpr(sel.Expr)
	}

	// Walk joins
	for _, join := range ast.Joins {
		collectFromExpr(join.Condition)
	}

	// Walk WHERE
	collectFromExpr(ast.Where)

	// Walk HAVING
	collectFromExpr(ast.Having)

	// Walk ORDER BY
	for _, ob := range ast.OrderBy {
		collectFromExpr(ob.Expr)
	}

	// Walk LIMIT and OFFSET
	collectFromExpr(ast.Limit)
	collectFromExpr(ast.Offset)

	// Walk INSERT values
	for _, val := range ast.InsertVals {
		collectFromExpr(val)
	}

	// Walk SET clauses
	for _, set := range ast.SetClauses {
		collectFromExpr(set.Value)
	}

	// Walk set operations
	if ast.SetOp != nil {
		collectFromAST(ast.SetOp.Left, params, seen)
		collectFromAST(ast.SetOp.Right, params, seen)
	}

	// Walk CTEs
	for _, cte := range ast.CTEs {
		collectFromAST(cte.Query, params, seen)
	}
}
