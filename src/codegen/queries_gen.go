package codegen

import (
	"bytes"
	"fmt"
	"go/format"
	"sort"
	"strings"

	"github.com/portsql/portsql/src/query"
)

// CompiledQuery holds the compiled information for a single query.
type CompiledQuery struct {
	Name    string
	SQL     string
	Params  []ParamInfo
	Results []ResultInfo
}

// ParamInfo describes a query parameter.
type ParamInfo struct {
	Name   string
	GoType string
}

// ResultInfo describes a result column.
type ResultInfo struct {
	Name   string
	GoType string
	// NestedFields holds the fields for JSON aggregation results.
	// When non-empty, this result is a nested type (slice of objects).
	NestedFields []ResultInfo
}

// GenerateQueriesPackage generates the queries.go file from compiled queries.
func GenerateQueriesPackage(queries []CompiledQuery, packageName string) ([]byte, error) {
	// Validate queries for duplicate field names before generating code
	for _, q := range queries {
		if err := validateNoDuplicateFields(q); err != nil {
			return nil, err
		}
	}

	var buf bytes.Buffer

	// Collect imports (including from nested fields)
	imports := make(map[string]bool)
	for _, q := range queries {
		for _, p := range q.Params {
			if imp := goTypeImport(p.GoType); imp != "" {
				imports[imp] = true
			}
		}
		collectImportsFromResults(q.Results, imports)
	}

	// Sort queries by name for deterministic output
	sort.Slice(queries, func(i, j int) bool {
		return queries[i].Name < queries[j].Name
	})

	// Write header
	buf.WriteString("// Code generated by portsql. DO NOT EDIT.\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	// Write imports if needed
	if len(imports) > 0 {
		buf.WriteString("import (\n")
		importList := make([]string, 0, len(imports))
		for imp := range imports {
			importList = append(importList, imp)
		}
		sort.Strings(importList)
		for _, imp := range importList {
			buf.WriteString(fmt.Sprintf("\t%q\n", imp))
		}
		buf.WriteString(")\n\n")
	}

	// Generate each query
	for _, q := range queries {
		// SQL constant
		buf.WriteString(fmt.Sprintf("// %sSQL contains the compiled SQL for %s.\n", q.Name, q.Name))
		buf.WriteString(fmt.Sprintf("const %sSQL = %s\n\n", q.Name, formatSQLString(q.SQL)))

		// Params struct (if any)
		if len(q.Params) > 0 {
			buf.WriteString(fmt.Sprintf("// %sParams contains the parameters for %s.\n", q.Name, q.Name))
			buf.WriteString(fmt.Sprintf("type %sParams struct {\n", q.Name))
			for _, p := range q.Params {
				fieldName := toPascalCase(p.Name)
				buf.WriteString(fmt.Sprintf("\t%s %s\n", fieldName, p.GoType))
			}
			buf.WriteString("}\n\n")
		}

		// Result struct (if any)
		if len(q.Results) > 0 {
			buf.WriteString(fmt.Sprintf("// %sResult contains a single result row for %s.\n", q.Name, q.Name))
			buf.WriteString(fmt.Sprintf("type %sResult struct {\n", q.Name))
			for _, r := range q.Results {
				fieldName := toPascalCase(r.Name)
				goType := r.GoType
				// Handle nested types (JSON aggregation)
				if len(r.NestedFields) > 0 {
					nestedTypeName := q.Name + fieldName + "Item"
					goType = "[]" + nestedTypeName
				}
				buf.WriteString(fmt.Sprintf("\t%s %s\n", fieldName, goType))
			}
			buf.WriteString("}\n\n")

			// Generate nested structs for JSON aggregation fields
			generateNestedStructs(&buf, q.Name, "", q.Results)
		}
	}

	// Format the code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return buf.Bytes(), fmt.Errorf("failed to format generated code: %w", err)
	}

	return formatted, nil
}

// collectImportsFromResults recursively collects imports from results including nested fields.
func collectImportsFromResults(results []ResultInfo, imports map[string]bool) {
	for _, r := range results {
		if imp := goTypeImport(r.GoType); imp != "" {
			imports[imp] = true
		}
		// Recursively check nested fields
		if len(r.NestedFields) > 0 {
			collectImportsFromResults(r.NestedFields, imports)
		}
	}
}

// generateNestedStructs generates struct types for JSON aggregation fields.
// It handles multi-level nesting by recursively processing NestedFields.
func generateNestedStructs(buf *bytes.Buffer, queryName, parentPath string, results []ResultInfo) {
	for _, r := range results {
		if len(r.NestedFields) == 0 {
			continue
		}

		fieldName := toPascalCase(r.Name)
		// Build the current path for this type
		var currentPath string
		if parentPath == "" {
			currentPath = fieldName
		} else {
			currentPath = parentPath + fieldName
		}
		typeName := queryName + currentPath + "Item"

		buf.WriteString(fmt.Sprintf("// %s represents a single item in the %s JSON array.\n", typeName, r.Name))
		buf.WriteString(fmt.Sprintf("type %s struct {\n", typeName))
		for _, nested := range r.NestedFields {
			nestedFieldName := toPascalCase(nested.Name)
			goType := nested.GoType
			// Handle deeply nested types - use the full path
			if len(nested.NestedFields) > 0 {
				nestedTypeName := queryName + currentPath + nestedFieldName + "Item"
				goType = "[]" + nestedTypeName
			}
			buf.WriteString(fmt.Sprintf("\t%s %s\n", nestedFieldName, goType))
		}
		buf.WriteString("}\n\n")

		// Recursively generate structs for deeply nested fields
		generateNestedStructs(buf, queryName, currentPath, r.NestedFields)
	}
}

// validateNoDuplicateFields checks that a query's result columns don't have duplicate
// field names after PascalCase conversion. This would generate invalid Go code.
func validateNoDuplicateFields(q CompiledQuery) error {
	// Check result fields
	resultFields := make(map[string]string) // PascalCase name -> original name
	for _, r := range q.Results {
		fieldName := toPascalCase(r.Name)
		if existingName, exists := resultFields[fieldName]; exists {
			return fmt.Errorf(
				"query %q has duplicate result field %q (from columns %q and %q). "+
					"Use SelectAs() to give one of them an alias",
				q.Name, fieldName, existingName, r.Name,
			)
		}
		resultFields[fieldName] = r.Name
	}

	// Check param fields
	paramFields := make(map[string]string)
	for _, p := range q.Params {
		fieldName := toPascalCase(p.Name)
		if existingName, exists := paramFields[fieldName]; exists {
			return fmt.Errorf(
				"query %q has duplicate parameter field %q (from params %q and %q)",
				q.Name, fieldName, existingName, p.Name,
			)
		}
		paramFields[fieldName] = p.Name
	}

	return nil
}

// goTypeImport returns the import path needed for a Go type, or empty string if none.
func goTypeImport(goType string) string {
	if strings.Contains(goType, "time.Time") {
		return "time"
	}
	if strings.Contains(goType, "json.RawMessage") {
		return "encoding/json"
	}
	return ""
}

// formatSQLString formats SQL as a Go string literal.
func formatSQLString(sql string) string {
	// Use backticks for multi-line or complex SQL
	if strings.Contains(sql, "\n") || strings.Contains(sql, `"`) {
		// Escape backticks by using string concatenation
		if strings.Contains(sql, "`") {
			// Fall back to double-quoted string with escaping
			escaped := strings.ReplaceAll(sql, `\`, `\\`)
			escaped = strings.ReplaceAll(escaped, `"`, `\"`)
			escaped = strings.ReplaceAll(escaped, "\n", `\n`)
			return fmt.Sprintf(`"%s"`, escaped)
		}
		return fmt.Sprintf("`%s`", sql)
	}
	// Simple single-line SQL
	return fmt.Sprintf("`%s`", sql)
}

// ExtractResultInfo extracts result column information from a SELECT query AST.
func ExtractResultInfo(ast *query.AST) []ResultInfo {
	if ast.Kind != query.SelectQuery {
		return nil
	}

	var results []ResultInfo
	for _, sel := range ast.SelectCols {
		name := ""
		goType := "interface{}"
		var nestedFields []ResultInfo

		// Determine name
		if sel.Alias != "" {
			name = sel.Alias
		} else {
			// Try to extract from expression
			switch e := sel.Expr.(type) {
			case query.ColumnExpr:
				name = e.Column.ColumnName()
				goType = e.Column.GoType()
			case query.AggregateExpr:
				// Aggregates need an alias or we use the function name
				if sel.Alias == "" {
					name = strings.ToLower(string(e.Func))
				}
				// Determine type based on aggregate
				switch e.Func {
				case query.AggCount:
					goType = "int64"
				case query.AggSum, query.AggAvg:
					// Type depends on the argument
					if col, ok := e.Arg.(query.ColumnExpr); ok {
						goType = col.Column.GoType()
					} else {
						goType = "float64"
					}
				case query.AggMin, query.AggMax:
					if col, ok := e.Arg.(query.ColumnExpr); ok {
						goType = col.Column.GoType()
					}
				}
			case query.JSONAggExpr:
				// JSON aggregation - extract nested column types
				name = e.FieldName
				// Extract nested fields from the columns
				for _, col := range e.Columns {
					nestedFields = append(nestedFields, ResultInfo{
						Name:   col.ColumnName(),
						GoType: col.GoType(),
					})
				}
				// GoType will be set by GenerateQueriesPackage based on the nested type name
				goType = "" // Marker - will be replaced with []TypeName
			default:
				// For other expressions, need an alias
				continue
			}
		}

		// Get Go type from column expression
		if goType == "interface{}" {
			switch e := sel.Expr.(type) {
			case query.ColumnExpr:
				goType = e.Column.GoType()
			}
		}

		// Handle JSONAggExpr when it has an alias
		if goType == "interface{}" || goType == "" {
			switch e := sel.Expr.(type) {
			case query.JSONAggExpr:
				for _, col := range e.Columns {
					nestedFields = append(nestedFields, ResultInfo{
						Name:   col.ColumnName(),
						GoType: col.GoType(),
					})
				}
				goType = "" // Marker - will be replaced with []TypeName
			}
		}

		if name != "" {
			results = append(results, ResultInfo{
				Name:         name,
				GoType:       goType,
				NestedFields: nestedFields,
			})
		}
	}

	return results
}

// ExtractParamInfo extracts parameter information from the AST by walking
// all expressions and collecting ParamExpr instances.
func ExtractParamInfo(ast *query.AST) []ParamInfo {
	var params []ParamInfo
	seen := make(map[string]bool)

	// Helper to collect params from an expression
	var collectFromExpr func(expr query.Expr)
	collectFromExpr = func(expr query.Expr) {
		if expr == nil {
			return
		}

		switch e := expr.(type) {
		case query.ParamExpr:
			if !seen[e.Name] {
				params = append(params, ParamInfo{
					Name:   e.Name,
					GoType: e.GoType,
				})
				seen[e.Name] = true
			}
		case query.BinaryExpr:
			collectFromExpr(e.Left)
			collectFromExpr(e.Right)
		case query.UnaryExpr:
			collectFromExpr(e.Expr)
		case query.FuncExpr:
			for _, arg := range e.Args {
				collectFromExpr(arg)
			}
		case query.ListExpr:
			for _, val := range e.Values {
				collectFromExpr(val)
			}
		case query.AggregateExpr:
			collectFromExpr(e.Arg)
		case query.SubqueryExpr:
			collectFromAST(e.Query, &params, seen)
		case query.ExistsExpr:
			collectFromAST(e.Subquery, &params, seen)
		}
	}

	collectFromAST(ast, &params, seen)
	return params
}

// collectFromAST walks an AST and collects all params.
func collectFromAST(ast *query.AST, params *[]ParamInfo, seen map[string]bool) {
	if ast == nil {
		return
	}

	// Helper to collect params from an expression
	var collectFromExpr func(expr query.Expr)
	collectFromExpr = func(expr query.Expr) {
		if expr == nil {
			return
		}

		switch e := expr.(type) {
		case query.ParamExpr:
			if !seen[e.Name] {
				*params = append(*params, ParamInfo{
					Name:   e.Name,
					GoType: e.GoType,
				})
				seen[e.Name] = true
			}
		case query.BinaryExpr:
			collectFromExpr(e.Left)
			collectFromExpr(e.Right)
		case query.UnaryExpr:
			collectFromExpr(e.Expr)
		case query.FuncExpr:
			for _, arg := range e.Args {
				collectFromExpr(arg)
			}
		case query.ListExpr:
			for _, val := range e.Values {
				collectFromExpr(val)
			}
		case query.AggregateExpr:
			collectFromExpr(e.Arg)
		case query.SubqueryExpr:
			collectFromAST(e.Query, params, seen)
		case query.ExistsExpr:
			collectFromAST(e.Subquery, params, seen)
		}
	}

	// Walk SELECT columns
	for _, sel := range ast.SelectCols {
		collectFromExpr(sel.Expr)
	}

	// Walk joins
	for _, join := range ast.Joins {
		collectFromExpr(join.Condition)
	}

	// Walk WHERE
	collectFromExpr(ast.Where)

	// Walk HAVING
	collectFromExpr(ast.Having)

	// Walk ORDER BY
	for _, ob := range ast.OrderBy {
		collectFromExpr(ob.Expr)
	}

	// Walk LIMIT and OFFSET
	collectFromExpr(ast.Limit)
	collectFromExpr(ast.Offset)

	// Walk INSERT values
	for _, val := range ast.InsertVals {
		collectFromExpr(val)
	}

	// Walk SET clauses
	for _, set := range ast.SetClauses {
		collectFromExpr(set.Value)
	}

	// Walk set operations
	if ast.SetOp != nil {
		collectFromAST(ast.SetOp.Left, params, seen)
		collectFromAST(ast.SetOp.Right, params, seen)
	}

	// Walk CTEs
	for _, cte := range ast.CTEs {
		collectFromAST(cte.Query, params, seen)
	}
}
