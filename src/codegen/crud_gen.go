package codegen

import (
	"bytes"
	"fmt"
	"go/format"
	"sort"

	"github.com/portsql/portsql/src/ddl"
	"github.com/portsql/portsql/src/migrate"
)

// CRUDOptions configures CRUD generation behavior.
type CRUDOptions struct {
	// ScopeColumn, if set, adds this column to WHERE clauses.
	// The column must exist in the table.
	// Example: "organization_id", "tenant_id", "user_id"
	ScopeColumn string
}

// GenerateCRUDTypes generates CRUD param and result structs for a single table.
func GenerateCRUDTypes(table ddl.Table, packageName string) ([]byte, error) {
	return GenerateCRUDTypesWithOptions(table, packageName, CRUDOptions{})
}

// GenerateCRUDTypesWithOptions generates CRUD param and result structs with custom options.
func GenerateCRUDTypesWithOptions(table ddl.Table, packageName string, opts CRUDOptions) ([]byte, error) {
	var buf bytes.Buffer
	analysis := AnalyzeTable(table)

	// Collect imports
	imports := make(map[string]bool)
	for _, col := range table.Columns {
		mapping := MapColumnType(col)
		if mapping.NeedsImport != "" {
			imports[mapping.NeedsImport] = true
		}
	}

	// Write package and imports
	buf.WriteString("// Code generated by orm codegen. DO NOT EDIT.\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	if len(imports) > 0 {
		buf.WriteString("import (\n")
		for imp := range imports {
			buf.WriteString(fmt.Sprintf("\t%q\n", imp))
		}
		buf.WriteString(")\n\n")
	}

	singular := toSingular(table.Name)
	singularPascal := toPascalCase(singular)

	// Write section comment
	buf.WriteString(fmt.Sprintf("// ========== %s CRUD Types ==========\n\n", toPascalCase(table.Name)))

	// --- Get ---
	writeGetTypes(&buf, table, analysis, singularPascal, opts)

	// --- List ---
	writeListTypes(&buf, table, analysis, singularPascal, opts)

	// --- Insert ---
	writeInsertTypes(&buf, table, analysis, singularPascal, opts)

	// --- Update ---
	writeUpdateTypes(&buf, table, analysis, singularPascal, opts)

	// --- Delete ---
	writeDeleteTypes(&buf, table, analysis, singularPascal)

	// --- HardDelete (only if table has deleted_at) ---
	if analysis.HasDeletedAt {
		writeHardDeleteTypes(&buf, table, analysis, singularPascal)
	}

	// Format the code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return buf.Bytes(), fmt.Errorf("failed to format generated code: %w", err)
	}

	return formatted, nil
}

// writeGetTypes writes the Get param and result types
func writeGetTypes(buf *bytes.Buffer, table ddl.Table, analysis TableAnalysis, singularPascal string, opts CRUDOptions) {
	// Get params - use public_id if available, otherwise id
	buf.WriteString(fmt.Sprintf("// --- Get ---\n\n"))
	buf.WriteString(fmt.Sprintf("// Get%sParams contains parameters for fetching a single %s.\n", singularPascal, toSingular(table.Name)))
	buf.WriteString(fmt.Sprintf("type Get%sParams struct {\n", singularPascal))

	if analysis.HasPublicID {
		buf.WriteString("\tPublicID string\n")
	} else {
		buf.WriteString("\tID int64\n")
	}

	// Add scope column if configured
	if opts.ScopeColumn != "" {
		scopeCol := findColumn(table, opts.ScopeColumn)
		if scopeCol != nil {
			mapping := MapColumnType(*scopeCol)
			buf.WriteString(fmt.Sprintf("\t%s %s\n", toPascalCase(opts.ScopeColumn), mapping.GoType))
		}
	}

	buf.WriteString("}\n\n")

	// Get result - all result columns
	buf.WriteString(fmt.Sprintf("// Get%sResult contains the result of fetching a single %s.\n", singularPascal, toSingular(table.Name)))
	buf.WriteString(fmt.Sprintf("type Get%sResult struct {\n", singularPascal))
	for _, col := range analysis.ResultColumns {
		mapping := MapColumnType(col)
		buf.WriteString(fmt.Sprintf("\t%s %s\n", toPascalCase(col.Name), mapping.GoType))
	}
	buf.WriteString("}\n\n")
}

// writeListTypes writes the List param and result types
func writeListTypes(buf *bytes.Buffer, table ddl.Table, analysis TableAnalysis, singularPascal string, opts CRUDOptions) {
	pluralPascal := toPascalCase(table.Name)

	buf.WriteString(fmt.Sprintf("// --- List ---\n\n"))
	buf.WriteString(fmt.Sprintf("// List%sParams contains parameters for listing %s.\n", pluralPascal, table.Name))
	buf.WriteString(fmt.Sprintf("type List%sParams struct {\n", pluralPascal))

	// Add scope column if configured
	if opts.ScopeColumn != "" {
		scopeCol := findColumn(table, opts.ScopeColumn)
		if scopeCol != nil {
			mapping := MapColumnType(*scopeCol)
			buf.WriteString(fmt.Sprintf("\t%s %s\n", toPascalCase(opts.ScopeColumn), mapping.GoType))
		}
	}

	buf.WriteString("\tLimit  int\n")
	buf.WriteString("\tOffset int\n")
	buf.WriteString("}\n\n")

	// List result - result columns excluding updated_at for brevity
	buf.WriteString(fmt.Sprintf("// List%sResult contains a single item from a list of %s.\n", pluralPascal, table.Name))
	buf.WriteString(fmt.Sprintf("type List%sResult struct {\n", pluralPascal))
	for _, col := range analysis.ResultColumns {
		// Optionally exclude updated_at from list results for brevity
		if col.Name == "updated_at" {
			continue
		}
		mapping := MapColumnType(col)
		buf.WriteString(fmt.Sprintf("\t%s %s\n", toPascalCase(col.Name), mapping.GoType))
	}
	buf.WriteString("}\n\n")
}

// writeInsertTypes writes the Insert param type
func writeInsertTypes(buf *bytes.Buffer, table ddl.Table, analysis TableAnalysis, singularPascal string, opts CRUDOptions) {
	buf.WriteString(fmt.Sprintf("// --- Insert ---\n\n"))
	buf.WriteString(fmt.Sprintf("// Insert%sParams contains parameters for inserting a new %s.\n", singularPascal, toSingular(table.Name)))
	buf.WriteString(fmt.Sprintf("type Insert%sParams struct {\n", singularPascal))

	// Add scope column if configured (user provides it on insert)
	if opts.ScopeColumn != "" {
		scopeCol := findColumn(table, opts.ScopeColumn)
		if scopeCol != nil {
			mapping := MapColumnType(*scopeCol)
			buf.WriteString(fmt.Sprintf("\t%s %s\n", toPascalCase(opts.ScopeColumn), mapping.GoType))
		}
	}

	// Only user-provided columns (not auto-filled)
	for _, col := range analysis.UserColumns {
		// Skip scope column if already added
		if opts.ScopeColumn != "" && col.Name == opts.ScopeColumn {
			continue
		}
		mapping := MapColumnType(col)
		buf.WriteString(fmt.Sprintf("\t%s %s\n", toPascalCase(col.Name), mapping.GoType))
	}
	buf.WriteString("}\n\n")
}

// writeUpdateTypes writes the Update param type
func writeUpdateTypes(buf *bytes.Buffer, table ddl.Table, analysis TableAnalysis, singularPascal string, opts CRUDOptions) {
	buf.WriteString(fmt.Sprintf("// --- Update ---\n\n"))
	buf.WriteString(fmt.Sprintf("// Update%sParams contains parameters for updating a %s.\n", singularPascal, toSingular(table.Name)))
	buf.WriteString(fmt.Sprintf("type Update%sParams struct {\n", singularPascal))

	// Primary identifier for WHERE clause
	if analysis.HasPublicID {
		buf.WriteString("\tPublicID string\n")
	} else {
		buf.WriteString("\tID int64\n")
	}

	// Add scope column if configured
	if opts.ScopeColumn != "" {
		scopeCol := findColumn(table, opts.ScopeColumn)
		if scopeCol != nil {
			mapping := MapColumnType(*scopeCol)
			buf.WriteString(fmt.Sprintf("\t%s %s\n", toPascalCase(opts.ScopeColumn), mapping.GoType))
		}
	}

	// User-provided columns
	for _, col := range analysis.UserColumns {
		// Skip scope column if already added
		if opts.ScopeColumn != "" && col.Name == opts.ScopeColumn {
			continue
		}
		mapping := MapColumnType(col)
		buf.WriteString(fmt.Sprintf("\t%s %s\n", toPascalCase(col.Name), mapping.GoType))
	}
	buf.WriteString("}\n\n")
}

// writeDeleteTypes writes the Delete param type
func writeDeleteTypes(buf *bytes.Buffer, table ddl.Table, analysis TableAnalysis, singularPascal string) {
	buf.WriteString(fmt.Sprintf("// --- Delete ---\n\n"))
	buf.WriteString(fmt.Sprintf("// Delete%sParams contains parameters for deleting a %s.\n", singularPascal, toSingular(table.Name)))
	buf.WriteString(fmt.Sprintf("type Delete%sParams struct {\n", singularPascal))
	if analysis.HasPublicID {
		buf.WriteString("\tPublicID string\n")
	} else {
		buf.WriteString("\tID int64\n")
	}
	buf.WriteString("}\n\n")
}

// writeHardDeleteTypes writes the HardDelete param type
func writeHardDeleteTypes(buf *bytes.Buffer, table ddl.Table, analysis TableAnalysis, singularPascal string) {
	buf.WriteString(fmt.Sprintf("// --- HardDelete ---\n\n"))
	buf.WriteString(fmt.Sprintf("// HardDelete%sParams contains parameters for permanently deleting a %s.\n", singularPascal, toSingular(table.Name)))
	buf.WriteString(fmt.Sprintf("type HardDelete%sParams struct {\n", singularPascal))
	if analysis.HasPublicID {
		buf.WriteString("\tPublicID string\n")
	} else {
		buf.WriteString("\tID int64\n")
	}
	buf.WriteString("}\n\n")
}

// findColumn finds a column by name in a table
func findColumn(table ddl.Table, name string) *ddl.ColumnDefinition {
	for _, col := range table.Columns {
		if col.Name == name {
			return &col
		}
	}
	return nil
}

// GenerateCRUDPackage generates CRUD types for all tables in a migration plan.
func GenerateCRUDPackage(plan *migrate.MigrationPlan, packageName string) ([]byte, error) {
	return GenerateCRUDPackageWithOptions(plan, packageName, make(map[string]CRUDOptions))
}

// GenerateCRUDPackageWithOptions generates CRUD types with per-table options.
func GenerateCRUDPackageWithOptions(plan *migrate.MigrationPlan, packageName string, tableOpts map[string]CRUDOptions) ([]byte, error) {
	var buf bytes.Buffer

	// Collect all imports
	imports := make(map[string]bool)
	for _, table := range plan.Schema.Tables {
		for _, col := range table.Columns {
			mapping := MapColumnType(col)
			if mapping.NeedsImport != "" {
				imports[mapping.NeedsImport] = true
			}
		}
	}

	// Sort tables for deterministic output
	tableNames := make([]string, 0, len(plan.Schema.Tables))
	for name := range plan.Schema.Tables {
		tableNames = append(tableNames, name)
	}
	sort.Strings(tableNames)

	// Write package and imports
	buf.WriteString("// Code generated by orm codegen. DO NOT EDIT.\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	if len(imports) > 0 {
		buf.WriteString("import (\n")
		for imp := range imports {
			buf.WriteString(fmt.Sprintf("\t%q\n", imp))
		}
		buf.WriteString(")\n\n")
	}

	// Generate CRUD types for each table
	for _, tableName := range tableNames {
		table := plan.Schema.Tables[tableName]
		analysis := AnalyzeTable(table)
		singular := toSingular(tableName)
		singularPascal := toPascalCase(singular)

		opts := tableOpts[tableName]

		// Write section comment
		buf.WriteString(fmt.Sprintf("// ========== %s CRUD Types ==========\n\n", toPascalCase(tableName)))

		writeGetTypes(&buf, table, analysis, singularPascal, opts)
		writeListTypes(&buf, table, analysis, singularPascal, opts)
		writeInsertTypes(&buf, table, analysis, singularPascal, opts)
		writeUpdateTypes(&buf, table, analysis, singularPascal, opts)
		writeDeleteTypes(&buf, table, analysis, singularPascal)
		if analysis.HasDeletedAt {
			writeHardDeleteTypes(&buf, table, analysis, singularPascal)
		}
	}

	// Format the code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return buf.Bytes(), fmt.Errorf("failed to format generated code: %w", err)
	}

	return formatted, nil
}
