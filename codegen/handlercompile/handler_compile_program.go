package handlercompile

import (
	"bytes"
	"fmt"
	"go/format"
	"sort"
)

// HandlerCompileProgramConfig holds configuration for generating the handler
// compile program.
type HandlerCompileProgramConfig struct {
	ModulePath string   // e.g., "myapp"
	APIPkgs    []string // import paths to api packages with Register functions
}

// GenerateHandlerCompileProgram generates the temporary program that extracts
// handler registrations. The generated program imports all api packages,
// calls their Register functions, then serializes the registry for processing.
func GenerateHandlerCompileProgram(cfg HandlerCompileProgramConfig) ([]byte, error) {
	var buf bytes.Buffer

	// Sort for deterministic output
	pkgs := make([]string, len(cfg.APIPkgs))
	copy(pkgs, cfg.APIPkgs)
	sort.Strings(pkgs)

	buf.WriteString(`// Code generated by shipq. This file can be run manually for debugging.
//
// To run manually:
//   cd <project_root>
//   go run .shipq/handler_compile/main.go
//
// Output: JSON array of handler definitions to stdout
// Errors: Written to stderr
//
package main

import (
	"encoding/json"
	"fmt"
	"os"

	"github.com/shipq/shipq/handler"
`)

	// Write imports for API packages
	if len(pkgs) > 0 {
		buf.WriteString("\n\t// API packages - importing to call their Register functions\n")
		for i, pkg := range pkgs {
			fmt.Fprintf(&buf, "\tapi%d %q\n", i, pkg)
		}
	}

	buf.WriteString(`)

// SerializedHandlerInfo is a JSON-serializable version of handler.HandlerInfo.
type SerializedHandlerInfo struct {
	Method      string                  ` + "`json:\"method\"`" + `
	Path        string                  ` + "`json:\"path\"`" + `
	PathParams  []SerializedPathParam   ` + "`json:\"path_params\"`" + `
	FuncName    string                  ` + "`json:\"func_name\"`" + `
	PackagePath string                  ` + "`json:\"package_path\"`" + `
	Request     *SerializedStructInfo   ` + "`json:\"request,omitempty\"`" + `
	Response    *SerializedStructInfo   ` + "`json:\"response,omitempty\"`" + `
}

type SerializedPathParam struct {
	Name     string ` + "`json:\"name\"`" + `
	Position int    ` + "`json:\"position\"`" + `
}

type SerializedStructInfo struct {
	Name    string                ` + "`json:\"name\"`" + `
	Package string                ` + "`json:\"package\"`" + `
	Fields  []SerializedFieldInfo ` + "`json:\"fields\"`" + `
}

type SerializedFieldInfo struct {
	Name     string            ` + "`json:\"name\"`" + `
	Type     string            ` + "`json:\"type\"`" + `
	JSONName string            ` + "`json:\"json_name\"`" + `
	JSONOmit bool              ` + "`json:\"json_omit\"`" + `
	Required bool              ` + "`json:\"required\"`" + `
	Tags     map[string]string ` + "`json:\"tags\"`" + `
}

func main() {
	app := handler.NewApp()

	// Call all Register functions
`)

	for i := range pkgs {
		fmt.Fprintf(&buf, "\tapi%d.Register(app)\n", i)
	}

	buf.WriteString(`
	// Get the registry
	registry := app.Registry()

	// Convert to serializable format
	serialized := make([]SerializedHandlerInfo, len(registry.Handlers))
	for i, h := range registry.Handlers {
		serialized[i] = SerializedHandlerInfo{
			Method:      string(h.Method),
			Path:        h.Path,
			PathParams:  convertPathParams(h.PathParams),
			FuncName:    h.FuncName,
			PackagePath: h.PackagePath,
			Request:     convertStructInfo(h.Request),
			Response:    convertStructInfo(h.Response),
		}
	}

	// Output as JSON
	data, err := json.MarshalIndent(serialized, "", "  ")
	if err != nil {
		fmt.Fprintf(os.Stderr, "error serializing handlers: %v\n", err)
		os.Exit(1)
	}

	os.Stdout.Write(data)
}

func convertPathParams(params []handler.PathParam) []SerializedPathParam {
	if params == nil {
		return []SerializedPathParam{}
	}
	result := make([]SerializedPathParam, len(params))
	for i, p := range params {
		result[i] = SerializedPathParam{
			Name:     p.Name,
			Position: p.Position,
		}
	}
	return result
}

func convertStructInfo(info *handler.StructInfo) *SerializedStructInfo {
	if info == nil {
		return nil
	}
	return &SerializedStructInfo{
		Name:    info.Name,
		Package: info.Package,
		Fields:  convertFields(info.Fields),
	}
}

func convertFields(fields []handler.FieldInfo) []SerializedFieldInfo {
	if fields == nil {
		return []SerializedFieldInfo{}
	}
	result := make([]SerializedFieldInfo, len(fields))
	for i, f := range fields {
		result[i] = SerializedFieldInfo{
			Name:     f.Name,
			Type:     f.Type,
			JSONName: f.JSONName,
			JSONOmit: f.JSONOmit,
			Required: f.Required,
			Tags:     f.Tags,
		}
	}
	return result
}
`)

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted source for debugging
		return buf.Bytes(), fmt.Errorf("failed to format handler compile program: %w", err)
	}

	return formatted, nil
}
