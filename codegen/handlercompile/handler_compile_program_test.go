package handlercompile

import (
	"strings"
	"testing"
)

func TestGenerateHandlerCompileProgram(t *testing.T) {
	tests := []struct {
		name     string
		cfg      HandlerCompileProgramConfig
		contains []string
	}{
		{
			name: "basic config with one package",
			cfg: HandlerCompileProgramConfig{
				ModulePath: "myapp",
				APIPkgs:    []string{"myapp/api/posts"},
			},
			contains: []string{
				"package main",
				`"github.com/shipq/shipq/handler"`,
				`api0 "myapp/api/posts"`,
				"api0.Register(app)",
				"app := handler.NewApp()",
				"registry := app.Registry()",
				"json.MarshalIndent",
			},
		},
		{
			name: "multiple packages",
			cfg: HandlerCompileProgramConfig{
				ModulePath: "github.com/example/myapp",
				APIPkgs: []string{
					"github.com/example/myapp/api/posts",
					"github.com/example/myapp/api/users",
					"github.com/example/myapp/api/comments",
				},
			},
			contains: []string{
				`api0 "github.com/example/myapp/api/comments"`, // sorted alphabetically
				`api1 "github.com/example/myapp/api/posts"`,
				`api2 "github.com/example/myapp/api/users"`,
				"api0.Register(app)",
				"api1.Register(app)",
				"api2.Register(app)",
			},
		},
		{
			name: "empty packages",
			cfg: HandlerCompileProgramConfig{
				ModulePath: "myapp",
				APIPkgs:    []string{},
			},
			contains: []string{
				"package main",
				"app := handler.NewApp()",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := GenerateHandlerCompileProgram(tt.cfg)
			if err != nil {
				t.Fatalf("unexpected error: %v", err)
			}

			code := string(result)

			for _, expected := range tt.contains {
				if !strings.Contains(code, expected) {
					t.Errorf("expected code to contain %q\nGot:\n%s", expected, code)
				}
			}
		})
	}
}

func TestGenerateHandlerCompileProgram_ValidGo(t *testing.T) {
	// Test that the generated code is valid Go
	cfg := HandlerCompileProgramConfig{
		ModulePath: "myapp",
		APIPkgs: []string{
			"myapp/api/posts",
			"myapp/api/users",
		},
	}

	result, err := GenerateHandlerCompileProgram(cfg)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	code := string(result)

	// Check for proper structure
	if !strings.HasPrefix(code, "// Code generated by shipq") {
		t.Error("expected generated code header")
	}

	// Check that it has the main function
	if !strings.Contains(code, "func main()") {
		t.Error("expected main function")
	}

	// Check for serialization types
	expectedTypes := []string{
		"type SerializedHandlerInfo struct",
		"type SerializedPathParam struct",
		"type SerializedStructInfo struct",
		"type SerializedFieldInfo struct",
	}

	for _, typ := range expectedTypes {
		if !strings.Contains(code, typ) {
			t.Errorf("expected code to contain %q", typ)
		}
	}

	// Check for helper functions
	expectedFuncs := []string{
		"func convertPathParams",
		"func convertStructInfo",
		"func convertFields",
	}

	for _, fn := range expectedFuncs {
		if !strings.Contains(code, fn) {
			t.Errorf("expected code to contain %q", fn)
		}
	}
}

func TestGenerateHandlerCompileProgram_DeterministicOutput(t *testing.T) {
	cfg := HandlerCompileProgramConfig{
		ModulePath: "myapp",
		APIPkgs: []string{
			"myapp/api/users",
			"myapp/api/posts",
			"myapp/api/comments",
		},
	}

	// Generate twice and verify same output
	result1, err := GenerateHandlerCompileProgram(cfg)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	result2, err := GenerateHandlerCompileProgram(cfg)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	if string(result1) != string(result2) {
		t.Error("expected deterministic output, but results differ")
	}
}

func TestGenerateHandlerCompileProgram_PackagesSorted(t *testing.T) {
	cfg := HandlerCompileProgramConfig{
		ModulePath: "myapp",
		APIPkgs: []string{
			"myapp/api/zebra",
			"myapp/api/alpha",
			"myapp/api/middle",
		},
	}

	result, err := GenerateHandlerCompileProgram(cfg)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	code := string(result)

	// Find positions of imports
	alphaPos := strings.Index(code, `"myapp/api/alpha"`)
	middlePos := strings.Index(code, `"myapp/api/middle"`)
	zebraPos := strings.Index(code, `"myapp/api/zebra"`)

	if alphaPos == -1 || middlePos == -1 || zebraPos == -1 {
		t.Fatal("expected all packages to be in output")
	}

	if !(alphaPos < middlePos && middlePos < zebraPos) {
		t.Error("expected packages to be sorted alphabetically")
	}
}

func TestGenerateHandlerCompileProgram_JSONTags(t *testing.T) {
	cfg := HandlerCompileProgramConfig{
		ModulePath: "myapp",
		APIPkgs:    []string{"myapp/api/posts"},
	}

	result, err := GenerateHandlerCompileProgram(cfg)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	code := string(result)

	// Verify JSON tags are present for serialization
	expectedTags := []string{
		"`json:\"method\"`",
		"`json:\"path\"`",
		"`json:\"path_params\"`",
		"`json:\"func_name\"`",
		"`json:\"package_path\"`",
		"`json:\"request,omitempty\"`",
		"`json:\"response,omitempty\"`",
		"`json:\"name\"`",
		"`json:\"position\"`",
		"`json:\"type\"`",
		"`json:\"json_name\"`",
		"`json:\"json_omit\"`",
		"`json:\"required\"`",
		"`json:\"tags\"`",
	}

	for _, tag := range expectedTags {
		if !strings.Contains(code, tag) {
			t.Errorf("expected code to contain JSON tag %q", tag)
		}
	}
}
