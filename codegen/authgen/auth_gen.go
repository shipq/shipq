package authgen

import (
	"bytes"
	"fmt"
	"go/format"
)

// generatedFileHeader is the standard header for generated auth handler files.
const generatedFileHeader = `// Code generated by shipq.
// NOTE: To regenerate this file, delete the .shipq-no-regen marker in this directory.
`

// AuthGenConfig holds configuration for generating auth handlers.
type AuthGenConfig struct {
	ModulePath string // e.g., "myapp" - the user's module path
}

// GenerateAuthHandlerFiles generates all auth handler files.
// Returns a map of filenames to their contents.
func GenerateAuthHandlerFiles(cfg AuthGenConfig) (map[string][]byte, error) {
	files := make(map[string][]byte)

	generators := map[string]func(AuthGenConfig) ([]byte, error){
		"login.go":    GenerateLoginHandler,
		"logout.go":   GenerateLogoutHandler,
		"me.go":       GenerateMeHandler,
		"signup.go":   GenerateSignupHandler,
		"register.go": GenerateRegister,
		"helpers.go":  GenerateHelpers,
	}

	for filename, generator := range generators {
		content, err := generator(cfg)
		if err != nil {
			return nil, fmt.Errorf("failed to generate %s: %w", filename, err)
		}
		files[filename] = content
	}

	return files, nil
}

// GenerateLoginHandler generates api/auth/login.go
func GenerateLoginHandler(cfg AuthGenConfig) ([]byte, error) {
	var buf bytes.Buffer

	buf.WriteString(generatedFileHeader)
	buf.WriteString("package auth\n\n")

	// Imports
	buf.WriteString("import (\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"net/http\"\n")
	buf.WriteString("\t\"time\"\n\n")
	buf.WriteString("\t\"github.com/shipq/shipq/crypto\"\n")
	buf.WriteString("\t\"github.com/shipq/shipq/httperror\"\n")
	buf.WriteString("\t\"github.com/shipq/shipq/httpserver\"\n")
	buf.WriteString("\t\"" + cfg.ModulePath + "/config\"\n")
	buf.WriteString(")\n\n")

	// Request struct
	buf.WriteString(`// LoginRequest is the request body for login.
type LoginRequest struct {
	Email    string ` + "`json:\"email\"`" + `
	Password string ` + "`json:\"password\"`" + `
}

`)

	// Response struct
	buf.WriteString(`// LoginResponse is the response body after successful login.
type LoginResponse struct {
	ID        string ` + "`json:\"id\"`" + `
	Email     string ` + "`json:\"email\"`" + `
	FirstName string ` + "`json:\"first_name\"`" + `
	LastName  string ` + "`json:\"last_name\"`" + `
}

`)

	// Handler function
	buf.WriteString(`// Login handles POST /login
func Login(ctx context.Context, req *LoginRequest) (*LoginResponse, error) {
	q := httpserver.GetQuerier(ctx)

	// Look up account by email
	account, err := findAccountByEmail(ctx, q, req.Email)
	if err != nil {
		return nil, httperror.Wrap(500, "failed to lookup account", err)
	}
	if account == nil {
		return nil, httperror.Unauthorized("invalid email or password")
	}

	// Verify password
	if !crypto.VerifyPassword(account.passwordHash, req.Password) {
		return nil, httperror.Unauthorized("invalid email or password")
	}

	// Create session with 2-week expiry
	session, err := createSession(ctx, q, account.id)
	if err != nil {
		return nil, httperror.Wrap(500, "failed to create session", err)
	}

	// Set session cookie
	setSessionCookie(ctx, session.publicID)

	return &LoginResponse{
		ID:        account.publicID,
		Email:     account.email,
		FirstName: account.firstName,
		LastName:  account.lastName,
	}, nil
}

// setSessionCookie sets the session cookie on the response.
func setSessionCookie(ctx context.Context, sessionID string) {
	secret := []byte(config.Settings.COOKIE_SECRET)
	signedValue := crypto.SignCookie(sessionID, secret)

	cookie := &http.Cookie{
		Name:     "session",
		Value:    signedValue,
		Path:     "/",
		HttpOnly: true,
		Secure:   config.Settings.GO_ENV != "development",
		SameSite: http.SameSiteLaxMode,
		MaxAge:   14 * 24 * 60 * 60, // 14 days
	}

	httpserver.SetCookie(ctx, cookie)
}
`)

	return formatSource(buf.Bytes())
}

// GenerateLogoutHandler generates api/auth/logout.go
func GenerateLogoutHandler(cfg AuthGenConfig) ([]byte, error) {
	var buf bytes.Buffer

	buf.WriteString(generatedFileHeader)
	buf.WriteString("package auth\n\n")

	// Imports
	buf.WriteString("import (\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"net/http\"\n\n")
	buf.WriteString("\t\"github.com/shipq/shipq/httperror\"\n")
	buf.WriteString("\t\"github.com/shipq/shipq/httpserver\"\n")
	buf.WriteString("\t\"" + cfg.ModulePath + "/config\"\n")
	buf.WriteString(")\n\n")

	// Request struct
	buf.WriteString(`// LogoutRequest is the request for logout (empty).
type LogoutRequest struct{}

`)

	// Response struct
	buf.WriteString(`// LogoutResponse is the response after successful logout.
type LogoutResponse struct {
	Success bool ` + "`json:\"success\"`" + `
}

`)

	// Handler function
	buf.WriteString(`// Logout handles DELETE /logout
func Logout(ctx context.Context, req *LogoutRequest) (*LogoutResponse, error) {
	q := httpserver.GetQuerier(ctx)

	// Get current session
	session, err := getCurrentSession(ctx, q, config.Settings.COOKIE_SECRET)
	if err != nil {
		return nil, httperror.Unauthorized("not logged in")
	}

	// Soft-delete the session
	if err := deleteSession(ctx, q, session.id); err != nil {
		return nil, httperror.Wrap(500, "failed to logout", err)
	}

	// Clear the session cookie
	clearSessionCookie(ctx)

	return &LogoutResponse{Success: true}, nil
}

// clearSessionCookie clears the session cookie.
func clearSessionCookie(ctx context.Context) {
	cookie := &http.Cookie{
		Name:     "session",
		Value:    "",
		Path:     "/",
		HttpOnly: true,
		Secure:   config.Settings.GO_ENV != "development",
		SameSite: http.SameSiteLaxMode,
		MaxAge:   -1, // Delete the cookie
	}

	httpserver.SetCookie(ctx, cookie)
}
`)

	return formatSource(buf.Bytes())
}

// GenerateMeHandler generates api/auth/me.go
func GenerateMeHandler(cfg AuthGenConfig) ([]byte, error) {
	var buf bytes.Buffer

	buf.WriteString(generatedFileHeader)
	buf.WriteString("package auth\n\n")

	// Imports
	buf.WriteString("import (\n")
	buf.WriteString("\t\"context\"\n\n")
	buf.WriteString("\t\"github.com/shipq/shipq/httperror\"\n")
	buf.WriteString("\t\"github.com/shipq/shipq/httpserver\"\n")
	buf.WriteString("\t\"" + cfg.ModulePath + "/config\"\n")
	buf.WriteString(")\n\n")

	// Request struct
	buf.WriteString(`// MeRequest is the request for getting current user (empty).
type MeRequest struct{}

`)

	// OrgInfo struct
	buf.WriteString(`// OrgInfo contains organization information.
type OrgInfo struct {
	ID          string ` + "`json:\"id\"`" + `
	Name        string ` + "`json:\"name\"`" + `
	Description string ` + "`json:\"description,omitempty\"`" + `
}

`)

	// Response struct
	buf.WriteString(`// MeResponse is the response with current user info.
type MeResponse struct {
	ID           string   ` + "`json:\"id\"`" + `
	Email        string   ` + "`json:\"email\"`" + `
	FirstName    string   ` + "`json:\"first_name\"`" + `
	LastName     string   ` + "`json:\"last_name\"`" + `
	Organization *OrgInfo ` + "`json:\"organization,omitempty\"`" + `
}

`)

	// Handler function
	buf.WriteString(`// Me handles GET /me
func Me(ctx context.Context, req *MeRequest) (*MeResponse, error) {
	q := httpserver.GetQuerier(ctx)

	// Get current session
	session, err := getCurrentSession(ctx, q, config.Settings.COOKIE_SECRET)
	if err != nil {
		return nil, httperror.Unauthorized("not logged in")
	}

	// Get account from session
	account, err := findAccountByID(ctx, q, session.accountID)
	if err != nil {
		return nil, httperror.Wrap(500, "failed to get account", err)
	}
	if account == nil {
		return nil, httperror.Unauthorized("account not found")
	}

	resp := &MeResponse{
		ID:        account.publicID,
		Email:     account.email,
		FirstName: account.firstName,
		LastName:  account.lastName,
	}

	// Include default organization if set
	if account.defaultOrgID != nil {
		org, err := findOrganizationByID(ctx, q, *account.defaultOrgID)
		if err == nil && org != nil {
			resp.Organization = &OrgInfo{
				ID:          org.publicID,
				Name:        org.name,
				Description: org.description,
			}
		}
	}

	return resp, nil
}
`)

	return formatSource(buf.Bytes())
}

// GenerateSignupHandler generates api/auth/signup.go
func GenerateSignupHandler(cfg AuthGenConfig) ([]byte, error) {
	var buf bytes.Buffer

	buf.WriteString(generatedFileHeader)
	buf.WriteString("package auth\n\n")

	// Imports
	buf.WriteString("import (\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"fmt\"\n\n")
	buf.WriteString("\t\"github.com/shipq/shipq/crypto\"\n")
	buf.WriteString("\t\"github.com/shipq/shipq/httperror\"\n")
	buf.WriteString("\t\"github.com/shipq/shipq/httpserver\"\n")
	buf.WriteString("\t\"" + cfg.ModulePath + "/config\"\n")
	buf.WriteString(")\n\n")

	// Request struct
	buf.WriteString(`// SignupRequest is the request body for signup.
type SignupRequest struct {
	Email     string ` + "`json:\"email\"`" + `
	Password  string ` + "`json:\"password\"`" + `
	FirstName string ` + "`json:\"first_name\"`" + `
	LastName  string ` + "`json:\"last_name\"`" + `
}

`)

	// Response struct
	buf.WriteString(`// SignupResponse is the response body after successful signup.
type SignupResponse struct {
	ID        string ` + "`json:\"id\"`" + `
	Email     string ` + "`json:\"email\"`" + `
	FirstName string ` + "`json:\"first_name\"`" + `
	LastName  string ` + "`json:\"last_name\"`" + `
}

`)

	// Handler function
	buf.WriteString(`// Signup handles POST /signup
func Signup(ctx context.Context, req *SignupRequest) (*SignupResponse, error) {
	q := httpserver.GetQuerier(ctx)

	// Check if email is already taken
	existing, err := findAccountByEmail(ctx, q, req.Email)
	if err != nil {
		return nil, httperror.Wrap(500, "failed to check email", err)
	}
	if existing != nil {
		return nil, httperror.Conflict("email already taken")
	}

	// Hash password
	passwordHash, err := crypto.HashPassword(req.Password)
	if err != nil {
		return nil, httperror.Wrap(500, "failed to hash password", err)
	}

	// Create organization with auto-generated name
	orgName := fmt.Sprintf("%s's Organization", req.FirstName)
	org, err := createOrganization(ctx, q, orgName, "")
	if err != nil {
		return nil, httperror.Wrap(500, "failed to create organization", err)
	}

	// Create account
	account, err := createAccount(ctx, q, req.Email, req.FirstName, req.LastName, passwordHash, org.id)
	if err != nil {
		return nil, httperror.Wrap(500, "failed to create account", err)
	}

	// Create organization_users link
	if err := createOrganizationUser(ctx, q, org.id, account.id); err != nil {
		return nil, httperror.Wrap(500, "failed to link account to organization", err)
	}

	// Create session
	session, err := createSession(ctx, q, account.id)
	if err != nil {
		return nil, httperror.Wrap(500, "failed to create session", err)
	}

	// Set session cookie
	setSessionCookie(ctx, session.publicID)

	return &SignupResponse{
		ID:        account.publicID,
		Email:     account.email,
		FirstName: account.firstName,
		LastName:  account.lastName,
	}, nil
}
`)

	return formatSource(buf.Bytes())
}

// GenerateRegister generates api/auth/register.go
func GenerateRegister(cfg AuthGenConfig) ([]byte, error) {
	var buf bytes.Buffer

	buf.WriteString(generatedFileHeader)
	buf.WriteString("package auth\n\n")

	// Import
	buf.WriteString("import \"github.com/shipq/shipq/handler\"\n\n")

	// Register function
	buf.WriteString(`// Register registers all auth handlers with the app.
func Register(app *handler.App) {
	app.Post("/login", Login)
	app.Delete("/logout", Logout)
	app.Get("/me", Me)
	app.Post("/signup", Signup)
}
`)

	return formatSource(buf.Bytes())
}

// GenerateHelpers generates api/auth/helpers.go
func GenerateHelpers(cfg AuthGenConfig) ([]byte, error) {
	var buf bytes.Buffer

	buf.WriteString(generatedFileHeader)
	buf.WriteString("package auth\n\n")

	// Imports
	buf.WriteString("import (\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"database/sql\"\n")
	buf.WriteString("\t\"time\"\n\n")
	buf.WriteString("\t\"github.com/shipq/shipq/crypto\"\n")
	buf.WriteString("\t\"github.com/shipq/shipq/httpserver\"\n")
	buf.WriteString("\t\"github.com/shipq/shipq/nanoid\"\n")
	buf.WriteString(")\n\n")

	// Internal structs
	buf.WriteString(`// Internal structs for database operations

type accountRecord struct {
	id           int64
	publicID     string
	email        string
	firstName    string
	lastName     string
	passwordHash []byte
	defaultOrgID *int64
}

type sessionRecord struct {
	id        int64
	publicID  string
	accountID int64
	expiresAt time.Time
}

type organizationRecord struct {
	id          int64
	publicID    string
	name        string
	description string
}

`)

	// Helper functions
	buf.WriteString(`// findAccountByEmail looks up an account by email.
func findAccountByEmail(ctx context.Context, q httpserver.Querier, email string) (*accountRecord, error) {
	row := q.QueryRowContext(ctx, ` + "`" + `
		SELECT id, public_id, email, first_name, last_name, password_hash, default_organization_id
		FROM accounts
		WHERE email = ? AND deleted_at IS NULL
	` + "`" + `, email)

	var a accountRecord
	err := row.Scan(&a.id, &a.publicID, &a.email, &a.firstName, &a.lastName, &a.passwordHash, &a.defaultOrgID)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}
	return &a, nil
}

// findAccountByID looks up an account by internal ID.
func findAccountByID(ctx context.Context, q httpserver.Querier, id int64) (*accountRecord, error) {
	row := q.QueryRowContext(ctx, ` + "`" + `
		SELECT id, public_id, email, first_name, last_name, password_hash, default_organization_id
		FROM accounts
		WHERE id = ? AND deleted_at IS NULL
	` + "`" + `, id)

	var a accountRecord
	err := row.Scan(&a.id, &a.publicID, &a.email, &a.firstName, &a.lastName, &a.passwordHash, &a.defaultOrgID)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}
	return &a, nil
}

// findOrganizationByID looks up an organization by internal ID.
func findOrganizationByID(ctx context.Context, q httpserver.Querier, id int64) (*organizationRecord, error) {
	row := q.QueryRowContext(ctx, ` + "`" + `
		SELECT id, public_id, name, COALESCE(description, '')
		FROM organizations
		WHERE id = ? AND deleted_at IS NULL
	` + "`" + `, id)

	var o organizationRecord
	err := row.Scan(&o.id, &o.publicID, &o.name, &o.description)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}
	return &o, nil
}

// createSession creates a new session for an account.
func createSession(ctx context.Context, q httpserver.Querier, accountID int64) (*sessionRecord, error) {
	publicID := nanoid.New()
	now := time.Now().UTC()
	expiresAt := now.Add(14 * 24 * time.Hour) // 2 weeks

	_, err := q.ExecContext(ctx, ` + "`" + `
		INSERT INTO sessions (public_id, account_id, expires_at, created_at, updated_at)
		VALUES (?, ?, ?, ?, ?)
	` + "`" + `, publicID, accountID, expiresAt, now, now)
	if err != nil {
		return nil, err
	}

	return &sessionRecord{
		publicID:  publicID,
		accountID: accountID,
		expiresAt: expiresAt,
	}, nil
}

// getCurrentSession gets the current session from the request cookie.
func getCurrentSession(ctx context.Context, q httpserver.Querier, cookieSecret string) (*sessionRecord, error) {
	cookie, err := httpserver.GetCookie(ctx, "session")
	if err != nil {
		return nil, err
	}

	sessionID, err := crypto.VerifyCookie(cookie.Value, []byte(cookieSecret))
	if err != nil {
		return nil, err
	}

	row := q.QueryRowContext(ctx, ` + "`" + `
		SELECT id, public_id, account_id, expires_at
		FROM sessions
		WHERE public_id = ? AND deleted_at IS NULL AND expires_at > ?
	` + "`" + `, sessionID, time.Now().UTC())

	var s sessionRecord
	err = row.Scan(&s.id, &s.publicID, &s.accountID, &s.expiresAt)
	if err == sql.ErrNoRows {
		return nil, err
	}
	if err != nil {
		return nil, err
	}
	return &s, nil
}

// deleteSession soft-deletes a session.
func deleteSession(ctx context.Context, q httpserver.Querier, sessionID int64) error {
	_, err := q.ExecContext(ctx, ` + "`" + `
		UPDATE sessions SET deleted_at = ? WHERE id = ?
	` + "`" + `, time.Now().UTC(), sessionID)
	return err
}

// createOrganization creates a new organization.
func createOrganization(ctx context.Context, q httpserver.Querier, name, description string) (*organizationRecord, error) {
	publicID := nanoid.New()
	now := time.Now().UTC()

	result, err := q.ExecContext(ctx, ` + "`" + `
		INSERT INTO organizations (public_id, name, description, created_at, updated_at)
		VALUES (?, ?, ?, ?, ?)
	` + "`" + `, publicID, name, description, now, now)
	if err != nil {
		return nil, err
	}

	id, err := result.LastInsertId()
	if err != nil {
		return nil, err
	}

	return &organizationRecord{
		id:          id,
		publicID:    publicID,
		name:        name,
		description: description,
	}, nil
}

// createAccount creates a new account.
func createAccount(ctx context.Context, q httpserver.Querier, email, firstName, lastName string, passwordHash []byte, defaultOrgID int64) (*accountRecord, error) {
	publicID := nanoid.New()
	now := time.Now().UTC()

	result, err := q.ExecContext(ctx, ` + "`" + `
		INSERT INTO accounts (public_id, email, first_name, last_name, password_hash, default_organization_id, created_at, updated_at)
		VALUES (?, ?, ?, ?, ?, ?, ?, ?)
	` + "`" + `, publicID, email, firstName, lastName, passwordHash, defaultOrgID, now, now)
	if err != nil {
		return nil, err
	}

	id, err := result.LastInsertId()
	if err != nil {
		return nil, err
	}

	return &accountRecord{
		id:           id,
		publicID:     publicID,
		email:        email,
		firstName:    firstName,
		lastName:     lastName,
		passwordHash: passwordHash,
		defaultOrgID: &defaultOrgID,
	}, nil
}

// createOrganizationUser links an account to an organization.
func createOrganizationUser(ctx context.Context, q httpserver.Querier, orgID, accountID int64) error {
	_, err := q.ExecContext(ctx, ` + "`" + `
		INSERT INTO organization_users (organization_id, account_id)
		VALUES (?, ?)
	` + "`" + `, orgID, accountID)
	return err
}
`)

	return formatSource(buf.Bytes())
}

// formatSource formats Go source code, returning the original if formatting fails.
func formatSource(src []byte) ([]byte, error) {
	formatted, err := format.Source(src)
	if err != nil {
		return src, fmt.Errorf("failed to format source: %w\n%s", err, src)
	}
	return formatted, nil
}
