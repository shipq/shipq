package codegen

import (
	"bytes"
	"fmt"
	"go/format"
	"go/token"
	"regexp"
	"sort"
	"strings"
)

// HTTPServerGenConfig holds configuration for generating the HTTP server.
type HTTPServerGenConfig struct {
	ModulePath string                  // e.g., "myapp"
	Handlers   []SerializedHandlerInfo // handlers from registry
	OutputPkg  string                  // package name for generated code (e.g., "api")
}

// GenerateHTTPServer generates the HTTP server code from the handler registry.
func GenerateHTTPServer(cfg HTTPServerGenConfig) ([]byte, error) {
	var buf bytes.Buffer

	// Collect unique handler package imports
	handlerPkgs := collectHandlerPackages(cfg.Handlers)

	// Generate file header
	buf.WriteString("// Code generated by shipq. DO NOT EDIT.\n")
	fmt.Fprintf(&buf, "package %s\n\n", cfg.OutputPkg)

	// Generate imports
	generateImports(&buf, handlerPkgs, cfg.ModulePath, cfg.Handlers)

	// Generate helper functions
	generateHelperFunctions(&buf)

	// Generate NewMux function
	generateNewMux(&buf, cfg.Handlers, handlerPkgs)

	// Generate individual handler wrappers
	for _, h := range cfg.Handlers {
		generateHandlerWrapper(&buf, h, handlerPkgs)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted source for debugging
		return buf.Bytes(), fmt.Errorf("failed to format HTTP server code: %w\nunformatted:\n%s", err, buf.String())
	}

	return formatted, nil
}

// ConvertPathSyntax converts :param syntax to {param} syntax for Go 1.22 ServeMux.
func ConvertPathSyntax(path string) string {
	// Match :paramName pattern
	re := regexp.MustCompile(`:([a-zA-Z_][a-zA-Z0-9_]*)`)
	return re.ReplaceAllString(path, "{$1}")
}

// packageAlias holds information about an imported package.
type packageAlias struct {
	Path  string
	Alias string
}

// collectHandlerPackages extracts unique package paths from handlers and assigns aliases.
func collectHandlerPackages(handlers []SerializedHandlerInfo) map[string]packageAlias {
	pkgPaths := make(map[string]bool)
	for _, h := range handlers {
		if h.PackagePath != "" {
			pkgPaths[h.PackagePath] = true
		}
	}

	// Sort for deterministic output
	var paths []string
	for path := range pkgPaths {
		paths = append(paths, path)
	}
	sort.Strings(paths)

	// Assign unique aliases
	result := make(map[string]packageAlias)
	usedAliases := make(map[string]int)

	for _, path := range paths {
		// Extract base name from path
		parts := strings.Split(path, "/")
		baseName := parts[len(parts)-1]

		// If base name is a Go keyword, prefix it
		if token.Lookup(baseName).IsKeyword() {
			baseName = "pkg_" + baseName
		}

		// Make alias unique if needed
		alias := baseName
		if count, exists := usedAliases[baseName]; exists {
			alias = fmt.Sprintf("%s%d", baseName, count+1)
			usedAliases[baseName] = count + 1
		} else {
			usedAliases[baseName] = 1
		}

		result[path] = packageAlias{
			Path:  path,
			Alias: alias,
		}
	}

	return result
}

// needsStrconv checks if any handler needs strconv for type conversion.
func needsStrconv(handlers []SerializedHandlerInfo) bool {
	for _, h := range handlers {
		if h.Request == nil {
			continue
		}
		for _, field := range h.Request.Fields {
			// Check if this field is bound from a path param
			for _, param := range h.PathParams {
				if strings.EqualFold(field.JSONName, param.Name) || strings.EqualFold(field.Name, param.Name) {
					// Path params are always strings, so non-string types need conversion
					if field.Type != "string" && !strings.HasPrefix(field.Type, "*") {
						return true
					}
				}
			}
		}
	}
	return false
}

// generateImports writes the import block.
func generateImports(buf *bytes.Buffer, handlerPkgs map[string]packageAlias, modulePath string, handlers []SerializedHandlerInfo) {
	buf.WriteString("import (\n")
	buf.WriteString("\t\"encoding/json\"\n")
	buf.WriteString("\t\"errors\"\n")
	buf.WriteString("\t\"net/http\"\n")

	if needsStrconv(handlers) {
		buf.WriteString("\t\"strconv\"\n")
	}

	buf.WriteString("\n")
	buf.WriteString("\t\"github.com/shipq/shipq/httperror\"\n")
	buf.WriteString("\t\"github.com/shipq/shipq/httpserver\"\n")

	// Handler packages
	if len(handlerPkgs) > 0 {
		buf.WriteString("\n")

		// Sort by alias for deterministic output
		var aliases []packageAlias
		for _, pkg := range handlerPkgs {
			aliases = append(aliases, pkg)
		}
		sort.Slice(aliases, func(i, j int) bool {
			return aliases[i].Alias < aliases[j].Alias
		})

		for _, pkg := range aliases {
			fmt.Fprintf(buf, "\t%s %q\n", pkg.Alias, pkg.Path)
		}
	}

	buf.WriteString(")\n\n")
}

// generateHelperFunctions writes the helper functions (writeJSON, writeError, wrapHandler).
func generateHelperFunctions(buf *bytes.Buffer) {
	// writeJSON helper
	buf.WriteString(`// writeJSON writes a JSON response with the given status code.
func writeJSON(w http.ResponseWriter, status int, v any) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	json.NewEncoder(w).Encode(v)
}

`)

	// writeError helper
	buf.WriteString(`// writeError writes an error response.
func writeError(w http.ResponseWriter, err error) {
	var httpErr *httperror.Error
	if errors.As(err, &httpErr) {
		writeJSON(w, httpErr.Code(), map[string]string{"error": httpErr.Message()})
		return
	}
	writeJSON(w, http.StatusInternalServerError, map[string]string{"error": "internal server error"})
}

`)

	// wrapHandler helper
	buf.WriteString(`// wrapHandler injects the Querier into context.
func wrapHandler(q httpserver.Querier, h http.HandlerFunc) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := httpserver.WithQuerier(r.Context(), q)
		r = r.WithContext(ctx)
		h(w, r)
	})
}

`)
}

// generateNewMux writes the NewMux function.
func generateNewMux(buf *bytes.Buffer, handlers []SerializedHandlerInfo, handlerPkgs map[string]packageAlias) {
	buf.WriteString(`// NewMux creates an http.ServeMux with all registered handlers.
// The provided Querier will be injected into each request's context.
func NewMux(q httpserver.Querier) *http.ServeMux {
	mux := http.NewServeMux()

`)

	for _, h := range handlers {
		convertedPath := ConvertPathSyntax(h.Path)
		wrapperName := handlerWrapperName(h)
		fmt.Fprintf(buf, "\tmux.Handle(\"%s %s\", wrapHandler(q, %s))\n", h.Method, convertedPath, wrapperName)
	}

	buf.WriteString(`
	return mux
}

`)
}

// handlerWrapperName returns the name of the generated wrapper function for a handler.
func handlerWrapperName(h SerializedHandlerInfo) string {
	return "handle" + h.FuncName
}

// generateHandlerWrapper writes a single handler wrapper function.
func generateHandlerWrapper(buf *bytes.Buffer, h SerializedHandlerInfo, handlerPkgs map[string]packageAlias) {
	wrapperName := handlerWrapperName(h)
	fmt.Fprintf(buf, "func %s(w http.ResponseWriter, r *http.Request) {\n", wrapperName)

	// Get the package alias for this handler
	pkgAlias := ""
	if pkg, ok := handlerPkgs[h.PackagePath]; ok {
		pkgAlias = pkg.Alias
	}

	// Determine if we need to declare a request variable
	hasRequest := h.Request != nil && (len(h.Request.Fields) > 0 || len(h.PathParams) > 0)
	needsJSONBody := hasRequest && methodHasBody(h.Method)

	if hasRequest {
		// Declare request variable
		reqType := h.Request.Name
		if pkgAlias != "" {
			reqType = pkgAlias + "." + reqType
		}
		fmt.Fprintf(buf, "\tvar req %s\n\n", reqType)

		// Bind path parameters first
		if len(h.PathParams) > 0 {
			generatePathParamBinding(buf, h)
		}

		// Bind JSON body for POST/PUT/PATCH
		if needsJSONBody {
			generateJSONBodyBinding(buf, h)
		}
	}

	// Call the actual handler
	buf.WriteString("\t// Call the actual handler\n")
	handlerCall := h.FuncName
	if pkgAlias != "" {
		handlerCall = pkgAlias + "." + h.FuncName
	}

	if hasRequest {
		fmt.Fprintf(buf, "\tresp, err := %s(r.Context(), req)\n", handlerCall)
	} else {
		// For handlers with no request, still need to pass something
		reqType := "struct{}"
		if h.Request != nil {
			reqType = h.Request.Name
			if pkgAlias != "" {
				reqType = pkgAlias + "." + reqType
			}
		}
		fmt.Fprintf(buf, "\tresp, err := %s(r.Context(), %s{})\n", handlerCall, reqType)
	}

	buf.WriteString("\tif err != nil {\n")
	buf.WriteString("\t\twriteError(w, err)\n")
	buf.WriteString("\t\treturn\n")
	buf.WriteString("\t}\n\n")

	// Write response
	statusCode := successStatusCode(h.Method)
	fmt.Fprintf(buf, "\twriteJSON(w, %s, resp)\n", statusCode)

	buf.WriteString("}\n\n")
}

// methodHasBody returns true if the HTTP method typically has a request body.
func methodHasBody(method string) bool {
	switch method {
	case "POST", "PUT", "PATCH":
		return true
	default:
		return false
	}
}

// successStatusCode returns the appropriate success status code for an HTTP method.
func successStatusCode(method string) string {
	switch method {
	case "POST":
		return "http.StatusCreated"
	default:
		return "http.StatusOK"
	}
}

// generatePathParamBinding generates code to bind path parameters to request fields.
func generatePathParamBinding(buf *bytes.Buffer, h SerializedHandlerInfo) {
	buf.WriteString("\t// Bind path parameters\n")

	for _, param := range h.PathParams {
		// Find the matching field in the request struct
		var matchedField *SerializedFieldInfo
		for i := range h.Request.Fields {
			field := &h.Request.Fields[i]
			if strings.EqualFold(field.JSONName, param.Name) || strings.EqualFold(field.Name, param.Name) {
				matchedField = field
				break
			}
		}

		if matchedField == nil {
			// No matching field, skip
			continue
		}

		// Generate binding code based on field type
		switch matchedField.Type {
		case "string":
			fmt.Fprintf(buf, "\treq.%s = r.PathValue(%q)\n", matchedField.Name, param.Name)
		case "int":
			fmt.Fprintf(buf, "\tif v, err := strconv.Atoi(r.PathValue(%q)); err != nil {\n", param.Name)
			fmt.Fprintf(buf, "\t\twriteError(w, httperror.BadRequest(\"invalid %s parameter\"))\n", param.Name)
			buf.WriteString("\t\treturn\n")
			buf.WriteString("\t} else {\n")
			fmt.Fprintf(buf, "\t\treq.%s = v\n", matchedField.Name)
			buf.WriteString("\t}\n")
		case "int64":
			fmt.Fprintf(buf, "\tif v, err := strconv.ParseInt(r.PathValue(%q), 10, 64); err != nil {\n", param.Name)
			fmt.Fprintf(buf, "\t\twriteError(w, httperror.BadRequest(\"invalid %s parameter\"))\n", param.Name)
			buf.WriteString("\t\treturn\n")
			buf.WriteString("\t} else {\n")
			fmt.Fprintf(buf, "\t\treq.%s = v\n", matchedField.Name)
			buf.WriteString("\t}\n")
		case "int32":
			fmt.Fprintf(buf, "\tif v, err := strconv.ParseInt(r.PathValue(%q), 10, 32); err != nil {\n", param.Name)
			fmt.Fprintf(buf, "\t\twriteError(w, httperror.BadRequest(\"invalid %s parameter\"))\n", param.Name)
			buf.WriteString("\t\treturn\n")
			buf.WriteString("\t} else {\n")
			fmt.Fprintf(buf, "\t\treq.%s = int32(v)\n", matchedField.Name)
			buf.WriteString("\t}\n")
		case "uint64":
			fmt.Fprintf(buf, "\tif v, err := strconv.ParseUint(r.PathValue(%q), 10, 64); err != nil {\n", param.Name)
			fmt.Fprintf(buf, "\t\twriteError(w, httperror.BadRequest(\"invalid %s parameter\"))\n", param.Name)
			buf.WriteString("\t\treturn\n")
			buf.WriteString("\t} else {\n")
			fmt.Fprintf(buf, "\t\treq.%s = v\n", matchedField.Name)
			buf.WriteString("\t}\n")
		default:
			// For other types, try to use string and let the handler deal with it
			fmt.Fprintf(buf, "\treq.%s = r.PathValue(%q)\n", matchedField.Name, param.Name)
		}
	}

	buf.WriteString("\n")
}

// generateJSONBodyBinding generates code to decode the JSON request body.
func generateJSONBodyBinding(buf *bytes.Buffer, h SerializedHandlerInfo) {
	buf.WriteString("\t// Bind JSON body\n")
	buf.WriteString("\tif err := json.NewDecoder(r.Body).Decode(&req); err != nil {\n")
	buf.WriteString("\t\twriteError(w, httperror.BadRequest(\"invalid JSON body\"))\n")
	buf.WriteString("\t\treturn\n")
	buf.WriteString("\t}\n\n")
}
