package codegen

import (
	"bytes"
	"fmt"
	"go/format"
)

// HTTPMainGenConfig holds configuration for generating the main.go entrypoint.
type HTTPMainGenConfig struct {
	ModulePath string // e.g., "myapp"
	OutputPkg  string // package containing generated HTTP server (e.g., "api")
	DBDialect  string // "mysql", "postgres", or "sqlite"
	Port       string // server port (default: "8080")
}

// GenerateHTTPMain generates the main.go entrypoint for the HTTP server.
func GenerateHTTPMain(cfg HTTPMainGenConfig) ([]byte, error) {
	if cfg.Port == "" {
		cfg.Port = "8080"
	}

	var buf bytes.Buffer

	buf.WriteString("// Code generated by shipq. DO NOT EDIT.\n")
	buf.WriteString("package main\n\n")

	// Generate imports
	generateMainImports(&buf, cfg)

	// Generate main function
	generateMainFunc(&buf, cfg)

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted source for debugging
		return buf.Bytes(), fmt.Errorf("failed to format main.go: %w\nunformatted:\n%s", err, buf.String())
	}

	return formatted, nil
}

// generateMainImports writes the import block for main.go.
func generateMainImports(buf *bytes.Buffer, cfg HTTPMainGenConfig) {
	buf.WriteString("import (\n")
	buf.WriteString("\t\"database/sql\"\n")
	buf.WriteString("\t\"log\"\n")
	buf.WriteString("\t\"net/http\"\n")
	buf.WriteString("\t\"os\"\n")
	buf.WriteString("\n")

	// API package import
	apiPkg := cfg.ModulePath + "/" + cfg.OutputPkg
	fmt.Fprintf(buf, "\t%q\n", apiPkg)
	buf.WriteString("\n")

	// Database driver import
	driverImport := getDriverImport(cfg.DBDialect)
	fmt.Fprintf(buf, "\t_ %q\n", driverImport)

	buf.WriteString(")\n\n")
}

// generateMainFunc writes the main function.
func generateMainFunc(buf *bytes.Buffer, cfg HTTPMainGenConfig) {
	driverName := getDriverName(cfg.DBDialect)
	envVar := getDatabaseEnvVar(cfg.DBDialect)

	buf.WriteString("func main() {\n")

	// Database connection
	fmt.Fprintf(buf, "\tdbURL := os.Getenv(%q)\n", envVar)
	buf.WriteString("\tif dbURL == \"\" {\n")
	fmt.Fprintf(buf, "\t\tlog.Fatal(\"%s environment variable is required\")\n", envVar)
	buf.WriteString("\t}\n\n")

	fmt.Fprintf(buf, "\tdb, err := sql.Open(%q, dbURL)\n", driverName)
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString("\t\tlog.Fatal(err)\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tdefer db.Close()\n\n")

	// Verify connection
	buf.WriteString("\tif err := db.Ping(); err != nil {\n")
	buf.WriteString("\t\tlog.Fatal(\"failed to connect to database: \", err)\n")
	buf.WriteString("\t}\n\n")

	// Create mux and start server
	buf.WriteString("\tmux := api.NewMux(db)\n\n")

	fmt.Fprintf(buf, "\tlog.Println(\"Starting server on :%s\")\n", cfg.Port)
	fmt.Fprintf(buf, "\tif err := http.ListenAndServe(\":%s\", mux); err != nil {\n", cfg.Port)
	buf.WriteString("\t\tlog.Fatal(err)\n")
	buf.WriteString("\t}\n")

	buf.WriteString("}\n")
}

// getDriverImport returns the import path for the database driver.
func getDriverImport(dialect string) string {
	switch dialect {
	case "postgres":
		return "github.com/jackc/pgx/v5/stdlib"
	case "sqlite":
		return "modernc.org/sqlite"
	case "mysql":
		return "github.com/go-sql-driver/mysql"
	default:
		// Default to mysql
		return "github.com/go-sql-driver/mysql"
	}
}

// getDriverName returns the driver name for sql.Open().
func getDriverName(dialect string) string {
	switch dialect {
	case "postgres":
		return "pgx"
	case "sqlite":
		return "sqlite"
	case "mysql":
		return "mysql"
	default:
		return "mysql"
	}
}

// getDatabaseEnvVar returns the environment variable name for the database URL.
func getDatabaseEnvVar(dialect string) string {
	return "DATABASE_URL"
}
