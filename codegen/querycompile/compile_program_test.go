package querycompile

import (
	"strings"
	"testing"
)

func TestGenerateCompileProgram_Empty(t *testing.T) {
	cfg := CompileProgramConfig{
		ModulePath:    "example.com/myapp",
		QuerydefsPkgs: nil,
	}

	code, err := GenerateCompileProgram(cfg)
	if err != nil {
		t.Fatalf("GenerateCompileProgram failed: %v", err)
	}

	codeStr := string(code)

	// Should contain package declaration
	if !strings.Contains(codeStr, "package main") {
		t.Error("expected 'package main' in generated code")
	}

	// Should import the query package
	if !strings.Contains(codeStr, `"github.com/shipq/shipq/db/portsql/query"`) {
		t.Error("expected query package import in generated code")
	}

	// Should call SerializeQueries
	if !strings.Contains(codeStr, "query.SerializeQueries()") {
		t.Error("expected call to query.SerializeQueries() in generated code")
	}

	// Should NOT have querydefs imports comment since there are no packages
	if strings.Contains(codeStr, "Querydefs packages") {
		t.Error("should not have querydefs comment when no packages")
	}
}

func TestGenerateCompileProgram_SinglePackage(t *testing.T) {
	cfg := CompileProgramConfig{
		ModulePath:    "example.com/myapp",
		QuerydefsPkgs: []string{"example.com/myapp/querydefs"},
	}

	code, err := GenerateCompileProgram(cfg)
	if err != nil {
		t.Fatalf("GenerateCompileProgram failed: %v", err)
	}

	codeStr := string(code)

	// Should have blank import for querydefs
	if !strings.Contains(codeStr, `_ "example.com/myapp/querydefs"`) {
		t.Errorf("expected blank import for querydefs, got:\n%s", codeStr)
	}

	// Should have comment about querydefs packages
	if !strings.Contains(codeStr, "Querydefs packages") {
		t.Error("expected querydefs comment in generated code")
	}
}

func TestGenerateCompileProgram_MultiplePackages(t *testing.T) {
	cfg := CompileProgramConfig{
		ModulePath: "example.com/myapp",
		QuerydefsPkgs: []string{
			"example.com/myapp/querydefs",
			"example.com/myapp/querydefs/users",
			"example.com/myapp/querydefs/orders",
		},
	}

	code, err := GenerateCompileProgram(cfg)
	if err != nil {
		t.Fatalf("GenerateCompileProgram failed: %v", err)
	}

	codeStr := string(code)

	// Should have all three blank imports
	if !strings.Contains(codeStr, `_ "example.com/myapp/querydefs"`) {
		t.Error("expected blank import for querydefs")
	}
	if !strings.Contains(codeStr, `_ "example.com/myapp/querydefs/users"`) {
		t.Error("expected blank import for querydefs/users")
	}
	if !strings.Contains(codeStr, `_ "example.com/myapp/querydefs/orders"`) {
		t.Error("expected blank import for querydefs/orders")
	}
}

func TestGenerateCompileProgram_SortedImports(t *testing.T) {
	cfg := CompileProgramConfig{
		ModulePath: "example.com/myapp",
		QuerydefsPkgs: []string{
			"example.com/myapp/querydefs/orders", // Out of order
			"example.com/myapp/querydefs",
			"example.com/myapp/querydefs/users",
		},
	}

	code, err := GenerateCompileProgram(cfg)
	if err != nil {
		t.Fatalf("GenerateCompileProgram failed: %v", err)
	}

	codeStr := string(code)

	// Find positions of imports
	posQuerydefs := strings.Index(codeStr, `_ "example.com/myapp/querydefs"`)
	posOrders := strings.Index(codeStr, `_ "example.com/myapp/querydefs/orders"`)
	posUsers := strings.Index(codeStr, `_ "example.com/myapp/querydefs/users"`)

	// They should be in alphabetical order
	if posQuerydefs > posOrders {
		t.Error("querydefs should come before querydefs/orders")
	}
	if posOrders > posUsers {
		t.Error("querydefs/orders should come before querydefs/users")
	}
}

func TestGenerateCompileProgram_ValidGo(t *testing.T) {
	cfg := CompileProgramConfig{
		ModulePath: "example.com/myapp",
		QuerydefsPkgs: []string{
			"example.com/myapp/querydefs",
			"example.com/myapp/querydefs/users",
		},
	}

	code, err := GenerateCompileProgram(cfg)
	if err != nil {
		t.Fatalf("GenerateCompileProgram failed: %v", err)
	}

	codeStr := string(code)

	// Check for required elements of valid Go code
	if !strings.Contains(codeStr, "func main()") {
		t.Error("expected func main() in generated code")
	}

	if !strings.Contains(codeStr, "import (") {
		t.Error("expected import block in generated code")
	}

	// Check it contains debug comment
	if !strings.Contains(codeStr, "Code generated by shipq") {
		t.Error("expected generation comment in generated code")
	}

	if !strings.Contains(codeStr, "go run") {
		t.Error("expected run instructions in generated code")
	}
}

func TestGenerateCompileProgram_ErrorHandling(t *testing.T) {
	cfg := CompileProgramConfig{
		ModulePath:    "example.com/myapp",
		QuerydefsPkgs: []string{"example.com/myapp/querydefs"},
	}

	code, err := GenerateCompileProgram(cfg)
	if err != nil {
		t.Fatalf("GenerateCompileProgram failed: %v", err)
	}

	codeStr := string(code)

	// Should have error handling for serialization
	if !strings.Contains(codeStr, "os.Exit(1)") {
		t.Error("expected os.Exit(1) for error handling")
	}

	// Should write errors to stderr
	if !strings.Contains(codeStr, "os.Stderr") {
		t.Error("expected errors to be written to stderr")
	}
}

func TestGenerateCompileProgram_JSONOutput(t *testing.T) {
	cfg := CompileProgramConfig{
		ModulePath:    "example.com/myapp",
		QuerydefsPkgs: []string{"example.com/myapp/querydefs"},
	}

	code, err := GenerateCompileProgram(cfg)
	if err != nil {
		t.Fatalf("GenerateCompileProgram failed: %v", err)
	}

	codeStr := string(code)

	// Should use json.Indent for pretty printing
	if !strings.Contains(codeStr, "json.Indent") {
		t.Error("expected json.Indent for pretty printing")
	}

	// Should write to stdout
	if !strings.Contains(codeStr, "os.Stdout") {
		t.Error("expected output to os.Stdout")
	}
}

func TestGenerateCompileProgram_DoesNotMutateInput(t *testing.T) {
	pkgs := []string{
		"example.com/myapp/querydefs/b",
		"example.com/myapp/querydefs/a",
	}
	original := make([]string, len(pkgs))
	copy(original, pkgs)

	cfg := CompileProgramConfig{
		ModulePath:    "example.com/myapp",
		QuerydefsPkgs: pkgs,
	}

	_, err := GenerateCompileProgram(cfg)
	if err != nil {
		t.Fatalf("GenerateCompileProgram failed: %v", err)
	}

	// Verify input was not mutated
	for i, pkg := range pkgs {
		if pkg != original[i] {
			t.Errorf("input was mutated: pkgs[%d] = %q, want %q", i, pkg, original[i])
		}
	}
}
