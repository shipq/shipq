package testclient

import (
	"bytes"
	"fmt"
	"go/format"
)

// HTTPTestHarnessGenConfig holds configuration for generating the HTTP test harness.
type HTTPTestHarnessGenConfig struct {
	ModulePath string // e.g., "myapp"
	OutputPkg  string // package name for generated code (e.g., "api")
	DBDialect  string // "mysql", "postgres", or "sqlite"
}

// GenerateHTTPTestHarness generates the test server setup with transaction isolation.
func GenerateHTTPTestHarness(cfg HTTPTestHarnessGenConfig) ([]byte, error) {
	var buf bytes.Buffer

	// Generate file header
	buf.WriteString("// Code generated by shipq. DO NOT EDIT.\n")
	fmt.Fprintf(&buf, "package %s\n\n", cfg.OutputPkg)

	// Generate imports
	generateTestHarnessImports(&buf, cfg)

	// Generate TestServer struct
	generateTestServerStruct(&buf)

	// Generate NewUnauthenticatedTestServer function
	generateNewTestServer(&buf)

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted source for debugging
		return buf.Bytes(), fmt.Errorf("failed to format HTTP test harness code: %w\nunformatted:\n%s", err, buf.String())
	}

	return formatted, nil
}

// generateTestHarnessImports writes the import block for the test harness.
func generateTestHarnessImports(buf *bytes.Buffer, cfg HTTPTestHarnessGenConfig) {
	buf.WriteString("import (\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"database/sql\"\n")
	buf.WriteString("\t\"io\"\n")
	buf.WriteString("\t\"log/slog\"\n")
	buf.WriteString("\t\"net/http/httptest\"\n")
	buf.WriteString("\t\"testing\"\n")
	buf.WriteString(")\n\n")
}

// generateTestServerStruct generates the TestServer struct definition.
func generateTestServerStruct(buf *bytes.Buffer) {
	buf.WriteString(`// TestServer wraps httptest.Server with transaction management.
// Each test gets its own database transaction that is rolled back after the test completes,
// providing isolation between tests.
type TestServer struct {
	*httptest.Server
	tx     *sql.Tx
	cancel context.CancelFunc
}

// Tx returns the underlying database transaction for direct database access in tests.
// This is useful for verifying database state or setting up test fixtures.
func (ts *TestServer) Tx() *sql.Tx {
	return ts.tx
}

`)
}

// generateNewTestServer generates the NewUnauthenticatedTestServer function.
func generateNewTestServer(buf *bytes.Buffer) {
	buf.WriteString(`// testLogger returns a logger that discards all output for tests.
func testLogger() *slog.Logger {
	return slog.New(slog.NewTextHandler(io.Discard, nil))
}

// NewUnauthenticatedTestServer creates a test server with a rolled-back transaction.
// The transaction is automatically rolled back when the test completes, ensuring
// test isolation without affecting the database.
//
// Usage:
//
//	func TestSomething(t *testing.T) {
//	    ts := api.NewUnauthenticatedTestServer(t, db)
//	    client := api.NewUnauthenticatedTestClient(ts.Server)
//	    // ... run test ...
//	}
func NewUnauthenticatedTestServer(t *testing.T, db *sql.DB) *TestServer {
	t.Helper()

	ctx, cancel := context.WithCancel(context.Background())

	// Start transaction
	tx, err := db.BeginTx(ctx, nil)
	if err != nil {
		cancel()
		t.Fatalf("failed to begin transaction: %v", err)
	}

	// Create mux with transaction-backed querier and discarded logger
	// The transaction implements the Querier interface (ExecContext, QueryContext, QueryRowContext)
	mux := NewMux(tx, testLogger())

	ts := httptest.NewServer(mux)

	testServer := &TestServer{
		Server: ts,
		tx:     tx,
		cancel: cancel,
	}

	t.Cleanup(func() {
		ts.Close()
		// Always rollback - ignore error since we're just cleaning up
		_ = tx.Rollback()
		cancel()
	})

	return testServer
}

`)
}
