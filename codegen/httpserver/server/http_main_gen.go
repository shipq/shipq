package server

import (
	"bytes"
	"fmt"
	"go/format"
)

// HTTPMainGenConfig holds configuration for generating the main.go entrypoint.
type HTTPMainGenConfig struct {
	ModulePath string // e.g., "myapp"
	OutputPkg  string // package containing generated HTTP server (e.g., "api")
	DBDialect  string // "mysql", "postgres", or "sqlite"
}

// GenerateHTTPMain generates the main.go entrypoint for the HTTP server.
func GenerateHTTPMain(cfg HTTPMainGenConfig) ([]byte, error) {
	var buf bytes.Buffer

	buf.WriteString("// Code generated by shipq. DO NOT EDIT.\n")
	buf.WriteString("package main\n\n")

	// Generate imports
	generateMainImports(&buf, cfg)

	// Generate main function
	generateMainFunc(&buf, cfg)

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted source for debugging
		return buf.Bytes(), fmt.Errorf("failed to format main.go: %w\nunformatted:\n%s", err, buf.String())
	}

	return formatted, nil
}

// generateMainImports writes the import block for main.go.
func generateMainImports(buf *bytes.Buffer, cfg HTTPMainGenConfig) {
	buf.WriteString("import (\n")
	buf.WriteString("\t\"database/sql\"\n")
	buf.WriteString("\t\"log\"\n")
	buf.WriteString("\t\"net/http\"\n")
	buf.WriteString("\n")

	// API package import
	apiPkg := cfg.ModulePath + "/" + cfg.OutputPkg
	fmt.Fprintf(buf, "\t%q\n", apiPkg)

	// Config package import
	configPkg := cfg.ModulePath + "/config"
	fmt.Fprintf(buf, "\t%q\n", configPkg)
	buf.WriteString("\n")

	// Database driver import
	driverImport := getDriverImport(cfg.DBDialect)
	fmt.Fprintf(buf, "\t_ %q\n", driverImport)

	buf.WriteString(")\n\n")
}

// generateMainFunc writes the main function.
func generateMainFunc(buf *bytes.Buffer, cfg HTTPMainGenConfig) {
	driverName := getDriverName(cfg.DBDialect)

	buf.WriteString("func main() {\n")

	// Database connection using config.Settings
	fmt.Fprintf(buf, "\tdb, err := sql.Open(%q, config.Settings.DATABASE_URL)\n", driverName)
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString("\t\tlog.Fatal(err)\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tdefer db.Close()\n\n")

	// Verify connection
	buf.WriteString("\tif err := db.Ping(); err != nil {\n")
	buf.WriteString("\t\tlog.Fatal(\"failed to connect to database: \", err)\n")
	buf.WriteString("\t}\n\n")

	// Create mux and start server with logger
	buf.WriteString("\thandler := api.NewMux(db, config.Logger)\n\n")

	buf.WriteString("\taddr := \":\" + config.Settings.PORT\n")
	buf.WriteString("\tlog.Println(\"Starting server on\", addr)\n")
	buf.WriteString("\tif err := http.ListenAndServe(addr, handler); err != nil {\n")
	buf.WriteString("\t\tlog.Fatal(err)\n")
	buf.WriteString("\t}\n")

	buf.WriteString("}\n")
}

// getDriverImport returns the import path for the database driver.
func getDriverImport(dialect string) string {
	switch dialect {
	case "postgres":
		return "github.com/jackc/pgx/v5/stdlib"
	case "sqlite":
		return "modernc.org/sqlite"
	case "mysql":
		return "github.com/go-sql-driver/mysql"
	default:
		// Default to mysql
		return "github.com/go-sql-driver/mysql"
	}
}

// getDriverName returns the driver name for sql.Open().
func getDriverName(dialect string) string {
	switch dialect {
	case "postgres":
		return "pgx"
	case "sqlite":
		return "sqlite"
	case "mysql":
		return "mysql"
	default:
		return "mysql"
	}
}

