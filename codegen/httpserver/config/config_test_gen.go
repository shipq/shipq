package config

import (
	"bytes"
	"fmt"
	"go/format"
)

// GenerateConfigTest generates the config/config_test.go file.
func GenerateConfigTest(cfg ConfigGenConfig) ([]byte, error) {
	var buf bytes.Buffer

	buf.WriteString("// Code generated by shipq. DO NOT EDIT.\n")
	buf.WriteString("package config\n\n")

	// Generate imports
	generateConfigTestImports(&buf, cfg)

	// Generate test functions
	generateLoggerTests(&buf)

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted source for debugging
		return buf.Bytes(), fmt.Errorf("failed to format config_test.go: %w\nunformatted:\n%s", err, buf.String())
	}

	return formatted, nil
}

// generateConfigTestImports writes the import block for config_test.go.
func generateConfigTestImports(buf *bytes.Buffer, cfg ConfigGenConfig) {
	buf.WriteString("import (\n")
	buf.WriteString("\t\"testing\"\n")
	buf.WriteString("\n")
	buf.WriteString("\t\"github.com/shipq/shipq/logging\"\n")
	buf.WriteString(")\n\n")
}

// generateLoggerTests writes the test functions for logger selection.
func generateLoggerTests(buf *bytes.Buffer) {
	buf.WriteString(`func TestProdLogger(t *testing.T) {
	logger := getLogger("production")
	if logger != logging.ProdLogger {
		t.Errorf("Logger is not the production logger")
	}
}

func TestDevLogger(t *testing.T) {
	logger := getLogger("development")
	if logger != logging.DevLogger {
		t.Errorf("Logger is not the development logger")
	}
}
`)
}
