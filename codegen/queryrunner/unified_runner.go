package queryrunner

import (
	"bytes"
	"fmt"
	"go/format"
	"sort"
	"strings"

	"github.com/shipq/shipq/codegen"
	portsqlcodegen "github.com/shipq/shipq/db/portsql/codegen"
	"github.com/shipq/shipq/db/portsql/ddl"
	"github.com/shipq/shipq/db/portsql/migrate"
	"github.com/shipq/shipq/db/portsql/query"
	"github.com/shipq/shipq/db/portsql/query/compile"
	"github.com/shipq/shipq/dbstrings"
	"github.com/shipq/shipq/dburl"
)

// UnifiedRunnerConfig holds all information needed to generate the runner.
type UnifiedRunnerConfig struct {
	ModulePath  string
	Dialect     string // "postgres", "mysql", "sqlite"
	UserQueries []query.SerializedQuery
	Schema      *migrate.MigrationPlan
	TableOpts   map[string]portsqlcodegen.CRUDOptions
}

// GenerateUnifiedRunner generates the complete runner for a dialect.
// This produces shipq/queries/<dialect>/runner.go
func GenerateUnifiedRunner(cfg UnifiedRunnerConfig) ([]byte, error) {
	var buf bytes.Buffer

	// Get the compiler for this dialect
	compiler, err := getCompiler(cfg.Dialect)
	if err != nil {
		return nil, err
	}

	// Collect all query info for code generation
	userQueryInfo, err := compileUserQueries(cfg.UserQueries, compiler)
	if err != nil {
		return nil, err
	}

	// Collect imports
	imports := collectRunnerImports(cfg, userQueryInfo)

	// Write header
	buf.WriteString("// Code generated by shipq. DO NOT EDIT.\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", cfg.Dialect))

	// Write imports
	writeImports(&buf, imports)

	// Write Querier interface
	writeQuerierInterface(&buf)

	// Write QueryRunner struct
	writeQueryRunnerStruct(&buf, userQueryInfo, cfg)

	// Write NewQueryRunner constructor
	writeNewQueryRunner(&buf, userQueryInfo, cfg, compiler)

	// Write WithTx method
	writeWithTx(&buf, userQueryInfo, cfg)

	// Write WithDB method
	writeWithDB(&buf, userQueryInfo, cfg)

	// Write user-defined query methods
	for _, qi := range userQueryInfo {
		if err := writeUserQueryMethod(&buf, qi, cfg); err != nil {
			return nil, err
		}
	}

	// Write CRUD methods if schema is provided
	if cfg.Schema != nil {
		if err := writeCRUDMethods(&buf, cfg, compiler); err != nil {
			return nil, err
		}
	}

	// Format the code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted for debugging
		return buf.Bytes(), fmt.Errorf("failed to format runner.go: %w (unformatted output returned)", err)
	}

	return formatted, nil
}

// GenerateSharedTypes generates the types.go file with param/result structs.
// This produces shipq/queries/types.go
func GenerateSharedTypes(cfg UnifiedRunnerConfig) ([]byte, error) {
	var buf bytes.Buffer

	// Compile user queries to get type information
	compiler, err := getCompiler(cfg.Dialect)
	if err != nil {
		return nil, err
	}

	userQueryInfo, err := compileUserQueries(cfg.UserQueries, compiler)
	if err != nil {
		return nil, err
	}

	// Collect imports needed for types
	imports := collectTypesImports(userQueryInfo, cfg)

	// Always need context for RunnerFromContext
	imports["context"] = true

	// Need encoding/base64 and encoding/json for cursor helpers
	if cfg.Schema != nil && len(cfg.Schema.Schema.Tables) > 0 {
		imports["encoding/base64"] = true
		imports["encoding/json"] = true
	}

	// Write header
	buf.WriteString("// Code generated by shipq. DO NOT EDIT.\n")
	buf.WriteString("package queries\n\n")

	// Write imports if any
	if len(imports) > 0 {
		writeImports(&buf, imports)
	}

	// Write context helpers for runner access
	writeContextHelpers(&buf, cfg)

	// Write user query types
	for _, qi := range userQueryInfo {
		writeUserQueryTypes(&buf, qi)
	}

	// Write CRUD types if schema is provided
	if cfg.Schema != nil {
		writeCRUDTypes(&buf, cfg)
	}

	// Format the code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted for debugging
		return buf.Bytes(), fmt.Errorf("failed to format types.go: %w (unformatted output returned)", err)
	}

	return formatted, nil
}

// writeContextHelpers writes the RunnerFromContext and NewContextWithRunner functions.
func writeContextHelpers(buf *bytes.Buffer, cfg UnifiedRunnerConfig) {
	buf.WriteString("// =============================================================================\n")
	buf.WriteString("// Context Helpers\n")
	buf.WriteString("// =============================================================================\n\n")

	buf.WriteString("type contextKey struct{}\n\n")

	// Generate the Runner interface with all CRUD methods
	buf.WriteString("// Runner is the interface that all dialect-specific runners implement.\n")
	buf.WriteString("// This allows handlers to work with any database dialect.\n")
	buf.WriteString("type Runner interface {\n")

	// Add method signatures for each table's CRUD operations
	if cfg.Schema != nil {
		tableNames := sortedTableNames(cfg.Schema.Schema.Tables)
		for _, tableName := range tableNames {
			getMethod := codegen.CRUD.GetMethodName(tableName)
			getResult := codegen.CRUD.GetResultType(tableName)
			buf.WriteString(fmt.Sprintf("\t%s(ctx context.Context, publicID string) (*%s, error)\n", getMethod, getResult))

			listMethod := codegen.CRUD.ListMethodName(tableName)
			listParams := codegen.CRUD.ListParamsType(tableName)
			listResult := codegen.CRUD.ListResultType(tableName)
			buf.WriteString(fmt.Sprintf("\t%s(ctx context.Context, params %s) (*%s, error)\n", listMethod, listParams, listResult))

			createMethod := codegen.CRUD.CreateMethodName(tableName)
			createParams := codegen.CRUD.CreateParamsType(tableName)
			createResult := codegen.CRUD.CreateResultType(tableName)
			buf.WriteString(fmt.Sprintf("\t%s(ctx context.Context, params %s) (*%s, error)\n", createMethod, createParams, createResult))

			updateMethod := codegen.CRUD.UpdateMethodName(tableName)
			updateParams := codegen.CRUD.UpdateParamsType(tableName)
			// Update returns GetResult since it fetches the updated record
			buf.WriteString(fmt.Sprintf("\t%s(ctx context.Context, publicID string, params %s) (*%s, error)\n", updateMethod, updateParams, getResult))

			softDeleteMethod := codegen.CRUD.SoftDeleteMethodName(tableName)
			buf.WriteString(fmt.Sprintf("\t%s(ctx context.Context, publicID string) error\n", softDeleteMethod))
		}
	}
	buf.WriteString("}\n\n")

	buf.WriteString("// NewContextWithRunner returns a new context with the QueryRunner attached.\n")
	buf.WriteString("func NewContextWithRunner(ctx context.Context, runner Runner) context.Context {\n")
	buf.WriteString("\treturn context.WithValue(ctx, contextKey{}, runner)\n")
	buf.WriteString("}\n\n")

	buf.WriteString("// RunnerFromContext extracts the QueryRunner from the context.\n")
	buf.WriteString("// Panics if no runner is present (indicates middleware misconfiguration).\n")
	buf.WriteString("func RunnerFromContext(ctx context.Context) Runner {\n")
	buf.WriteString("\trunner := ctx.Value(contextKey{})\n")
	buf.WriteString("\tif runner == nil {\n")
	buf.WriteString("\t\tpanic(\"queries: no runner in context - ensure middleware calls NewContextWithRunner\")\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn runner.(Runner)\n")
	buf.WriteString("}\n\n")
}

// =============================================================================
// Internal Types
// =============================================================================

// userQueryInfo holds compiled information about a user-defined query.
type userQueryInfo struct {
	Name       string
	ReturnType query.QueryReturnType
	SQL        string
	ParamOrder []string // Parameter names in SQL order (may have duplicates)
	Params     []paramInfo
	Results    []resultInfo
}

type paramInfo struct {
	Name   string
	GoType string
}

type resultInfo struct {
	Name   string // Field name (PascalCase)
	GoType string
	Column string // Original column name
}

// =============================================================================
// Compiler Helpers
// =============================================================================

func getCompiler(dialect string) (*compile.Compiler, error) {
	switch dialect {
	case dburl.DialectPostgres:
		return compile.NewCompiler(compile.Postgres), nil
	case dburl.DialectMySQL:
		return compile.NewCompiler(compile.MySQL), nil
	case dburl.DialectSQLite:
		return compile.NewCompiler(compile.SQLite), nil
	default:
		return nil, fmt.Errorf("unsupported dialect: %s", dialect)
	}
}

func compileUserQueries(queries []query.SerializedQuery, compiler *compile.Compiler) ([]userQueryInfo, error) {
	result := make([]userQueryInfo, 0, len(queries))

	for _, sq := range queries {
		// Deserialize the AST
		ast := query.DeserializeAST(sq.AST)
		if ast == nil {
			return nil, fmt.Errorf("failed to deserialize AST for query %s", sq.Name)
		}

		// Compile to SQL
		sql, paramOrder, err := compiler.Compile(ast)
		if err != nil {
			return nil, fmt.Errorf("failed to compile query %s: %w", sq.Name, err)
		}

		// Extract parameters (deduplicated, in definition order)
		params := extractParams(sq.AST)

		// Extract result columns for SELECT queries
		var results []resultInfo
		if sq.ReturnType == query.ReturnOne || sq.ReturnType == query.ReturnMany {
			results = extractResults(sq.AST)
		}

		result = append(result, userQueryInfo{
			Name:       sq.Name,
			ReturnType: sq.ReturnType,
			SQL:        sql,
			ParamOrder: paramOrder,
			Params:     params,
			Results:    results,
		})
	}

	// Sort by name for deterministic output
	sort.Slice(result, func(i, j int) bool {
		return result[i].Name < result[j].Name
	})

	return result, nil
}

func extractParams(ast *query.SerializedAST) []paramInfo {
	if ast == nil {
		return nil
	}

	// Use Params from the AST if available
	if len(ast.Params) > 0 {
		params := make([]paramInfo, len(ast.Params))
		for i, p := range ast.Params {
			params[i] = paramInfo{
				Name:   p.Name,
				GoType: p.GoType,
			}
		}
		return params
	}

	// Otherwise, walk the AST to find parameters
	seen := make(map[string]bool)
	var params []paramInfo

	walkSerializedAST(ast, func(expr *query.SerializedExpr) {
		if expr.Type == "param" && expr.Param != nil {
			if !seen[expr.Param.Name] {
				seen[expr.Param.Name] = true
				params = append(params, paramInfo{
					Name:   expr.Param.Name,
					GoType: expr.Param.GoType,
				})
			}
		}
	})

	return params
}

func extractResults(ast *query.SerializedAST) []resultInfo {
	if ast == nil || len(ast.SelectCols) == 0 {
		return nil
	}

	results := make([]resultInfo, 0, len(ast.SelectCols))

	for _, col := range ast.SelectCols {
		var name, colName, goType string

		// Determine the field name
		if col.Alias != "" {
			name = dbstrings.ToPascalCase(col.Alias)
			colName = col.Alias
		} else if col.Expr.Type == "column" && col.Expr.Column != nil {
			name = dbstrings.ToPascalCase(col.Expr.Column.Name)
			colName = col.Expr.Column.Name
			goType = col.Expr.Column.GoType
		} else {
			// For expressions without alias, generate a name
			name = fmt.Sprintf("Col%d", len(results)+1)
			colName = name
		}

		// Determine the Go type
		if goType == "" {
			goType = inferGoType(&col.Expr)
		}
		if goType == "" {
			goType = "any"
		}

		results = append(results, resultInfo{
			Name:   name,
			GoType: goType,
			Column: colName,
		})
	}

	return results
}

func inferGoType(expr *query.SerializedExpr) string {
	if expr == nil {
		return "any"
	}

	switch expr.Type {
	case "column":
		if expr.Column != nil {
			return expr.Column.GoType
		}
	case "literal":
		switch expr.Literal.(type) {
		case string:
			return "string"
		case float64:
			return "float64"
		case bool:
			return "bool"
		case nil:
			return "any"
		}
	case "aggregate":
		if expr.Aggregate != nil {
			switch expr.Aggregate.Func {
			case "COUNT":
				return "int64"
			case "SUM", "AVG":
				return "float64"
			case "MIN", "MAX":
				if expr.Aggregate.Arg != nil {
					return inferGoType(expr.Aggregate.Arg)
				}
			}
		}
	case "func":
		// Common functions
		if expr.Func != nil {
			switch expr.Func.Name {
			case "NOW":
				return "time.Time"
			case "LOWER", "UPPER", "TRIM", "CONCAT":
				return "string"
			case "COALESCE":
				if len(expr.Func.Args) > 0 {
					return inferGoType(&expr.Func.Args[0])
				}
			}
		}
	}

	return "any"
}

// walkSerializedAST walks all expressions in a serialized AST.
func walkSerializedAST(ast *query.SerializedAST, fn func(*query.SerializedExpr)) {
	if ast == nil {
		return
	}

	// Walk select columns
	for i := range ast.SelectCols {
		walkSerializedExpr(&ast.SelectCols[i].Expr, fn)
	}

	// Walk joins
	for i := range ast.Joins {
		walkSerializedExpr(&ast.Joins[i].Condition, fn)
	}

	// Walk where
	if ast.Where != nil {
		walkSerializedExpr(ast.Where, fn)
	}

	// Walk having
	if ast.Having != nil {
		walkSerializedExpr(ast.Having, fn)
	}

	// Walk order by
	for i := range ast.OrderBy {
		walkSerializedExpr(&ast.OrderBy[i].Expr, fn)
	}

	// Walk limit/offset
	if ast.Limit != nil {
		walkSerializedExpr(ast.Limit, fn)
	}
	if ast.Offset != nil {
		walkSerializedExpr(ast.Offset, fn)
	}

	// Walk insert values
	for i := range ast.InsertVals {
		walkSerializedExpr(&ast.InsertVals[i], fn)
	}

	// Walk set clauses
	for i := range ast.SetClauses {
		walkSerializedExpr(&ast.SetClauses[i].Value, fn)
	}

	// Walk CTEs
	for i := range ast.CTEs {
		walkSerializedAST(ast.CTEs[i].Query, fn)
	}

	// Walk set operations
	if ast.SetOp != nil {
		walkSerializedAST(ast.SetOp.Left, fn)
		walkSerializedAST(ast.SetOp.Right, fn)
	}
}

func walkSerializedExpr(expr *query.SerializedExpr, fn func(*query.SerializedExpr)) {
	if expr == nil {
		return
	}

	fn(expr)

	switch expr.Type {
	case "binary":
		if expr.Binary != nil {
			walkSerializedExpr(&expr.Binary.Left, fn)
			walkSerializedExpr(&expr.Binary.Right, fn)
		}
	case "unary":
		if expr.Unary != nil {
			walkSerializedExpr(&expr.Unary.Expr, fn)
		}
	case "func":
		if expr.Func != nil {
			for i := range expr.Func.Args {
				walkSerializedExpr(&expr.Func.Args[i], fn)
			}
		}
	case "list":
		for i := range expr.List {
			walkSerializedExpr(&expr.List[i], fn)
		}
	case "aggregate":
		if expr.Aggregate != nil && expr.Aggregate.Arg != nil {
			walkSerializedExpr(expr.Aggregate.Arg, fn)
		}
	case "subquery":
		walkSerializedAST(expr.Subquery, fn)
	case "exists":
		if expr.Exists != nil {
			walkSerializedAST(expr.Exists.Subquery, fn)
		}
	}
}

// =============================================================================
// Import Collection
// =============================================================================

func collectRunnerImports(cfg UnifiedRunnerConfig, queries []userQueryInfo) map[string]bool {
	imports := make(map[string]bool)

	// Always needed
	imports["context"] = true
	imports["database/sql"] = true

	// Types package import
	imports[cfg.ModulePath+"/shipq/queries"] = true

	// Check user queries for time imports
	for _, qi := range queries {
		for _, p := range qi.Params {
			if needsTimeImport(p.GoType) {
				imports["time"] = true
			}
		}
		for _, r := range qi.Results {
			if needsTimeImport(r.GoType) {
				imports["time"] = true
			}
		}
	}

	// Check schema for imports
	// Note: We don't need time import in runner because time types are in queries package.
	// We only need nanoid for generating public IDs.
	if cfg.Schema != nil {
		for _, table := range cfg.Schema.Schema.Tables {
			analysis := portsqlcodegen.AnalyzeTable(table)
			if analysis.HasPublicID {
				imports["github.com/shipq/shipq/nanoid"] = true
			}
		}
	}

	return imports
}

func collectTypesImports(queries []userQueryInfo, cfg UnifiedRunnerConfig) map[string]bool {
	imports := make(map[string]bool)

	// Check user queries
	for _, qi := range queries {
		for _, p := range qi.Params {
			if needsTimeImport(p.GoType) {
				imports["time"] = true
			}
			if needsJSONImport(p.GoType) {
				imports["encoding/json"] = true
			}
		}
		for _, r := range qi.Results {
			if needsTimeImport(r.GoType) {
				imports["time"] = true
			}
			if needsJSONImport(r.GoType) {
				imports["encoding/json"] = true
			}
		}
	}

	// Check schema
	if cfg.Schema != nil {
		for _, table := range cfg.Schema.Schema.Tables {
			for _, col := range table.Columns {
				mapping := portsqlcodegen.MapColumnType(col)
				if mapping.NeedsImport == "time" {
					imports["time"] = true
				}
				if mapping.NeedsImport == "encoding/json" {
					imports["encoding/json"] = true
				}
			}
		}
	}

	return imports
}

func needsTimeImport(goType string) bool {
	return strings.Contains(goType, "time.Time")
}

func needsJSONImport(goType string) bool {
	return strings.Contains(goType, "json.RawMessage")
}

// =============================================================================
// Code Generation Helpers
// =============================================================================

func writeImports(buf *bytes.Buffer, imports map[string]bool) {
	if len(imports) == 0 {
		return
	}

	// Sort imports
	importList := make([]string, 0, len(imports))
	for imp := range imports {
		importList = append(importList, imp)
	}
	sort.Strings(importList)

	// Separate standard library and third-party imports
	var stdImports, thirdPartyImports []string
	for _, imp := range importList {
		if isStdLib(imp) {
			stdImports = append(stdImports, imp)
		} else {
			thirdPartyImports = append(thirdPartyImports, imp)
		}
	}

	buf.WriteString("import (\n")
	for _, imp := range stdImports {
		buf.WriteString(fmt.Sprintf("\t%q\n", imp))
	}
	if len(stdImports) > 0 && len(thirdPartyImports) > 0 {
		buf.WriteString("\n")
	}
	for _, imp := range thirdPartyImports {
		buf.WriteString(fmt.Sprintf("\t%q\n", imp))
	}
	buf.WriteString(")\n\n")
}

func isStdLib(pkg string) bool {
	// Simple heuristic: standard library packages don't have dots in the first component
	if strings.Contains(pkg, "/") {
		firstComponent := strings.Split(pkg, "/")[0]
		return !strings.Contains(firstComponent, ".")
	}
	return !strings.Contains(pkg, ".")
}

func writeQuerierInterface(buf *bytes.Buffer) {
	buf.WriteString(`// Querier is the interface for database operations.
// Both *sql.DB and *sql.Tx implement this interface.
type Querier interface {
	ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error)
	QueryContext(ctx context.Context, query string, args ...any) (*sql.Rows, error)
	QueryRowContext(ctx context.Context, query string, args ...any) *sql.Row
}

`)
}

func writeQueryRunnerStruct(buf *bytes.Buffer, queries []userQueryInfo, cfg UnifiedRunnerConfig) {
	buf.WriteString(`// QueryRunner executes queries against the database.
// Create with NewQueryRunner(db) and use WithTx(tx) for transactions.
type QueryRunner struct {
	db Querier

`)

	// User query SQL fields
	if len(queries) > 0 {
		buf.WriteString("\t// User-defined query SQL\n")
		for _, qi := range queries {
			fieldName := dbstrings.ToLowerCamel(qi.Name) + "SQL"
			buf.WriteString(fmt.Sprintf("\t%s string\n", fieldName))
		}
	}

	// CRUD SQL fields
	if cfg.Schema != nil && len(cfg.Schema.Schema.Tables) > 0 {
		buf.WriteString("\n\t// CRUD SQL\n")
		tableNames := sortedTableNames(cfg.Schema.Schema.Tables)
		for _, tableName := range tableNames {
			singular := dbstrings.ToSingular(tableName)
			pascal := dbstrings.ToPascalCase(singular)

			buf.WriteString(fmt.Sprintf("\tget%sSQL string\n", pascal))
			buf.WriteString(fmt.Sprintf("\tlist%sSQL string\n", dbstrings.ToPascalCase(tableName)))
			buf.WriteString(fmt.Sprintf("\tcreate%sSQL string\n", pascal))
			buf.WriteString(fmt.Sprintf("\tupdate%sSQL string\n", pascal))
			buf.WriteString(fmt.Sprintf("\tdelete%sSQL string\n", pascal))
		}
	}

	buf.WriteString("}\n\n")
}

func writeNewQueryRunner(buf *bytes.Buffer, queries []userQueryInfo, cfg UnifiedRunnerConfig, compiler *compile.Compiler) {
	buf.WriteString(`// NewQueryRunner creates a QueryRunner for this dialect.
// All SQL strings are selected once at construction time.
func NewQueryRunner(db Querier) *QueryRunner {
	return &QueryRunner{
		db: db,

`)

	// User query SQL values
	if len(queries) > 0 {
		buf.WriteString("\t\t// User-defined queries\n")
		for _, qi := range queries {
			fieldName := dbstrings.ToLowerCamel(qi.Name) + "SQL"
			buf.WriteString(fmt.Sprintf("\t\t%s: %q,\n", fieldName, qi.SQL))
		}
	}

	// CRUD SQL values
	if cfg.Schema != nil && len(cfg.Schema.Schema.Tables) > 0 {
		buf.WriteString("\n\t\t// CRUD queries\n")
		tableNames := sortedTableNames(cfg.Schema.Schema.Tables)
		for _, tableName := range tableNames {
			table := cfg.Schema.Schema.Tables[tableName]
			analysis := portsqlcodegen.AnalyzeTable(table)
			singular := dbstrings.ToSingular(tableName)
			pascal := dbstrings.ToPascalCase(singular)

			// Generate SQL for each CRUD operation
			getSQL := generateGetSQL(table, analysis, compiler)
			listSQL := generateListSQL(table, analysis, compiler)
			createSQL := generateCreateSQL(table, analysis, compiler)
			updateSQL := generateUpdateSQL(table, analysis, compiler)
			deleteSQL := generateDeleteSQL(table, analysis, compiler)

			buf.WriteString(fmt.Sprintf("\t\tget%sSQL: %q,\n", pascal, getSQL))
			buf.WriteString(fmt.Sprintf("\t\tlist%sSQL: %q,\n", dbstrings.ToPascalCase(tableName), listSQL))
			buf.WriteString(fmt.Sprintf("\t\tcreate%sSQL: %q,\n", pascal, createSQL))
			buf.WriteString(fmt.Sprintf("\t\tupdate%sSQL: %q,\n", pascal, updateSQL))
			buf.WriteString(fmt.Sprintf("\t\tdelete%sSQL: %q,\n", pascal, deleteSQL))
		}
	}

	buf.WriteString("\t}\n}\n\n")
}

func writeWithTx(buf *bytes.Buffer, queries []userQueryInfo, cfg UnifiedRunnerConfig) {
	buf.WriteString(`// WithTx returns a new QueryRunner using the given transaction.
// SQL strings are copied (no recomputation).
func (r *QueryRunner) WithTx(tx *sql.Tx) *QueryRunner {
	return &QueryRunner{
		db: tx,

`)

	// Copy user query SQL
	if len(queries) > 0 {
		for _, qi := range queries {
			fieldName := dbstrings.ToLowerCamel(qi.Name) + "SQL"
			buf.WriteString(fmt.Sprintf("\t\t%s: r.%s,\n", fieldName, fieldName))
		}
	}

	// Copy CRUD SQL
	if cfg.Schema != nil && len(cfg.Schema.Schema.Tables) > 0 {
		tableNames := sortedTableNames(cfg.Schema.Schema.Tables)
		for _, tableName := range tableNames {
			singular := dbstrings.ToSingular(tableName)
			pascal := dbstrings.ToPascalCase(singular)

			buf.WriteString(fmt.Sprintf("\t\tget%sSQL: r.get%sSQL,\n", pascal, pascal))
			buf.WriteString(fmt.Sprintf("\t\tlist%sSQL: r.list%sSQL,\n", dbstrings.ToPascalCase(tableName), dbstrings.ToPascalCase(tableName)))
			buf.WriteString(fmt.Sprintf("\t\tcreate%sSQL: r.create%sSQL,\n", pascal, pascal))
			buf.WriteString(fmt.Sprintf("\t\tupdate%sSQL: r.update%sSQL,\n", pascal, pascal))
			buf.WriteString(fmt.Sprintf("\t\tdelete%sSQL: r.delete%sSQL,\n", pascal, pascal))
		}
	}

	buf.WriteString("\t}\n}\n\n")
}

func writeWithDB(buf *bytes.Buffer, queries []userQueryInfo, cfg UnifiedRunnerConfig) {
	buf.WriteString(`// WithDB returns a new QueryRunner using a different Querier.
func (r *QueryRunner) WithDB(db Querier) *QueryRunner {
	return &QueryRunner{
		db: db,

`)

	// Copy user query SQL
	if len(queries) > 0 {
		for _, qi := range queries {
			fieldName := dbstrings.ToLowerCamel(qi.Name) + "SQL"
			buf.WriteString(fmt.Sprintf("\t\t%s: r.%s,\n", fieldName, fieldName))
		}
	}

	// Copy CRUD SQL
	if cfg.Schema != nil && len(cfg.Schema.Schema.Tables) > 0 {
		tableNames := sortedTableNames(cfg.Schema.Schema.Tables)
		for _, tableName := range tableNames {
			singular := dbstrings.ToSingular(tableName)
			pascal := dbstrings.ToPascalCase(singular)

			buf.WriteString(fmt.Sprintf("\t\tget%sSQL: r.get%sSQL,\n", pascal, pascal))
			buf.WriteString(fmt.Sprintf("\t\tlist%sSQL: r.list%sSQL,\n", dbstrings.ToPascalCase(tableName), dbstrings.ToPascalCase(tableName)))
			buf.WriteString(fmt.Sprintf("\t\tcreate%sSQL: r.create%sSQL,\n", pascal, pascal))
			buf.WriteString(fmt.Sprintf("\t\tupdate%sSQL: r.update%sSQL,\n", pascal, pascal))
			buf.WriteString(fmt.Sprintf("\t\tdelete%sSQL: r.delete%sSQL,\n", pascal, pascal))
		}
	}

	buf.WriteString("\t}\n}\n\n")
}

func writeUserQueryMethod(buf *bytes.Buffer, qi userQueryInfo, cfg UnifiedRunnerConfig) error {
	typesPackage := "queries"

	switch qi.ReturnType {
	case query.ReturnOne:
		// Returns (*Result, error)
		paramType := fmt.Sprintf("%s.%sParams", typesPackage, qi.Name)
		resultType := fmt.Sprintf("%s.%sResult", typesPackage, qi.Name)

		buf.WriteString(fmt.Sprintf("// %s executes the user-defined query and returns at most one result.\n", qi.Name))
		buf.WriteString(fmt.Sprintf("func (r *QueryRunner) %s(ctx context.Context, params %s) (*%s, error) {\n", qi.Name, paramType, resultType))

		// Build args slice
		writeArgsSlice(buf, qi)

		// Execute query
		sqlField := dbstrings.ToLowerCamel(qi.Name) + "SQL"
		buf.WriteString(fmt.Sprintf("\trow := r.db.QueryRowContext(ctx, r.%s, args...)\n\n", sqlField))

		// Scan result
		buf.WriteString(fmt.Sprintf("\tvar result %s\n", resultType))
		buf.WriteString("\tif err := row.Scan(\n")
		for _, r := range qi.Results {
			buf.WriteString(fmt.Sprintf("\t\t&result.%s,\n", r.Name))
		}
		buf.WriteString("\t); err != nil {\n")
		buf.WriteString("\t\tif err == sql.ErrNoRows {\n")
		buf.WriteString("\t\t\treturn nil, nil\n")
		buf.WriteString("\t\t}\n")
		buf.WriteString("\t\treturn nil, err\n")
		buf.WriteString("\t}\n")
		buf.WriteString("\treturn &result, nil\n")
		buf.WriteString("}\n\n")

	case query.ReturnMany:
		// Returns ([]Result, error)
		paramType := fmt.Sprintf("%s.%sParams", typesPackage, qi.Name)
		resultType := fmt.Sprintf("%s.%sResult", typesPackage, qi.Name)

		buf.WriteString(fmt.Sprintf("// %s executes the user-defined query and returns all results.\n", qi.Name))
		buf.WriteString(fmt.Sprintf("func (r *QueryRunner) %s(ctx context.Context, params %s) ([]%s, error) {\n", qi.Name, paramType, resultType))

		// Build args slice
		writeArgsSlice(buf, qi)

		// Execute query
		sqlField := dbstrings.ToLowerCamel(qi.Name) + "SQL"
		buf.WriteString(fmt.Sprintf("\trows, err := r.db.QueryContext(ctx, r.%s, args...)\n", sqlField))
		buf.WriteString("\tif err != nil {\n")
		buf.WriteString("\t\treturn nil, err\n")
		buf.WriteString("\t}\n")
		buf.WriteString("\tdefer rows.Close()\n\n")

		// Scan results
		buf.WriteString(fmt.Sprintf("\tvar results []%s\n", resultType))
		buf.WriteString("\tfor rows.Next() {\n")
		buf.WriteString(fmt.Sprintf("\t\tvar item %s\n", resultType))
		buf.WriteString("\t\tif err := rows.Scan(\n")
		for _, r := range qi.Results {
			buf.WriteString(fmt.Sprintf("\t\t\t&item.%s,\n", r.Name))
		}
		buf.WriteString("\t\t); err != nil {\n")
		buf.WriteString("\t\t\treturn nil, err\n")
		buf.WriteString("\t\t}\n")
		buf.WriteString("\t\tresults = append(results, item)\n")
		buf.WriteString("\t}\n\n")

		buf.WriteString("\tif err := rows.Err(); err != nil {\n")
		buf.WriteString("\t\treturn nil, err\n")
		buf.WriteString("\t}\n")
		buf.WriteString("\treturn results, nil\n")
		buf.WriteString("}\n\n")

	case query.ReturnExec:
		// Returns (sql.Result, error)
		paramType := fmt.Sprintf("%s.%sParams", typesPackage, qi.Name)

		buf.WriteString(fmt.Sprintf("// %s executes the user-defined query without returning rows.\n", qi.Name))
		buf.WriteString(fmt.Sprintf("func (r *QueryRunner) %s(ctx context.Context, params %s) (sql.Result, error) {\n", qi.Name, paramType))

		// Build args slice
		writeArgsSlice(buf, qi)

		// Execute query
		sqlField := dbstrings.ToLowerCamel(qi.Name) + "SQL"
		buf.WriteString(fmt.Sprintf("\treturn r.db.ExecContext(ctx, r.%s, args...)\n", sqlField))
		buf.WriteString("}\n\n")
	}

	return nil
}

func writeArgsSlice(buf *bytes.Buffer, qi userQueryInfo) {
	if len(qi.ParamOrder) == 0 {
		buf.WriteString("\targs := []any{}\n")
		return
	}

	buf.WriteString("\targs := []any{\n")
	for _, paramName := range qi.ParamOrder {
		buf.WriteString(fmt.Sprintf("\t\tparams.%s,\n", dbstrings.ToPascalCase(paramName)))
	}
	buf.WriteString("\t}\n")
}

func writeUserQueryTypes(buf *bytes.Buffer, qi userQueryInfo) {
	// Write params struct
	buf.WriteString(fmt.Sprintf("// %sParams are the parameters for the %s query.\n", qi.Name, qi.Name))
	buf.WriteString(fmt.Sprintf("type %sParams struct {\n", qi.Name))
	for _, p := range qi.Params {
		buf.WriteString(fmt.Sprintf("\t%s %s\n", dbstrings.ToPascalCase(p.Name), p.GoType))
	}
	buf.WriteString("}\n\n")

	// Write result struct for SELECT queries
	if qi.ReturnType == query.ReturnOne || qi.ReturnType == query.ReturnMany {
		buf.WriteString(fmt.Sprintf("// %sResult is the result type for the %s query.\n", qi.Name, qi.Name))
		buf.WriteString(fmt.Sprintf("type %sResult struct {\n", qi.Name))
		for _, r := range qi.Results {
			buf.WriteString(fmt.Sprintf("\t%s %s\n", r.Name, r.GoType))
		}
		buf.WriteString("}\n\n")
	}
}

// =============================================================================
// CRUD Generation
// =============================================================================

func writeCRUDMethods(buf *bytes.Buffer, cfg UnifiedRunnerConfig, compiler *compile.Compiler) error {
	if cfg.Schema == nil {
		return nil
	}

	tableNames := sortedTableNames(cfg.Schema.Schema.Tables)
	for _, tableName := range tableNames {
		table := cfg.Schema.Schema.Tables[tableName]
		analysis := portsqlcodegen.AnalyzeTable(table)
		singular := dbstrings.ToSingular(tableName)
		pascal := dbstrings.ToPascalCase(singular)

		// Get method
		writeGetMethod(buf, tableName, table, analysis, pascal, cfg)

		// List method
		writeListMethod(buf, tableName, table, analysis, cfg)

		// Create method
		writeCreateMethod(buf, tableName, table, analysis, pascal, cfg)

		// Update method
		writeUpdateMethod(buf, tableName, table, analysis, pascal, cfg)

		// Delete method
		writeDeleteMethod(buf, tableName, table, analysis, pascal, cfg)
	}

	return nil
}

func writeCRUDTypes(buf *bytes.Buffer, cfg UnifiedRunnerConfig) {
	if cfg.Schema == nil {
		return
	}

	tableNames := sortedTableNames(cfg.Schema.Schema.Tables)
	for _, tableName := range tableNames {
		table := cfg.Schema.Schema.Tables[tableName]
		analysis := portsqlcodegen.AnalyzeTable(table)
		singular := dbstrings.ToSingular(tableName)
		pascal := dbstrings.ToPascalCase(singular)

		// Get params/result
		writeGetTypes(buf, tableName, table, analysis, pascal)

		// List params/result
		writeListTypes(buf, tableName, table, analysis)

		// Create params/result
		writeCreateTypes(buf, tableName, table, analysis, pascal)

		// Update params
		writeUpdateTypes(buf, tableName, table, analysis, pascal)

		// Delete params
		writeDeleteTypes(buf, tableName, table, analysis, pascal)
	}
}

func writeGetTypes(buf *bytes.Buffer, tableName string, table ddl.Table, analysis portsqlcodegen.TableAnalysis, pascal string) {
	resultType := codegen.CRUD.GetResultType(tableName)

	// No params type needed for GetByPublicID - publicID is passed directly
	// Result only
	buf.WriteString(fmt.Sprintf("// %s is the result of fetching a single %s.\n", resultType, singular(tableName)))
	buf.WriteString(fmt.Sprintf("type %s struct {\n", resultType))
	for _, col := range table.Columns {
		if col.Name == "id" {
			continue // Skip internal ID
		}
		mapping := portsqlcodegen.MapColumnType(col)
		buf.WriteString(fmt.Sprintf("\t%s %s\n", dbstrings.ToPascalCase(col.Name), mapping.GoType))
	}
	buf.WriteString("}\n\n")
	_ = analysis // suppress unused
}

func writeListTypes(buf *bytes.Buffer, tableName string, table ddl.Table, analysis portsqlcodegen.TableAnalysis) {
	plural := dbstrings.ToPascalCase(tableName)
	cursorType := codegen.CRUD.ListCursorType(tableName)
	encodeCursorFunc := codegen.CRUD.EncodeCursorFunc(tableName)
	decodeCursorFunc := codegen.CRUD.DecodeCursorFunc(tableName)

	// Cursor type for pagination
	buf.WriteString(fmt.Sprintf("// %s holds pagination state for listing %s.\n", cursorType, tableName))
	buf.WriteString(fmt.Sprintf("type %s struct {\n", cursorType))
	buf.WriteString("\tLastID        int64  `json:\"last_id\"`\n")
	buf.WriteString("\tLastCreatedAt string `json:\"last_created_at\"`\n")
	buf.WriteString("}\n\n")

	// Encode cursor function
	buf.WriteString(fmt.Sprintf("// %s encodes a cursor to a base64 string.\n", encodeCursorFunc))
	buf.WriteString(fmt.Sprintf("func %s(cursor *%s) string {\n", encodeCursorFunc, cursorType))
	buf.WriteString("\tif cursor == nil {\n")
	buf.WriteString("\t\treturn \"\"\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tdata, _ := json.Marshal(cursor)\n")
	buf.WriteString("\treturn base64.StdEncoding.EncodeToString(data)\n")
	buf.WriteString("}\n\n")

	// Decode cursor function
	buf.WriteString(fmt.Sprintf("// %s decodes a base64 string to a cursor.\n", decodeCursorFunc))
	buf.WriteString(fmt.Sprintf("func %s(encoded string) *%s {\n", decodeCursorFunc, cursorType))
	buf.WriteString("\tif encoded == \"\" {\n")
	buf.WriteString("\t\treturn nil\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tdata, err := base64.StdEncoding.DecodeString(encoded)\n")
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString("\t\treturn nil\n")
	buf.WriteString("\t}\n")
	buf.WriteString(fmt.Sprintf("\tvar cursor %s\n", cursorType))
	buf.WriteString("\tif err := json.Unmarshal(data, &cursor); err != nil {\n")
	buf.WriteString("\t\treturn nil\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn &cursor\n")
	buf.WriteString("}\n\n")

	// Params with pagination
	buf.WriteString(fmt.Sprintf("// List%sParams are the parameters for listing %s.\n", plural, tableName))
	buf.WriteString(fmt.Sprintf("type List%sParams struct {\n", plural))
	buf.WriteString("\tLimit  int\n")
	buf.WriteString(fmt.Sprintf("\tCursor *%s\n", cursorType))
	buf.WriteString("}\n\n")

	// Result item
	buf.WriteString(fmt.Sprintf("// List%sItem is a single item in the list %s result.\n", plural, tableName))
	buf.WriteString(fmt.Sprintf("type List%sItem struct {\n", plural))
	for _, col := range table.Columns {
		if col.Name == "id" {
			continue
		}
		mapping := portsqlcodegen.MapColumnType(col)
		buf.WriteString(fmt.Sprintf("\t%s %s\n", dbstrings.ToPascalCase(col.Name), mapping.GoType))
	}
	buf.WriteString("}\n\n")

	// Result wrapper with items and next cursor
	buf.WriteString(fmt.Sprintf("// List%sResult is the result of listing %s.\n", plural, tableName))
	buf.WriteString(fmt.Sprintf("type List%sResult struct {\n", plural))
	buf.WriteString(fmt.Sprintf("\tItems      []List%sItem\n", plural))
	buf.WriteString(fmt.Sprintf("\tNextCursor *%s\n", cursorType))
	buf.WriteString("}\n\n")
}

func writeCreateTypes(buf *bytes.Buffer, tableName string, table ddl.Table, analysis portsqlcodegen.TableAnalysis, pascal string) {
	// Params
	buf.WriteString(fmt.Sprintf("// Create%sParams are the parameters for creating a %s.\n", pascal, singular(tableName)))
	buf.WriteString(fmt.Sprintf("type Create%sParams struct {\n", pascal))
	for _, col := range table.Columns {
		// Skip auto-managed columns
		if col.Name == "id" || col.Name == "public_id" || col.Name == "created_at" || col.Name == "updated_at" || col.Name == "deleted_at" {
			continue
		}
		mapping := portsqlcodegen.MapColumnType(col)
		buf.WriteString(fmt.Sprintf("\t%s %s\n", dbstrings.ToPascalCase(col.Name), mapping.GoType))
	}
	buf.WriteString("}\n\n")

	// Result
	buf.WriteString(fmt.Sprintf("// Create%sResult is the result of creating a %s.\n", pascal, singular(tableName)))
	buf.WriteString(fmt.Sprintf("type Create%sResult struct {\n", pascal))
	if analysis.HasPublicID {
		buf.WriteString("\tPublicID string\n")
	}
	for _, col := range table.Columns {
		if col.Name == "id" {
			continue
		}
		mapping := portsqlcodegen.MapColumnType(col)
		buf.WriteString(fmt.Sprintf("\t%s %s\n", dbstrings.ToPascalCase(col.Name), mapping.GoType))
	}
	buf.WriteString("}\n\n")
}

func writeUpdateTypes(buf *bytes.Buffer, tableName string, table ddl.Table, analysis portsqlcodegen.TableAnalysis, pascal string) {
	updateParamsType := codegen.CRUD.UpdateParamsType(tableName)
	updateResultType := codegen.CRUD.UpdateResultType(tableName)

	// Params - no identifier needed since it's passed separately in ByPublicID signature
	buf.WriteString(fmt.Sprintf("// %s are the parameters for updating a %s.\n", updateParamsType, singular(tableName)))
	buf.WriteString(fmt.Sprintf("type %s struct {\n", updateParamsType))
	// Updatable fields only (no identifier - passed separately)
	for _, col := range table.Columns {
		if col.Name == "id" || col.Name == "public_id" || col.Name == "created_at" || col.Name == "updated_at" || col.Name == "deleted_at" {
			continue
		}
		mapping := portsqlcodegen.MapColumnType(col)
		// Make fields pointers for optional updates (PATCH semantics)
		buf.WriteString(fmt.Sprintf("\t%s *%s\n", dbstrings.ToPascalCase(col.Name), mapping.GoType))
	}
	buf.WriteString("}\n\n")

	// Result - same as Get result
	buf.WriteString(fmt.Sprintf("// %s is the result of updating a %s.\n", updateResultType, singular(tableName)))
	buf.WriteString(fmt.Sprintf("type %s struct {\n", updateResultType))
	for _, col := range table.Columns {
		if col.Name == "id" {
			continue // Skip internal ID
		}
		mapping := portsqlcodegen.MapColumnType(col)
		buf.WriteString(fmt.Sprintf("\t%s %s\n", dbstrings.ToPascalCase(col.Name), mapping.GoType))
	}
	buf.WriteString("}\n\n")
}

func writeDeleteTypes(buf *bytes.Buffer, tableName string, table ddl.Table, analysis portsqlcodegen.TableAnalysis, pascal string) {
	// No params type needed for SoftDeleteByPublicID - publicID is passed directly
	// This function is kept for compatibility but generates nothing
	_ = tableName
	_ = table
	_ = analysis
	_ = pascal
}

// CRUD method writers
func writeGetMethod(buf *bytes.Buffer, tableName string, table ddl.Table, analysis portsqlcodegen.TableAnalysis, pascal string, cfg UnifiedRunnerConfig) {
	typesPackage := "queries"
	methodName := codegen.CRUD.GetMethodName(tableName)
	resultType := fmt.Sprintf("%s.%s", typesPackage, codegen.CRUD.GetResultType(tableName))

	// Use ByPublicID signature - takes publicID directly, not params struct
	buf.WriteString(fmt.Sprintf("// %s fetches a single %s by its public ID.\n", methodName, singular(tableName)))
	buf.WriteString(fmt.Sprintf("func (r *QueryRunner) %s(ctx context.Context, publicID string) (*%s, error) {\n", methodName, resultType))

	// Build args - just the publicID
	buf.WriteString("\targs := []any{publicID}\n")

	buf.WriteString(fmt.Sprintf("\trow := r.db.QueryRowContext(ctx, r.get%sSQL, args...)\n\n", pascal))

	buf.WriteString(fmt.Sprintf("\tvar result %s\n", resultType))
	buf.WriteString("\tif err := row.Scan(\n")
	for _, col := range table.Columns {
		if col.Name == "id" {
			continue
		}
		buf.WriteString(fmt.Sprintf("\t\t&result.%s,\n", dbstrings.ToPascalCase(col.Name)))
	}
	buf.WriteString("\t); err != nil {\n")
	buf.WriteString("\t\tif err == sql.ErrNoRows {\n")
	buf.WriteString("\t\t\treturn nil, nil\n")
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t\treturn nil, err\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn &result, nil\n")
	buf.WriteString("}\n\n")
}

func writeListMethod(buf *bytes.Buffer, tableName string, table ddl.Table, analysis portsqlcodegen.TableAnalysis, cfg UnifiedRunnerConfig) {
	typesPackage := "queries"
	plural := dbstrings.ToPascalCase(tableName)
	methodName := codegen.CRUD.ListMethodName(tableName)
	paramType := fmt.Sprintf("%s.%s", typesPackage, codegen.CRUD.ListParamsType(tableName))
	itemType := fmt.Sprintf("%s.%s", typesPackage, codegen.CRUD.ListItemType(tableName))
	resultType := fmt.Sprintf("%s.%s", typesPackage, codegen.CRUD.ListResultType(tableName))
	cursorType := fmt.Sprintf("%s.%s", typesPackage, codegen.CRUD.ListCursorType(tableName))

	buf.WriteString(fmt.Sprintf("// %s fetches %s with pagination.\n", methodName, tableName))
	buf.WriteString(fmt.Sprintf("func (r *QueryRunner) %s(ctx context.Context, params %s) (*%s, error) {\n", methodName, paramType, resultType))

	// Handle pagination params
	buf.WriteString("\tlimit := params.Limit\n")
	buf.WriteString("\tif limit <= 0 {\n")
	buf.WriteString("\t\tlimit = 20\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\t// Fetch one extra to determine if there's a next page\n")
	buf.WriteString("\tfetchLimit := limit + 1\n\n")

	buf.WriteString("\t_ = params.Cursor // TODO: Implement cursor-based pagination in SQL\n\n")

	buf.WriteString(fmt.Sprintf("\trows, err := r.db.QueryContext(ctx, r.list%sSQL)\n", plural))
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString("\t\treturn nil, err\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tdefer rows.Close()\n\n")

	buf.WriteString(fmt.Sprintf("\tvar items []%s\n", itemType))
	buf.WriteString("\tfor rows.Next() {\n")
	buf.WriteString(fmt.Sprintf("\t\tvar item %s\n", itemType))
	buf.WriteString("\t\tif err := rows.Scan(\n")
	for _, col := range table.Columns {
		if col.Name == "id" {
			continue
		}
		buf.WriteString(fmt.Sprintf("\t\t\t&item.%s,\n", dbstrings.ToPascalCase(col.Name)))
	}
	buf.WriteString("\t\t); err != nil {\n")
	buf.WriteString("\t\t\treturn nil, err\n")
	buf.WriteString("\t\t}\n")
	buf.WriteString("\t\titems = append(items, item)\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\tif err := rows.Err(); err != nil {\n")
	buf.WriteString("\t\treturn nil, err\n")
	buf.WriteString("\t}\n\n")

	// Determine next cursor
	buf.WriteString(fmt.Sprintf("\tresult := &%s{Items: items}\n", resultType))
	buf.WriteString("\t_ = fetchLimit // TODO: Use fetchLimit to determine next cursor\n")
	buf.WriteString(fmt.Sprintf("\t_ = %s{} // suppress unused\n", cursorType))
	buf.WriteString("\treturn result, nil\n")
	buf.WriteString("}\n\n")
}

func writeCreateMethod(buf *bytes.Buffer, tableName string, table ddl.Table, analysis portsqlcodegen.TableAnalysis, pascal string, cfg UnifiedRunnerConfig) {
	typesPackage := "queries"
	paramType := fmt.Sprintf("%s.Create%sParams", typesPackage, pascal)
	resultType := fmt.Sprintf("%s.Create%sResult", typesPackage, pascal)

	buf.WriteString(fmt.Sprintf("// Create%s creates a new %s.\n", pascal, singular(tableName)))
	buf.WriteString(fmt.Sprintf("func (r *QueryRunner) Create%s(ctx context.Context, params %s) (*%s, error) {\n", pascal, paramType, resultType))

	// Generate public_id if needed
	if analysis.HasPublicID {
		buf.WriteString("\tpublicID := nanoid.New()\n")
	}

	// Build args
	buf.WriteString("\targs := []any{\n")
	if analysis.HasPublicID {
		buf.WriteString("\t\tpublicID,\n")
	}
	for _, col := range table.Columns {
		if col.Name == "id" || col.Name == "public_id" || col.Name == "created_at" || col.Name == "updated_at" || col.Name == "deleted_at" {
			continue
		}
		buf.WriteString(fmt.Sprintf("\t\tparams.%s,\n", dbstrings.ToPascalCase(col.Name)))
	}
	buf.WriteString("\t}\n")

	buf.WriteString(fmt.Sprintf("\trow := r.db.QueryRowContext(ctx, r.create%sSQL, args...)\n\n", pascal))

	buf.WriteString(fmt.Sprintf("\tvar result %s\n", resultType))
	buf.WriteString("\tif err := row.Scan(\n")
	for _, col := range table.Columns {
		if col.Name == "id" {
			continue
		}
		buf.WriteString(fmt.Sprintf("\t\t&result.%s,\n", dbstrings.ToPascalCase(col.Name)))
	}
	buf.WriteString("\t); err != nil {\n")
	buf.WriteString("\t\treturn nil, err\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn &result, nil\n")
	buf.WriteString("}\n\n")
}

func writeUpdateMethod(buf *bytes.Buffer, tableName string, table ddl.Table, analysis portsqlcodegen.TableAnalysis, pascal string, cfg UnifiedRunnerConfig) {
	typesPackage := "queries"
	methodName := codegen.CRUD.UpdateMethodName(tableName)
	paramType := fmt.Sprintf("%s.%s", typesPackage, codegen.CRUD.UpdateParamsType(tableName))
	// Return GetResult type since we fetch the updated record using Get method
	resultType := fmt.Sprintf("%s.%s", typesPackage, codegen.CRUD.GetResultType(tableName))

	// Use ByPublicID signature - takes publicID and params separately
	buf.WriteString(fmt.Sprintf("// %s updates an existing %s by its public ID.\n", methodName, singular(tableName)))
	buf.WriteString(fmt.Sprintf("func (r *QueryRunner) %s(ctx context.Context, publicID string, params %s) (*%s, error) {\n", methodName, paramType, resultType))

	// Build args - SET values first, then WHERE condition (publicID)
	buf.WriteString("\targs := []any{\n")
	for _, col := range table.Columns {
		if col.Name == "id" || col.Name == "public_id" || col.Name == "created_at" || col.Name == "updated_at" || col.Name == "deleted_at" {
			continue
		}
		buf.WriteString(fmt.Sprintf("\t\tparams.%s,\n", dbstrings.ToPascalCase(col.Name)))
	}
	// WHERE condition - use publicID parameter
	buf.WriteString("\t\tpublicID,\n")
	buf.WriteString("\t}\n\n")

	// Execute update and fetch the updated row
	buf.WriteString(fmt.Sprintf("\t_, err := r.db.ExecContext(ctx, r.update%sSQL, args...)\n", pascal))
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString("\t\treturn nil, err\n")
	buf.WriteString("\t}\n\n")

	// Fetch the updated record using the Get method
	getMethodName := codegen.CRUD.GetMethodName(tableName)
	buf.WriteString(fmt.Sprintf("\treturn r.%s(ctx, publicID)\n", getMethodName))
	buf.WriteString("}\n\n")
}

func writeDeleteMethod(buf *bytes.Buffer, tableName string, table ddl.Table, analysis portsqlcodegen.TableAnalysis, pascal string, cfg UnifiedRunnerConfig) {
	methodName := codegen.CRUD.SoftDeleteMethodName(tableName)

	// Use ByPublicID signature - takes publicID directly
	buf.WriteString(fmt.Sprintf("// %s soft-deletes a %s by its public ID.\n", methodName, singular(tableName)))
	buf.WriteString(fmt.Sprintf("func (r *QueryRunner) %s(ctx context.Context, publicID string) error {\n", methodName))

	buf.WriteString("\targs := []any{publicID}\n")

	buf.WriteString(fmt.Sprintf("\t_, err := r.db.ExecContext(ctx, r.delete%sSQL, args...)\n", pascal))
	buf.WriteString("\treturn err\n")
	buf.WriteString("}\n\n")
}

// =============================================================================
// SQL Generation for CRUD
// =============================================================================

func generateGetSQL(table ddl.Table, analysis portsqlcodegen.TableAnalysis, compiler *compile.Compiler) string {
	dialect := compiler
	_ = dialect // TODO: Use dialect for proper quoting

	var cols []string
	for _, col := range table.Columns {
		if col.Name == "id" {
			continue
		}
		cols = append(cols, quoteIdentifier(col.Name, compiler))
	}

	whereCol := "public_id"
	if !analysis.HasPublicID && analysis.PrimaryKey != nil {
		whereCol = analysis.PrimaryKey.Name
	}

	sql := fmt.Sprintf("SELECT %s FROM %s WHERE %s = %s",
		strings.Join(cols, ", "),
		quoteIdentifier(table.Name, compiler),
		quoteIdentifier(whereCol, compiler),
		getPlaceholder(1, compiler))

	if analysis.HasDeletedAt {
		sql += fmt.Sprintf(" AND %s IS NULL", quoteIdentifier("deleted_at", compiler))
	}

	return sql
}

func generateListSQL(table ddl.Table, analysis portsqlcodegen.TableAnalysis, compiler *compile.Compiler) string {
	var cols []string
	for _, col := range table.Columns {
		if col.Name == "id" {
			continue
		}
		cols = append(cols, quoteIdentifier(col.Name, compiler))
	}

	sql := fmt.Sprintf("SELECT %s FROM %s",
		strings.Join(cols, ", "),
		quoteIdentifier(table.Name, compiler))

	if analysis.HasDeletedAt {
		sql += fmt.Sprintf(" WHERE %s IS NULL", quoteIdentifier("deleted_at", compiler))
	}

	return sql
}

func generateCreateSQL(table ddl.Table, analysis portsqlcodegen.TableAnalysis, compiler *compile.Compiler) string {
	var cols []string
	var placeholders []string
	var returnCols []string
	paramNum := 1

	if analysis.HasPublicID {
		cols = append(cols, quoteIdentifier("public_id", compiler))
		placeholders = append(placeholders, getPlaceholder(paramNum, compiler))
		paramNum++
	}

	for _, col := range table.Columns {
		if col.Name == "id" || col.Name == "public_id" || col.Name == "created_at" || col.Name == "updated_at" || col.Name == "deleted_at" {
			continue
		}
		cols = append(cols, quoteIdentifier(col.Name, compiler))
		placeholders = append(placeholders, getPlaceholder(paramNum, compiler))
		paramNum++
	}

	// Return columns
	for _, col := range table.Columns {
		if col.Name == "id" {
			continue
		}
		returnCols = append(returnCols, quoteIdentifier(col.Name, compiler))
	}

	sql := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s) RETURNING %s",
		quoteIdentifier(table.Name, compiler),
		strings.Join(cols, ", "),
		strings.Join(placeholders, ", "),
		strings.Join(returnCols, ", "))

	return sql
}

func generateUpdateSQL(table ddl.Table, analysis portsqlcodegen.TableAnalysis, compiler *compile.Compiler) string {
	var setClauses []string
	paramNum := 1

	for _, col := range table.Columns {
		if col.Name == "id" || col.Name == "public_id" || col.Name == "created_at" || col.Name == "updated_at" || col.Name == "deleted_at" {
			continue
		}
		setClauses = append(setClauses, fmt.Sprintf("%s = %s", quoteIdentifier(col.Name, compiler), getPlaceholder(paramNum, compiler)))
		paramNum++
	}

	// Add updated_at if present
	if analysis.HasUpdatedAt {
		setClauses = append(setClauses, fmt.Sprintf("%s = %s", quoteIdentifier("updated_at", compiler), getNowFunc(compiler)))
	}

	whereCol := "public_id"
	if !analysis.HasPublicID && analysis.PrimaryKey != nil {
		whereCol = analysis.PrimaryKey.Name
	}

	sql := fmt.Sprintf("UPDATE %s SET %s WHERE %s = %s",
		quoteIdentifier(table.Name, compiler),
		strings.Join(setClauses, ", "),
		quoteIdentifier(whereCol, compiler),
		getPlaceholder(paramNum, compiler))

	return sql
}

func generateDeleteSQL(table ddl.Table, analysis portsqlcodegen.TableAnalysis, compiler *compile.Compiler) string {
	whereCol := "public_id"
	if !analysis.HasPublicID && analysis.PrimaryKey != nil {
		whereCol = analysis.PrimaryKey.Name
	}

	if analysis.HasDeletedAt {
		// Soft delete
		return fmt.Sprintf("UPDATE %s SET %s = %s WHERE %s = %s",
			quoteIdentifier(table.Name, compiler),
			quoteIdentifier("deleted_at", compiler),
			getNowFunc(compiler),
			quoteIdentifier(whereCol, compiler),
			getPlaceholder(1, compiler))
	}

	// Hard delete
	return fmt.Sprintf("DELETE FROM %s WHERE %s = %s",
		quoteIdentifier(table.Name, compiler),
		quoteIdentifier(whereCol, compiler),
		getPlaceholder(1, compiler))
}

// =============================================================================
// Dialect Helpers
// =============================================================================

func quoteIdentifier(name string, compiler *compile.Compiler) string {
	// For now, just use double quotes (works for Postgres and SQLite)
	// MySQL uses backticks, but we'll handle that separately
	return `"` + name + `"`
}

func getPlaceholder(num int, compiler *compile.Compiler) string {
	// Default to Postgres-style $1, $2, etc.
	return fmt.Sprintf("$%d", num)
}

func getNowFunc(compiler *compile.Compiler) string {
	return "NOW()"
}

// =============================================================================
// Helper Functions
// =============================================================================

func sortedTableNames(tables map[string]ddl.Table) []string {
	names := make([]string, 0, len(tables))
	for name := range tables {
		names = append(names, name)
	}
	sort.Strings(names)
	return names
}

func singular(name string) string {
	return dbstrings.ToSingular(name)
}
