package dbpkg

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"

	"github.com/shipq/shipq/codegen"
	"github.com/shipq/shipq/codegen/crud"
	portsqlcodegen "github.com/shipq/shipq/db/portsql/codegen"
	"github.com/shipq/shipq/dburl"
	"github.com/shipq/shipq/inifile"
)

// DBPackageConfig holds configuration for generating the db package.
type DBPackageConfig struct {
	GoModRoot   string           // Directory containing go.mod
	ShipqRoot   string           // Directory containing shipq.ini
	ModulePath  string           // Module path from go.mod
	DatabaseURL string           // From shipq.ini [db] database_url
	Dialect     string           // postgres, mysql, or sqlite
	CRUDConfig  *crud.CRUDConfig // Scope and order configuration for CRUD generation
}

// GetTableOpts returns the TableOpts map from CRUDConfig, or an empty map if not configured.
func (c *DBPackageConfig) GetTableOpts() map[string]portsqlcodegen.CRUDOptions {
	if c.CRUDConfig != nil {
		return c.CRUDConfig.TableOpts
	}
	return make(map[string]portsqlcodegen.CRUDOptions)
}

// LoadDBPackageConfig reads shipq.ini and builds the config.
// goModRoot is the directory containing go.mod, shipqRoot is the directory containing shipq.ini.
// In a standard setup these are the same; in a monorepo, shipqRoot may be a subdirectory.
func LoadDBPackageConfig(goModRoot, shipqRoot string) (*DBPackageConfig, error) {
	modulePath, err := codegen.GetModulePath(goModRoot)
	if err != nil {
		return nil, err
	}

	shipqIniPath := filepath.Join(shipqRoot, "shipq.ini")
	ini, err := inifile.ParseFile(shipqIniPath)
	if err != nil {
		return nil, fmt.Errorf("failed to parse shipq.ini: %w", err)
	}

	databaseURL := ini.Get("db", "database_url")
	if databaseURL == "" {
		return nil, fmt.Errorf("db.database_url not configured in shipq.ini")
	}

	dialect, err := dburl.InferDialectFromDBUrl(databaseURL)
	if err != nil {
		return nil, fmt.Errorf("failed to determine dialect from database_url: %w", err)
	}

	// Load CRUD config (scope, order) - this doesn't require tables yet
	// Tables will be loaded later and ApplyScopeFiltering will be called
	crudCfg, _ := crud.LoadCRUDConfig(ini, nil) // Pass nil tables for now

	return &DBPackageConfig{
		GoModRoot:   goModRoot,
		ShipqRoot:   shipqRoot,
		ModulePath:  modulePath,
		DatabaseURL: databaseURL,
		Dialect:     dialect,
		CRUDConfig:  crudCfg,
	}, nil
}

// GenerateDBFile generates the db.go file content.
func GenerateDBFile(cfg *DBPackageConfig) ([]byte, error) {
	var buf bytes.Buffer

	// Determine driver import based on dialect
	var driverImport, driverName string
	switch cfg.Dialect {
	case dburl.DialectPostgres:
		driverImport = `_ "github.com/jackc/pgx/v5/stdlib"`
		driverName = "pgx"
	case dburl.DialectMySQL:
		driverImport = `_ "github.com/go-sql-driver/mysql"`
		driverName = "mysql"
	case dburl.DialectSQLite:
		driverImport = `_ "modernc.org/sqlite"`
		driverName = "sqlite"
	default:
		return nil, fmt.Errorf("unsupported dialect: %s", cfg.Dialect)
	}

	buf.WriteString(`// Code generated by shipq. DO NOT EDIT.
package db

import (
	"database/sql"
	"fmt"
	"os"
	"sync"

	`)
	buf.WriteString(driverImport)
	buf.WriteString(`
)

// Dialect is the database dialect configured for this project.
const Dialect = "`)
	buf.WriteString(cfg.Dialect)
	buf.WriteString(`"

// localhostURL is the fallback URL from shipq.ini at code generation time.
// Used for local development when DATABASE_URL is not set.
const localhostURL = "`)
	buf.WriteString(cfg.DatabaseURL)
	buf.WriteString(`"

var (
	db     *sql.DB
	dbOnce sync.Once
	dbErr  error
)

// DB returns the database connection pool.
// On first call, it initializes the connection using DATABASE_URL env var,
// falling back to the compile-time localhost URL from shipq.ini.
func DB() (*sql.DB, error) {
	dbOnce.Do(func() {
		dbURL := os.Getenv("DATABASE_URL")
		if dbURL == "" {
			fmt.Fprintln(os.Stderr, "shipq: DATABASE_URL not set, using localhost fallback")
			dbURL = localhostURL
		}

		if dbURL == "" {
			dbErr = fmt.Errorf("shipq: no database URL available (set DATABASE_URL or configure db.database_url in shipq.ini)")
			return
		}

		// Convert URL to driver-specific DSN if needed
		dsn, err := urlToDSN(dbURL)
		if err != nil {
			dbErr = fmt.Errorf("shipq: failed to parse database URL: %w", err)
			return
		}

		db, dbErr = sql.Open("`)
	buf.WriteString(driverName)
	buf.WriteString(`", dsn)
		if dbErr != nil {
			dbErr = fmt.Errorf("shipq: failed to open database: %w", dbErr)
			return
		}

		// Verify connection
		if err := db.Ping(); err != nil {
			dbErr = fmt.Errorf("shipq: failed to ping database: %w", err)
			return
		}
	})

	return db, dbErr
}

// MustDB returns the database connection pool or panics on error.
func MustDB() *sql.DB {
	db, err := DB()
	if err != nil {
		panic(err)
	}
	return db
}

`)

	// Add dialect-specific URL to DSN conversion
	switch cfg.Dialect {
	case dburl.DialectPostgres:
		buf.WriteString(`// urlToDSN converts a postgres:// URL to a pgx-compatible connection string.
// pgx accepts the URL format directly.
func urlToDSN(dbURL string) (string, error) {
	return dbURL, nil
}
`)
	case dburl.DialectMySQL:
		buf.WriteString(`// urlToDSN converts a mysql:// URL to a MySQL DSN.
// Format: user:password@tcp(host:port)/dbname
func urlToDSN(dbURL string) (string, error) {
	// Strip mysql:// prefix
	if len(dbURL) > 8 && dbURL[:8] == "mysql://" {
		dbURL = dbURL[8:]
	}

	// Find @ separator
	atIdx := -1
	for i, c := range dbURL {
		if c == '@' {
			atIdx = i
			break
		}
	}
	if atIdx == -1 {
		return "", fmt.Errorf("invalid MySQL URL: missing @ separator")
	}

	user := dbURL[:atIdx]
	rest := dbURL[atIdx+1:]

	// Find / separator for database
	slashIdx := -1
	for i, c := range rest {
		if c == '/' {
			slashIdx = i
			break
		}
	}

	var hostPort, dbName string
	if slashIdx == -1 {
		hostPort = rest
		dbName = ""
	} else {
		hostPort = rest[:slashIdx]
		dbName = rest[slashIdx+1:]
	}

	return fmt.Sprintf("%s@tcp(%s)/%s", user, hostPort, dbName), nil
}
`)
	case dburl.DialectSQLite:
		buf.WriteString(`// urlToDSN converts a sqlite:// URL to a file path.
func urlToDSN(dbURL string) (string, error) {
	// Strip sqlite:// or sqlite: prefix
	if len(dbURL) > 9 && dbURL[:9] == "sqlite://" {
		return dbURL[9:], nil
	}
	if len(dbURL) > 7 && dbURL[:7] == "sqlite:" {
		return dbURL[7:], nil
	}
	return dbURL, nil
}
`)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return buf.Bytes(), fmt.Errorf("failed to format db.go: %w", err)
	}

	return formatted, nil
}

// EnsureDBPackage generates or updates the shipq/db package.
// This is the main entry point that other commands should call.
// shipqRoot is the directory containing shipq.ini where the db package will be generated.
func EnsureDBPackage(shipqRoot string) error {
	// Find go.mod root from shipq root for loading module path
	goModRoot, err := findGoModRootFrom(shipqRoot)
	if err != nil {
		return fmt.Errorf("failed to find go.mod: %w", err)
	}

	cfg, err := LoadDBPackageConfig(goModRoot, shipqRoot)
	if err != nil {
		return err
	}

	// Create shipq/db directory (in shipq root)
	dbPkgPath := filepath.Join(shipqRoot, "shipq", "db")
	if err := codegen.EnsureDir(dbPkgPath); err != nil {
		return fmt.Errorf("failed to create shipq/db directory: %w", err)
	}

	// Generate and write db.go
	dbContent, err := GenerateDBFile(cfg)
	if err != nil {
		return err
	}

	dbFilePath := filepath.Join(dbPkgPath, "db.go")
	if _, err := codegen.WriteFileIfChanged(dbFilePath, dbContent); err != nil {
		return fmt.Errorf("failed to write db.go: %w", err)
	}

	return nil
}

// findGoModRootFrom walks up from the given directory looking for go.mod.
// This is a local helper to avoid circular import with project package.
func findGoModRootFrom(startDir string) (string, error) {
	dir := startDir
	for {
		goModPath := filepath.Join(dir, "go.mod")
		if _, err := os.Stat(goModPath); err == nil {
			return dir, nil
		}

		parent := filepath.Dir(dir)
		if parent == dir {
			return "", fmt.Errorf("go.mod not found")
		}
		dir = parent
	}
}
