package codegen

import (
	"bytes"
	"fmt"
	"go/format"
	"regexp"
	"sort"
	"strings"
)

// HTTPTestClientGenConfig holds configuration for generating the HTTP test client.
type HTTPTestClientGenConfig struct {
	ModulePath string                  // e.g., "myapp"
	Handlers   []SerializedHandlerInfo // handlers from registry
	OutputPkg  string                  // package name for generated code (e.g., "api")
}

// GenerateHTTPTestClient generates a type-safe HTTP client for testing.
func GenerateHTTPTestClient(cfg HTTPTestClientGenConfig) ([]byte, error) {
	var buf bytes.Buffer

	// Collect unique handler package imports
	handlerPkgs := collectHandlerPackages(cfg.Handlers)

	// Generate file header
	buf.WriteString("// Code generated by shipq. DO NOT EDIT.\n")
	fmt.Fprintf(&buf, "package %s\n\n", cfg.OutputPkg)

	// Generate imports
	generateTestClientImports(&buf, handlerPkgs)

	// Generate Client struct
	generateTestClientStruct(&buf)

	// Generate constructor
	generateTestClientConstructor(&buf)

	// Generate method for each handler
	for _, h := range cfg.Handlers {
		generateTestClientMethod(&buf, h, handlerPkgs)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted source for debugging
		return buf.Bytes(), fmt.Errorf("failed to format HTTP test client code: %w\nunformatted:\n%s", err, buf.String())
	}

	return formatted, nil
}

// generateTestClientImports writes the import block for the test client.
func generateTestClientImports(buf *bytes.Buffer, handlerPkgs map[string]packageAlias) {
	buf.WriteString("import (\n")
	buf.WriteString("\t\"bytes\"\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"encoding/json\"\n")
	buf.WriteString("\t\"fmt\"\n")
	buf.WriteString("\t\"io\"\n")
	buf.WriteString("\t\"net/http\"\n")
	buf.WriteString("\t\"net/http/httptest\"\n")
	buf.WriteString("\t\"strings\"\n")

	// Handler packages
	if len(handlerPkgs) > 0 {
		buf.WriteString("\n")

		// Sort by alias for deterministic output
		var aliases []packageAlias
		for _, pkg := range handlerPkgs {
			aliases = append(aliases, pkg)
		}
		sort.Slice(aliases, func(i, j int) bool {
			return aliases[i].Alias < aliases[j].Alias
		})

		for _, pkg := range aliases {
			fmt.Fprintf(buf, "\t%s %q\n", pkg.Alias, pkg.Path)
		}
	}

	buf.WriteString(")\n\n")
}

// generateTestClientStruct generates the Client struct definition.
func generateTestClientStruct(buf *bytes.Buffer) {
	buf.WriteString(`// Client is a type-safe HTTP client for testing.
type Client struct {
	server *httptest.Server
	http   *http.Client
}

`)
}

// generateTestClientConstructor generates the NewUnauthenticatedTestClient function.
func generateTestClientConstructor(buf *bytes.Buffer) {
	buf.WriteString(`// NewUnauthenticatedTestClient creates a test client for the given server.
func NewUnauthenticatedTestClient(ts *httptest.Server) *Client {
	return &Client{
		server: ts,
		http:   ts.Client(),
	}
}

`)
}

// generateTestClientMethod generates a typed method for a single handler.
func generateTestClientMethod(buf *bytes.Buffer, h SerializedHandlerInfo, handlerPkgs map[string]packageAlias) {
	// Get the package alias for this handler
	pkgAlias := ""
	if pkg, ok := handlerPkgs[h.PackagePath]; ok {
		pkgAlias = pkg.Alias
	}

	// Determine request and response types
	reqType := "struct{}"
	if h.Request != nil && h.Request.Name != "" {
		reqType = h.Request.Name
		if pkgAlias != "" {
			reqType = pkgAlias + "." + reqType
		}
	}

	respType := "struct{}"
	if h.Response != nil && h.Response.Name != "" {
		respType = h.Response.Name
		if pkgAlias != "" {
			respType = pkgAlias + "." + respType
		}
	}

	// Check if this is a DELETE that returns no body
	isDeleteNoBody := h.Method == "DELETE" && (h.Response == nil || len(h.Response.Fields) == 0)

	// Generate method signature
	convertedPath := ConvertPathSyntax(h.Path)
	fmt.Fprintf(buf, "// %s calls %s %s\n", h.FuncName, h.Method, h.Path)

	if isDeleteNoBody {
		fmt.Fprintf(buf, "func (c *Client) %s(ctx context.Context, req %s) error {\n", h.FuncName, reqType)
	} else {
		fmt.Fprintf(buf, "func (c *Client) %s(ctx context.Context, req %s) (%s, error) {\n", h.FuncName, reqType, respType)
	}

	// Declare response variable if needed
	if !isDeleteNoBody {
		fmt.Fprintf(buf, "\tvar resp %s\n", respType)
	}

	// Build URL with path parameter substitution
	generateURLConstruction(buf, convertedPath, h)

	// Create request with optional body
	generateRequestCreation(buf, h)

	// Execute request
	buf.WriteString("\thttpResp, err := c.http.Do(httpReq)\n")
	buf.WriteString("\tif err != nil {\n")
	if isDeleteNoBody {
		buf.WriteString("\t\treturn err\n")
	} else {
		buf.WriteString("\t\treturn resp, err\n")
	}
	buf.WriteString("\t}\n")
	buf.WriteString("\tdefer httpResp.Body.Close()\n\n")

	// Handle error responses
	buf.WriteString("\tif httpResp.StatusCode >= 400 {\n")
	buf.WriteString("\t\tbodyBytes, _ := io.ReadAll(httpResp.Body)\n")
	if isDeleteNoBody {
		buf.WriteString("\t\treturn fmt.Errorf(\"HTTP %d: %s\", httpResp.StatusCode, string(bodyBytes))\n")
	} else {
		buf.WriteString("\t\treturn resp, fmt.Errorf(\"HTTP %d: %s\", httpResp.StatusCode, string(bodyBytes))\n")
	}
	buf.WriteString("\t}\n\n")

	// Decode response
	if isDeleteNoBody {
		buf.WriteString("\treturn nil\n")
	} else {
		buf.WriteString("\tif err := json.NewDecoder(httpResp.Body).Decode(&resp); err != nil {\n")
		buf.WriteString("\t\treturn resp, fmt.Errorf(\"failed to decode response: %w\", err)\n")
		buf.WriteString("\t}\n\n")
		buf.WriteString("\treturn resp, nil\n")
	}

	buf.WriteString("}\n\n")
}

// generateURLConstruction generates code to build the URL with path parameter substitution.
func generateURLConstruction(buf *bytes.Buffer, convertedPath string, h SerializedHandlerInfo) {
	if len(h.PathParams) == 0 {
		// No path params, simple URL
		fmt.Fprintf(buf, "\turl := c.server.URL + %q\n\n", convertedPath)
		return
	}

	// Build URL with path parameter substitution
	// Convert {param} syntax back to a format we can use for string replacement
	buf.WriteString("\turl := c.server.URL + ")

	// Start building the path with replacements
	pathParts := parsePathForReplacement(convertedPath)

	if len(pathParts) == 1 && pathParts[0].isLiteral {
		// No actual params to substitute (shouldn't happen but handle gracefully)
		fmt.Fprintf(buf, "%q\n\n", convertedPath)
		return
	}

	// Use strings.Replace or direct string building
	buf.WriteString("strings.NewReplacer(\n")
	for _, param := range h.PathParams {
		// Find the matching field in the request to get the Go field name
		fieldName := findRequestFieldForParam(h, param.Name)
		fmt.Fprintf(buf, "\t\t\"{%s}\", req.%s,\n", param.Name, fieldName)
	}
	fmt.Fprintf(buf, "\t).Replace(%q)\n\n", convertedPath)
}

// pathPart represents either a literal string or a parameter placeholder.
type pathPart struct {
	value     string
	isLiteral bool
}

// parsePathForReplacement parses a path like "/users/{id}/posts" into parts.
func parsePathForReplacement(path string) []pathPart {
	var parts []pathPart
	re := regexp.MustCompile(`\{([a-zA-Z_][a-zA-Z0-9_]*)\}`)
	matches := re.FindAllStringSubmatchIndex(path, -1)

	if len(matches) == 0 {
		return []pathPart{{value: path, isLiteral: true}}
	}

	lastEnd := 0
	for _, match := range matches {
		if match[0] > lastEnd {
			parts = append(parts, pathPart{value: path[lastEnd:match[0]], isLiteral: true})
		}
		parts = append(parts, pathPart{value: path[match[2]:match[3]], isLiteral: false})
		lastEnd = match[1]
	}
	if lastEnd < len(path) {
		parts = append(parts, pathPart{value: path[lastEnd:], isLiteral: true})
	}

	return parts
}

// findRequestFieldForParam finds the Go field name for a path parameter.
func findRequestFieldForParam(h SerializedHandlerInfo, paramName string) string {
	if h.Request == nil {
		return paramName
	}

	for _, field := range h.Request.Fields {
		if strings.EqualFold(field.JSONName, paramName) || strings.EqualFold(field.Name, paramName) {
			return field.Name
		}
	}

	// Default to the parameter name with first letter capitalized
	if len(paramName) > 0 {
		return strings.ToUpper(paramName[:1]) + paramName[1:]
	}
	return paramName
}

// generateRequestCreation generates code to create the HTTP request.
func generateRequestCreation(buf *bytes.Buffer, h SerializedHandlerInfo) {
	hasBody := methodHasBody(h.Method)

	if hasBody && h.Request != nil && len(h.Request.Fields) > 0 {
		// Marshal request body
		buf.WriteString("\tbody, err := json.Marshal(req)\n")
		buf.WriteString("\tif err != nil {\n")
		buf.WriteString("\t\treturn resp, fmt.Errorf(\"failed to marshal request: %w\", err)\n")
		buf.WriteString("\t}\n\n")

		fmt.Fprintf(buf, "\thttpReq, err := http.NewRequestWithContext(ctx, %q, url, bytes.NewReader(body))\n", h.Method)
		buf.WriteString("\tif err != nil {\n")
		buf.WriteString("\t\treturn resp, fmt.Errorf(\"failed to create request: %w\", err)\n")
		buf.WriteString("\t}\n")
		buf.WriteString("\thttpReq.Header.Set(\"Content-Type\", \"application/json\")\n\n")
	} else {
		// No body
		isDeleteNoBody := h.Method == "DELETE" && (h.Response == nil || len(h.Response.Fields) == 0)
		fmt.Fprintf(buf, "\thttpReq, err := http.NewRequestWithContext(ctx, %q, url, nil)\n", h.Method)
		buf.WriteString("\tif err != nil {\n")
		if isDeleteNoBody {
			buf.WriteString("\t\treturn fmt.Errorf(\"failed to create request: %w\", err)\n")
		} else {
			buf.WriteString("\t\treturn resp, fmt.Errorf(\"failed to create request: %w\", err)\n")
		}
		buf.WriteString("\t}\n\n")
	}
}
