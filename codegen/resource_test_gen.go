package codegen

import (
	"bytes"
	"fmt"
	"go/format"
	"strings"
)

// ResourceTestGenConfig holds configuration for generating resource tests.
type ResourceTestGenConfig struct {
	ModulePath string // e.g., "myapp"
	OutputPkg  string // package name for API code (e.g., "api")
}

// GenerateResourceTest generates a test file for a full resource.
// The test covers the complete CRUD lifecycle: Create → GetOne → Update → List → Delete → GetOne(404) → List(excluded).
func GenerateResourceTest(cfg ResourceTestGenConfig, resource ResourceInfo) ([]byte, error) {
	if !resource.IsFullResource() {
		return nil, fmt.Errorf("resource %q is not a full resource (missing CRUD operations)", resource.PackagePath)
	}

	var buf bytes.Buffer

	// Generate file header
	buf.WriteString("// Code generated by shipq. DO NOT EDIT.\n")
	fmt.Fprintf(&buf, "package %s_test\n\n", resource.PackageName)

	// Generate imports
	generateResourceTestImports(&buf, cfg, resource)

	// Generate the CRUD test function
	generateCRUDTestFunction(&buf, cfg, resource)

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted source for debugging
		return buf.Bytes(), fmt.Errorf("failed to format resource test code: %w\nunformatted:\n%s", err, buf.String())
	}

	return formatted, nil
}

// generateResourceTestImports writes the import block for resource tests.
func generateResourceTestImports(buf *bytes.Buffer, cfg ResourceTestGenConfig, resource ResourceInfo) {
	buf.WriteString("import (\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"database/sql\"\n")
	buf.WriteString("\t\"os\"\n")
	buf.WriteString("\t\"testing\"\n")
	buf.WriteString("\n")

	// API package import
	apiPkg := cfg.ModulePath + "/" + cfg.OutputPkg
	fmt.Fprintf(buf, "\t%q\n", apiPkg)

	// Resource package import
	fmt.Fprintf(buf, "\t%q\n", resource.PackagePath)

	buf.WriteString(")\n\n")
}

// generateCRUDTestFunction generates the main CRUD test function.
func generateCRUDTestFunction(buf *bytes.Buffer, cfg ResourceTestGenConfig, resource ResourceInfo) {
	resourceName := toPascalCase(resource.PackageName)
	singularName := toSingular(resourceName)

	fmt.Fprintf(buf, "func TestResource_%s_CRUD(t *testing.T) {\n", singularName)

	// Setup
	buf.WriteString("\tctx := context.Background()\n\n")

	// Database setup
	buf.WriteString("\t// Get database connection from environment\n")
	buf.WriteString("\tdbURL := os.Getenv(\"DATABASE_URL\")\n")
	buf.WriteString("\tif dbURL == \"\" {\n")
	buf.WriteString("\t\tt.Skip(\"DATABASE_URL not set, skipping integration test\")\n")
	buf.WriteString("\t}\n\n")

	buf.WriteString("\tdb, err := sql.Open(\"mysql\", dbURL)\n")
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString("\t\tt.Fatalf(\"failed to open database: %v\", err)\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\tdefer db.Close()\n\n")

	// Create test server and client
	fmt.Fprintf(buf, "\tts := %s.NewUnauthenticatedTestServer(t, db)\n", cfg.OutputPkg)
	fmt.Fprintf(buf, "\tclient := %s.NewUnauthenticatedTestClient(ts.Server)\n\n", cfg.OutputPkg)

	// Generate Create section
	generateCreateSection(buf, resource)

	// Generate GetOne section
	generateGetOneSection(buf, resource)

	// Generate Update section
	generateUpdateSection(buf, resource)

	// Generate List section (should include the record)
	generateListSection(buf, resource, true)

	// Generate Delete section
	generateDeleteSection(buf, resource)

	// Generate GetOne after delete (should 404)
	generateGetOneAfterDeleteSection(buf, resource)

	// Generate List after delete (should exclude deleted record)
	generateListSection(buf, resource, false)

	buf.WriteString("}\n")
}

// generateCreateSection generates the Create test section.
func generateCreateSection(buf *bytes.Buffer, resource ResourceInfo) {
	buf.WriteString("\t// -------------------------------------------------------------------------\n")
	buf.WriteString("\t// Create\n")
	buf.WriteString("\t// -------------------------------------------------------------------------\n")

	if resource.CreateHandler == nil || resource.CreateHandler.Request == nil {
		buf.WriteString("\t// TODO: Add create request fields\n")
		fmt.Fprintf(buf, "\tcreateReq := %s.%s{}\n", resource.PackageName, resource.CreateHandler.Request.Name)
	} else {
		fmt.Fprintf(buf, "\tcreateReq := %s.%s{\n", resource.PackageName, resource.CreateHandler.Request.Name)
		// Generate sample values for required fields
		for _, field := range resource.CreateHandler.Request.Fields {
			if field.Required && !isIDField(field.JSONName) {
				sampleValue := getSampleValue(field.Type, field.Name)
				fmt.Fprintf(buf, "\t\t%s: %s,\n", field.Name, sampleValue)
			}
		}
		buf.WriteString("\t}\n")
	}

	fmt.Fprintf(buf, "\tcreated, err := client.%s(ctx, createReq)\n", resource.CreateHandler.FuncName)
	buf.WriteString("\tif err != nil {\n")
	fmt.Fprintf(buf, "\t\tt.Fatalf(\"%s failed: %%v\", err)\n", resource.CreateHandler.FuncName)
	buf.WriteString("\t}\n\n")

	// Extract the ID for subsequent operations
	idJSONName := GetResourceIDJSONName(resource)
	responseIDField := findResponseIDField(resource.CreateHandler.Response, idJSONName)

	if responseIDField != "" {
		fmt.Fprintf(buf, "\tpublicID := created.%s\n", responseIDField)
		buf.WriteString("\tif publicID == \"\" {\n")
		buf.WriteString("\t\tt.Fatal(\"created resource has empty ID\")\n")
		buf.WriteString("\t}\n\n")
	} else {
		buf.WriteString("\t// TODO: Extract resource ID from created response\n")
		buf.WriteString("\tpublicID := \"\" // Extract from created response\n\n")
	}

	// Add basic field verification
	if resource.CreateHandler.Request != nil {
		for _, field := range resource.CreateHandler.Request.Fields {
			if field.Required && !isIDField(field.JSONName) && field.Type == "string" {
				responseField := findMatchingResponseField(resource.CreateHandler.Response, field.Name)
				if responseField != "" {
					fmt.Fprintf(buf, "\tif created.%s != createReq.%s {\n", responseField, field.Name)
					fmt.Fprintf(buf, "\t\tt.Errorf(\"%s mismatch: got %%q, want %%q\", created.%s, createReq.%s)\n", field.Name, responseField, field.Name)
					buf.WriteString("\t}\n")
				}
			}
		}
	}
	buf.WriteString("\n")
}

// generateGetOneSection generates the GetOne test section.
func generateGetOneSection(buf *bytes.Buffer, resource ResourceInfo) {
	buf.WriteString("\t// -------------------------------------------------------------------------\n")
	buf.WriteString("\t// GetOne\n")
	buf.WriteString("\t// -------------------------------------------------------------------------\n")

	idField := GetResourceIDField(resource)
	fmt.Fprintf(buf, "\tgetReq := %s.%s{\n", resource.PackageName, resource.GetOneHandler.Request.Name)
	fmt.Fprintf(buf, "\t\t%s: publicID,\n", idField)
	buf.WriteString("\t}\n")

	fmt.Fprintf(buf, "\tgot, err := client.%s(ctx, getReq)\n", resource.GetOneHandler.FuncName)
	buf.WriteString("\tif err != nil {\n")
	fmt.Fprintf(buf, "\t\tt.Fatalf(\"%s failed: %%v\", err)\n", resource.GetOneHandler.FuncName)
	buf.WriteString("\t}\n\n")

	// Verify the ID matches
	idJSONName := GetResourceIDJSONName(resource)
	responseIDField := findResponseIDField(resource.GetOneHandler.Response, idJSONName)
	if responseIDField != "" {
		fmt.Fprintf(buf, "\tif got.%s != publicID {\n", responseIDField)
		fmt.Fprintf(buf, "\t\tt.Errorf(\"ID mismatch: got %%q, want %%q\", got.%s, publicID)\n", responseIDField)
		buf.WriteString("\t}\n")
	}
	buf.WriteString("\n")
}

// generateUpdateSection generates the Update test section.
func generateUpdateSection(buf *bytes.Buffer, resource ResourceInfo) {
	buf.WriteString("\t// -------------------------------------------------------------------------\n")
	buf.WriteString("\t// Update\n")
	buf.WriteString("\t// -------------------------------------------------------------------------\n")

	idField := GetResourceIDField(resource)
	fmt.Fprintf(buf, "\tupdateReq := %s.%s{\n", resource.PackageName, resource.UpdateHandler.Request.Name)
	fmt.Fprintf(buf, "\t\t%s: publicID,\n", idField)

	// Generate updated values for fields
	if resource.UpdateHandler.Request != nil {
		for _, field := range resource.UpdateHandler.Request.Fields {
			if !isIDField(field.JSONName) && field.Type == "string" {
				fmt.Fprintf(buf, "\t\t%s: \"updated_%s\",\n", field.Name, strings.ToLower(field.Name))
				break // Just update one field for the test
			}
		}
	}
	buf.WriteString("\t}\n")

	fmt.Fprintf(buf, "\tupdated, err := client.%s(ctx, updateReq)\n", resource.UpdateHandler.FuncName)
	buf.WriteString("\tif err != nil {\n")
	fmt.Fprintf(buf, "\t\tt.Fatalf(\"%s failed: %%v\", err)\n", resource.UpdateHandler.FuncName)
	buf.WriteString("\t}\n")
	buf.WriteString("\t_ = updated // Use updated response if needed\n\n")
}

// generateListSection generates the List test section.
func generateListSection(buf *bytes.Buffer, resource ResourceInfo, shouldInclude bool) {
	buf.WriteString("\t// -------------------------------------------------------------------------\n")
	if shouldInclude {
		buf.WriteString("\t// List (should include our record)\n")
	} else {
		buf.WriteString("\t// List after delete (should NOT include deleted record)\n")
	}
	buf.WriteString("\t// -------------------------------------------------------------------------\n")

	varName := "listResp"
	if !shouldInclude {
		varName = "listAfterDelete"
	}

	fmt.Fprintf(buf, "\t%s, err := client.%s(ctx, %s.%s{})\n",
		varName, resource.ListHandler.FuncName, resource.PackageName, resource.ListHandler.Request.Name)
	buf.WriteString("\tif err != nil {\n")
	fmt.Fprintf(buf, "\t\tt.Fatalf(\"%s failed: %%v\", err)\n", resource.ListHandler.FuncName)
	buf.WriteString("\t}\n\n")

	// Find the list field in the response (typically "Items" or similar)
	listFieldName := findListFieldName(resource.ListHandler.Response)
	idJSONName := GetResourceIDJSONName(resource)

	if listFieldName != "" {
		buf.WriteString("\tfound := false\n")
		fmt.Fprintf(buf, "\tfor _, item := range %s.%s {\n", varName, listFieldName)

		// Find ID field in list item
		itemIDField := findListItemIDField(resource.ListHandler.Response, listFieldName, idJSONName)
		if itemIDField != "" {
			fmt.Fprintf(buf, "\t\tif item.%s == publicID {\n", itemIDField)
		} else {
			buf.WriteString("\t\t// TODO: Check if item matches publicID\n")
			buf.WriteString("\t\tif false {\n")
		}
		buf.WriteString("\t\t\tfound = true\n")
		buf.WriteString("\t\t\tbreak\n")
		buf.WriteString("\t\t}\n")
		buf.WriteString("\t}\n")

		if shouldInclude {
			buf.WriteString("\tif !found {\n")
			buf.WriteString("\t\tt.Error(\"Created resource not found in list\")\n")
			buf.WriteString("\t}\n")
		} else {
			buf.WriteString("\tif found {\n")
			buf.WriteString("\t\tt.Error(\"Deleted resource should not appear in list\")\n")
			buf.WriteString("\t}\n")
		}
	} else {
		buf.WriteString("\t// TODO: Verify list contains/excludes the resource\n")
		fmt.Fprintf(buf, "\t_ = %s\n", varName)
	}
	buf.WriteString("\n")
}

// generateDeleteSection generates the Delete test section.
func generateDeleteSection(buf *bytes.Buffer, resource ResourceInfo) {
	buf.WriteString("\t// -------------------------------------------------------------------------\n")
	buf.WriteString("\t// Delete (soft delete)\n")
	buf.WriteString("\t// -------------------------------------------------------------------------\n")

	idField := GetResourceIDField(resource)
	fmt.Fprintf(buf, "\tdeleteReq := %s.%s{\n", resource.PackageName, resource.DeleteHandler.Request.Name)
	fmt.Fprintf(buf, "\t\t%s: publicID,\n", idField)
	buf.WriteString("\t}\n")

	fmt.Fprintf(buf, "\terr = client.%s(ctx, deleteReq)\n", resource.DeleteHandler.FuncName)
	buf.WriteString("\tif err != nil {\n")
	fmt.Fprintf(buf, "\t\tt.Fatalf(\"%s failed: %%v\", err)\n", resource.DeleteHandler.FuncName)
	buf.WriteString("\t}\n\n")
}

// generateGetOneAfterDeleteSection generates the GetOne after delete section (should 404).
func generateGetOneAfterDeleteSection(buf *bytes.Buffer, resource ResourceInfo) {
	buf.WriteString("\t// -------------------------------------------------------------------------\n")
	buf.WriteString("\t// GetOne after delete => 404\n")
	buf.WriteString("\t// -------------------------------------------------------------------------\n")

	idField := GetResourceIDField(resource)
	fmt.Fprintf(buf, "\t_, err = client.%s(ctx, %s.%s{%s: publicID})\n",
		resource.GetOneHandler.FuncName, resource.PackageName, resource.GetOneHandler.Request.Name, idField)
	buf.WriteString("\tif err == nil {\n")
	buf.WriteString("\t\tt.Error(\"Expected 404 after delete, got success\")\n")
	buf.WriteString("\t}\n\n")
}

// Helper functions

// isIDField checks if a field name looks like an ID field.
func isIDField(jsonName string) bool {
	name := strings.ToLower(jsonName)
	return name == "id" ||
		name == "public_id" ||
		name == "publicid" ||
		strings.HasSuffix(name, "_id")
}

// getSampleValue returns a sample value for a given Go type.
func getSampleValue(goType, fieldName string) string {
	switch goType {
	case "string":
		return fmt.Sprintf("\"test_%s\"", strings.ToLower(fieldName))
	case "int", "int32", "int64":
		return "1"
	case "uint", "uint32", "uint64":
		return "1"
	case "float32", "float64":
		return "1.0"
	case "bool":
		return "true"
	default:
		if strings.HasPrefix(goType, "*") {
			return "nil"
		}
		return fmt.Sprintf("%s{}", goType)
	}
}

// findResponseIDField finds the ID field name in a response struct.
func findResponseIDField(response *SerializedStructInfo, idJSONName string) string {
	if response == nil {
		return ""
	}
	for _, field := range response.Fields {
		if strings.EqualFold(field.JSONName, idJSONName) ||
			strings.EqualFold(field.Name, "PublicID") ||
			strings.EqualFold(field.Name, "ID") {
			return field.Name
		}
	}
	return ""
}

// findMatchingResponseField finds a response field that matches a request field name.
func findMatchingResponseField(response *SerializedStructInfo, fieldName string) string {
	if response == nil {
		return ""
	}
	for _, field := range response.Fields {
		if strings.EqualFold(field.Name, fieldName) {
			return field.Name
		}
	}
	return ""
}

// findListFieldName finds the field name in a list response that contains the items.
func findListFieldName(response *SerializedStructInfo) string {
	if response == nil {
		return ""
	}
	// Common patterns for list fields
	patterns := []string{"Items", "Data", "Results", "Records"}
	for _, pattern := range patterns {
		for _, field := range response.Fields {
			if strings.EqualFold(field.Name, pattern) {
				return field.Name
			}
		}
	}
	// Look for any slice field
	for _, field := range response.Fields {
		if strings.HasPrefix(field.Type, "[]") {
			return field.Name
		}
	}
	return ""
}

// findListItemIDField finds the ID field name in list items.
func findListItemIDField(response *SerializedStructInfo, listFieldName, idJSONName string) string {
	// For simplicity, assume the list items have the same ID field as GetOne response
	// In a more sophisticated implementation, we'd parse the slice element type
	if response == nil {
		return ""
	}
	// Common ID field patterns
	patterns := []string{"PublicID", "PublicId", "ID", "Id"}
	for _, pattern := range patterns {
		return pattern
	}
	return "PublicID"
}
