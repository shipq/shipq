= Cursor and Scope Implementation Plan

This document details the implementation plan for integrating cursor-based pagination
and scope filtering into shipq's autogenerated code.

== Overview

=== Goals

1. Add `scope` configuration to `shipq.ini` (global default with per-table override)
2. Add `order` configuration to `shipq.ini` (global default with per-table override)
3. Generate cursor encode/decode utilities using simple concatenation format
4. Warn users when tables lack `created_at` (falling back to offset pagination)
5. Add compiler tests for the new functionality

=== Non-Goals

- Forcing cursor pagination on tables without `created_at`
- Complex cursor encoding (base64/JSON) - simple format is sufficient
- HTTP handler generation (out of scope for now)

== Configuration Design

=== `shipq.ini` Schema

[source,ini]
----
[db]
url = postgres://localhost:5432/myapp
scope = organization_id    # Global default scope column
order = desc               # Global default order (desc = newest first)

[crud.users]
# Inherits scope = organization_id, order = desc

[crud.events]
order = asc                # Override: oldest first for event streams

[crud.audit_logs]
scope = tenant_id          # Override: different scope column
order = asc
----

=== Configuration Rules

1. `[db]` section defines global defaults
2. `[crud.<table_name>]` sections can override per table
3. If no scope is configured, no scope filtering is applied
4. If no order is configured, default is `desc` (newest first)
5. **Scope is only applied to tables that have the scope column** (column presence = opt-in)
6. New migrations auto-include the scope column when global scope is configured

=== Scope Application Logic

Global scope is **only applied** to tables that have the scope column:

|===
| Table | Has `organization_id` column? | Scope applied?

| `accounts` | No | No (global table)
| `organizations` | No | No (global table)
| `users` | Yes | Yes
| `posts` | Yes | Yes
|===

This is elegant because:
- **The migration is the source of truth** - adding the scope column = opting into scope
- **No state tracking needed** - just check if column exists
- **Predictable** - user sees the column in their migration
- **Safe by default** - can't accidentally scope a table without the column

== Auto-Injection of Scope Column

When a global scope is configured in `shipq.ini`, the `shipq migrate new` command
automatically adds the scope column to new migrations.

=== Extended Configuration

[source,ini]
----
[db]
scope = organization_id
scope_table = organizations  # Table that scope references (inferred if not set)
----

If `scope_table` isn't set, we infer it from the column name:

- `organization_id` → `organizations`
- `tenant_id` → `tenants`
- `user_id` → `users`

=== Auto-Generated Migration Template

When you run `shipq migrate new posts title:string`:

[source,go]
----
func Migrate_20240115_create_posts(plan *migrate.MigrationPlan) error {
    organizationsRef, err := plan.Table("organizations")
    if err != nil {
        return err
    }

    _, err = plan.AddTable("posts", func(tb *ddl.TableBuilder) error {
        // Auto-added: global scope from [db] scope = organization_id
        tb.Bigint("organization_id").NotNull().References(organizationsRef)

        // Your columns:
        tb.String("title")
        return nil
    })
    return err
}
----

=== Opting Out for Global Tables

Two ways to create a global (unscoped) table:

1. **CLI flag**: `shipq migrate new accounts --global`
2. **Delete the line**: Just remove the auto-generated scope column from the migration

=== Implementation in `migrate_generator.go`

The `MigrationConfig` struct will be extended:

[source,go]
----
type MigrationConfig struct {
    PackageName   string
    MigrationName string
    Timestamp     string
    Columns       []ColumnSpec
    ScopeColumn   string  // NEW: e.g., "organization_id"
    ScopeTable    string  // NEW: e.g., "organizations"
    IsGlobal      bool    // NEW: if true, skip scope injection
}
----

== Cursor Format Design

=== Why We Need Cursor Encoding

Keyset pagination requires two values to uniquely identify a position:

1. `created_at` - the timestamp (primary sort key)
2. `public_id` - tiebreaker (when multiple rows have same timestamp)

These must travel: server → HTTP response → client → HTTP request → server

=== Chosen Format: Base64-encoded JSON

[source]
----
eyJjIjoiMjAyNC0wMS0xNVQxMDozMDowMFoiLCJpIjoidXNyX2FiYzEyMyJ9
----

Decodes to:
[source,json]
----
{"c":"2024-01-15T10:30:00Z","i":"usr_abc123"}
----

==== Why This Format

- **Opaque to clients**: Clients can't/shouldn't construct cursors themselves - they just pass back what they received. This prevents clients from depending on cursor internals.
- **Extensible**: Easy to add more fields later (e.g., version, filter state) without breaking existing clients.
- **Industry standard**: Stripe, Slack, GitHub all use opaque base64 cursors.
- **Future-proof**: Can add HMAC signatures for tamper detection if needed later.

==== JSON Field Names

We use short field names to minimize cursor size:

- `c` = created_at (RFC3339 timestamp)
- `i` = public_id

==== Generated Utility Functions

[source,go]
----
// cursorData is the internal structure for cursor encoding.
type cursorData struct {
    C time.Time `json:"c"` // created_at
    I string    `json:"i"` // public_id
}

// EncodeCursor converts a cursor struct to a base64-encoded string.
func EncodeCursor(c *ListUsersCursor) string {
    if c == nil {
        return ""
    }
    data, err := json.Marshal(cursorData{C: c.CreatedAt, I: c.PublicID})
    if err != nil {
        return ""
    }
    return base64.RawURLEncoding.EncodeToString(data)
}

// DecodeCursor parses a base64-encoded cursor string.
// Returns nil if the cursor is empty or invalid.
func DecodeCursor(s string) *ListUsersCursor {
    if s == "" {
        return nil
    }
    data, err := base64.RawURLEncoding.DecodeString(s)
    if err != nil {
        return nil
    }
    var cd cursorData
    if err := json.Unmarshal(data, &cd); err != nil {
        return nil
    }
    return &ListUsersCursor{
        CreatedAt: cd.C,
        PublicID:  cd.I,
    }
}
----

==== Debugging Cursors

Since cursors are opaque, we can provide a CLI helper:

[source,bash]
----
$ shipq cursor decode eyJjIjoiMjAyNC0wMS0xNVQxMDozMDowMFoiLCJpIjoidXNyX2FiYzEyMyJ9
created_at: 2024-01-15T10:30:00Z
public_id:  usr_abc123
----

Or users can decode manually:

[source,bash]
----
$ echo 'eyJjIjoiMjAyNC0wMS0xNVQxMDozMDowMFoiLCJpIjoidXNyX2FiYzEyMyJ9' | base64 -d
{"c":"2024-01-15T10:30:00Z","i":"usr_abc123"}
----

== Implementation Tasks

=== Phase 1: Configuration Loading

==== Task 1.1: Extend INI Parsing for CRUD Sections

*File:* `codegen/dbpkg.go` (or new file `codegen/crud_config.go`)

Add functions to:

1. Parse `[db]` section for global `scope` and `order`
2. Parse `[crud.<table>]` sections for per-table overrides
3. Build `map[string]CRUDOptions` from configuration

[source,go]
----
type CRUDConfig struct {
    GlobalScope string           // From [db] scope
    GlobalOrder string           // From [db] order (asc/desc)
    TableOpts   map[string]CRUDOptions
}

func LoadCRUDConfig(ini *inifile.File, tables []string) (*CRUDConfig, error) {
    // 1. Read global defaults from [db]
    // 2. For each table, check for [crud.<table>] override
    // 3. Validate scope columns exist in tables
    // 4. Return merged configuration
}
----

==== Task 1.2: Validate Scope Columns

At codegen time, verify that configured scope columns actually exist in the table schema.

[source,go]
----
func validateScopeColumn(table ddl.Table, scopeColumn string) error {
    for _, col := range table.Columns {
        if col.Name == scopeColumn {
            return nil
        }
    }
    return fmt.Errorf("scope column %q not found in table %q", scopeColumn, table.Name)
}
----

=== Phase 2: Auto-Inject Scope in New Migrations

==== Task 2.1: Extend MigrationConfig

*File:* `cmd/shipq/migrate_generator.go`

[source,go]
----
type MigrationConfig struct {
    PackageName   string
    MigrationName string
    Timestamp     string
    Columns       []ColumnSpec
    ScopeColumn   string  // e.g., "organization_id" (empty = no scope)
    ScopeTable    string  // e.g., "organizations"
    IsGlobal      bool    // --global flag skips scope injection
}
----

==== Task 2.2: Update GenerateMigration

*File:* `cmd/shipq/migrate_generator.go`

Add scope column injection at the start of columns:

[source,go]
----
func GenerateMigration(cfg MigrationConfig) ([]byte, error) {
    // If scope is configured and not global, prepend scope column
    columns := cfg.Columns
    if cfg.ScopeColumn != "" && !cfg.IsGlobal {
        scopeCol := ColumnSpec{
            Name:       cfg.ScopeColumn,
            Type:       "references",
            References: cfg.ScopeTable,
        }
        columns = append([]ColumnSpec{scopeCol}, columns...)
    }

    // ... rest of generation using columns
}
----

==== Task 2.3: Update migrateNewCmd

*File:* `cmd/shipq/migrate_new.go`

Load scope config and pass to generator:

[source,go]
----
func migrateNewCmd(args []string) {
    // ... existing arg parsing ...

    // Check for --global flag
    isGlobal := hasFlag(args, "--global")

    // Load scope config from shipq.ini
    scopeColumn, scopeTable := loadScopeConfig(cfg)

    migrationCfg := MigrationConfig{
        PackageName:   "migrations",
        MigrationName: migrationName,
        Timestamp:     timestamp,
        Columns:       columns,
        ScopeColumn:   scopeColumn,
        ScopeTable:    scopeTable,
        IsGlobal:      isGlobal,
    }
    // ...
}

func loadScopeConfig(cfg *ProjectConfig) (column, table string) {
    ini, err := inifile.ParseFile(filepath.Join(cfg.ProjectRoot, "shipq.ini"))
    if err != nil {
        return "", ""
    }
    column = ini.Get("db", "scope")
    if column == "" {
        return "", ""
    }
    table = ini.Get("db", "scope_table")
    if table == "" {
        // Infer from column name: organization_id -> organizations
        table = inferScopeTable(column)
    }
    return column, table
}

func inferScopeTable(column string) string {
    // organization_id -> organizations
    // tenant_id -> tenants
    // user_id -> users
    if strings.HasSuffix(column, "_id") {
        singular := strings.TrimSuffix(column, "_id")
        return toPlural(singular)
    }
    return column + "s"
}
----

=== Phase 3: Warning for Missing Cursor Support

==== Task 2.1: Add Warning During Codegen

When generating CRUD code, warn if a table lacks `created_at` or `public_id`:

[source,go]
----
func checkCursorSupport(table ddl.Table) {
    analysis := AnalyzeTable(table)
    if !analysis.HasCreatedAt || !analysis.HasPublicID {
        var missing []string
        if !analysis.HasCreatedAt {
            missing = append(missing, "created_at")
        }
        if !analysis.HasPublicID {
            missing = append(missing, "public_id")
        }
        fmt.Fprintf(os.Stderr,
            "shipq: warning: table %q lacks %s - using offset pagination (cursor pagination requires both)\n",
            table.Name, strings.Join(missing, " and "))
    }
}
----

=== Phase 4: Generate Cursor Utilities

==== Task 3.1: Generate Per-Table Cursor Functions

Add to `queries_gen.go` or new file `cursor_gen.go`:

[source,go]
----
func GenerateCursorUtils(table ddl.Table, analysis TableAnalysis) string {
    if !analysis.HasCreatedAt || !analysis.HasPublicID {
        return "" // No cursor utils for offset-based tables
    }

    plural := toPascalCase(table.Name)

    return fmt.Sprintf(`
// %sCursorData is the internal structure for cursor encoding.
type %sCursorData struct {
    C time.Time ` + "`json:\"c\"`" + ` // created_at
    I string    ` + "`json:\"i\"`" + ` // public_id
}

// Encode%sCursor converts a cursor struct to a base64-encoded string.
func Encode%sCursor(c *List%sCursor) string {
    if c == nil {
        return ""
    }
    data, err := json.Marshal(%sCursorData{C: c.CreatedAt, I: c.PublicID})
    if err != nil {
        return ""
    }
    return base64.RawURLEncoding.EncodeToString(data)
}

// Decode%sCursor parses a base64-encoded cursor string. Returns nil if invalid.
func Decode%sCursor(s string) *List%sCursor {
    if s == "" {
        return nil
    }
    data, err := base64.RawURLEncoding.DecodeString(s)
    if err != nil {
        return nil
    }
    var cd %sCursorData
    if err := json.Unmarshal(data, &cd); err != nil {
        return nil
    }
    return &List%sCursor{
        CreatedAt: cd.C,
        PublicID:  cd.I,
    }
}
`, plural, plural, plural, plural, plural, plural, plural, plural, plural, plural, plural)
}
----

==== Task 3.2: Add Imports for Cursor Utils

The generated cursor utilities need:
- `encoding/base64`
- `encoding/json`
- `time`

Ensure these are included in the imports when cursor utils are generated.

=== Phase 5: Integration into Codegen Pipeline

==== Task 4.1: Update `LoadDBPackageConfig`

Extend to also load CRUD configuration:

[source,go]
----
type DBPackageConfig struct {
    ProjectRoot string
    ModulePath  string
    DatabaseURL string
    Dialect     string
    CRUDConfig  *CRUDConfig  // NEW
}
----

==== Task 4.2: Update Runner Generation

Ensure `GenerateUnifiedRunner` and `GenerateDialectRunner` receive the loaded `CRUDOptions` from config:

[source,go]
----
// In compile command flow:
cfg, _ := LoadDBPackageConfig(projectRoot)
tableOpts := cfg.CRUDConfig.TableOpts

// Pass to runner generation
code, _ := GenerateUnifiedRunner(UnifiedRunnerConfig{
    // ...
    TableOpts: tableOpts,
})
----

==== Task 4.3: Update Types Generation

Add cursor utilities to `GenerateSharedTypes`:

[source,go]
----
func GenerateSharedTypes(cfg UnifiedRunnerConfig) ([]byte, error) {
    // ... existing code ...

    // After writing CRUD types, write cursor utilities
    for tableName, table := range cfg.Schema.Tables {
        analysis := AnalyzeTable(table)
        if analysis.HasCreatedAt && analysis.HasPublicID {
            buf.WriteString(GenerateCursorUtils(table, analysis))
        }
    }

    // ...
}
----

=== Phase 6: Tests

==== Task 6.1: Config Loading Tests

*File:* `codegen/crud_config_test.go`

[source,go]
----
func TestLoadCRUDConfig_GlobalDefaults(t *testing.T) {
    ini := parseINI(`
[db]
scope = organization_id
order = desc
`)
    cfg, err := LoadCRUDConfig(ini, []string{"users", "posts"})
    // Assert all tables inherit global scope and order
}

func TestLoadCRUDConfig_PerTableOverride(t *testing.T) {
    ini := parseINI(`
[db]
scope = organization_id

[crud.events]
order = asc
`)
    cfg, err := LoadCRUDConfig(ini, []string{"users", "events"})
    // Assert users has desc, events has asc
}

func TestLoadCRUDConfig_InvalidScopeColumn(t *testing.T) {
    // Test that validation catches non-existent scope columns
}
----

==== Task 6.2: Migration Scope Injection Tests

*File:* `cmd/shipq/migrate_generator_test.go`

[source,go]
----
func TestGenerateMigration_WithScopeColumn(t *testing.T) {
    cfg := MigrationConfig{
        PackageName:   "migrations",
        MigrationName: "posts",
        Timestamp:     "20240115120000",
        Columns:       []ColumnSpec{{Name: "title", Type: "string"}},
        ScopeColumn:   "organization_id",
        ScopeTable:    "organizations",
    }

    code, err := GenerateMigration(cfg)
    // Assert code contains organization_id reference
    // Assert code contains organizationsRef lookup
}

func TestGenerateMigration_GlobalFlag_NoScope(t *testing.T) {
    cfg := MigrationConfig{
        PackageName:   "migrations",
        MigrationName: "accounts",
        Timestamp:     "20240115120000",
        Columns:       []ColumnSpec{{Name: "name", Type: "string"}},
        ScopeColumn:   "organization_id",
        ScopeTable:    "organizations",
        IsGlobal:      true,  // --global flag
    }

    code, err := GenerateMigration(cfg)
    // Assert code does NOT contain organization_id
}

func TestInferScopeTable(t *testing.T) {
    tests := []struct{
        column, expected string
    }{
        {"organization_id", "organizations"},
        {"tenant_id", "tenants"},
        {"user_id", "users"},
    }
    for _, tt := range tests {
        got := inferScopeTable(tt.column)
        if got != tt.expected {
            t.Errorf("inferScopeTable(%q) = %q, want %q", tt.column, got, tt.expected)
        }
    }
}
----

==== Task 6.3: Cursor Encoding Tests

*File:* `codegen/queries_gen_test.go` (extend existing)

[source,go]
----
func TestGenerateCursorUtils_EncodeDecode(t *testing.T) {
    // Generate cursor utils for a table
    // Compile the generated code
    // Verify encode/decode round-trips correctly
}

func TestGenerateCursorUtils_DecodeInvalidInput(t *testing.T) {
    // Empty string → nil
    // No underscore → nil
    // Invalid timestamp → nil
}

func TestGenerateCursorUtils_OnlyForCursorTables(t *testing.T) {
    // Tables without created_at should NOT get cursor utils
}
----

==== Task 6.4: SQL Generation with Config

Extend existing tests in `crud_sql_gen_test.go`:

[source,go]
----
func TestGenerateCRUDSQL_WithConfiguredScope(t *testing.T) {
    // Test that scope from config is applied to SQL
}

func TestGenerateCRUDSQL_WithConfiguredOrderAsc(t *testing.T) {
    // Test ORDER BY ASC when configured
}
----

==== Task 6.5: Scope Column Detection Tests

[source,go]
----
func TestScopeOnlyAppliedWhenColumnExists(t *testing.T) {
    // Table WITH organization_id column -> scope applied
    // Table WITHOUT organization_id column -> no scope (global table)
}
----

==== Task 6.6: Warning Output Test

[source,go]
----
func TestCursorSupportWarning(t *testing.T) {
    // Capture stderr
    // Generate for table without created_at
    // Assert warning was printed
}
----

== File Changes Summary

=== New Files

1. `codegen/crud_config.go` - Configuration loading for CRUD options
2. `codegen/crud_config_test.go` - Tests for configuration loading
3. `codegen/scope_utils.go` - Scope table inference utilities

=== Modified Files

1. `inifile/parse.go` - No changes needed (already supports sectioned config)
2. `codegen/dbpkg.go` - Extend `DBPackageConfig` to include `CRUDConfig`
3. `codegen/unified_runner.go` - Use config-loaded `TableOpts`
4. `db/portsql/codegen/queries_gen.go` - Add `GenerateCursorUtils` function, add scope detection
5. `db/portsql/codegen/queries_gen_test.go` - Add cursor utility tests
6. `db/portsql/codegen/crud_sql_gen_test.go` - Add config-based tests
7. `cmd/shipq/migrate_generator.go` - Add scope injection to migration generation
8. `cmd/shipq/migrate_new.go` - Load scope config, add `--global` flag
9. `cmd/shipq/migrate_generator_test.go` - Tests for scope injection

== Example: End-to-End Flow

=== Input: `shipq.ini`

[source,ini]
----
[db]
url = postgres://localhost:5432/myapp
scope = org_id
order = desc

[crud.audit_logs]
order = asc
----

=== Input: Migration

[source,go]
----
plan.AddTable("users", func(tb *ddl.TableBuilder) error {
    tb.Bigint("org_id")
    tb.String("name")
    return nil
})
----

=== Generated: `queries/types.go`

[source,go]
----
// ListUsersCursor represents a pagination cursor.
type ListUsersCursor struct {
    CreatedAt time.Time
    PublicID  string
}

// ListUsersParams contains parameters for listing users.
type ListUsersParams struct {
    OrgId         int64  // From scope config
    Limit         int
    Cursor        *ListUsersCursor
    CreatedAfter  *time.Time
    CreatedBefore *time.Time
}

// UsersCursorData is the internal structure for cursor encoding.
type UsersCursorData struct {
    C time.Time `json:"c"` // created_at
    I string    `json:"i"` // public_id
}

// EncodeUsersCursor converts a cursor struct to a base64-encoded string.
func EncodeUsersCursor(c *ListUsersCursor) string {
    if c == nil {
        return ""
    }
    data, _ := json.Marshal(UsersCursorData{C: c.CreatedAt, I: c.PublicID})
    return base64.RawURLEncoding.EncodeToString(data)
}

// DecodeUsersCursor parses a base64-encoded cursor string. Returns nil if invalid.
func DecodeUsersCursor(s string) *ListUsersCursor {
    if s == "" {
        return nil
    }
    data, err := base64.RawURLEncoding.DecodeString(s)
    if err != nil {
        return nil
    }
    var cd UsersCursorData
    if err := json.Unmarshal(data, &cd); err != nil {
        return nil
    }
    return &ListUsersCursor{
        CreatedAt: cd.C,
        PublicID:  cd.I,
    }
}
----

=== Generated: `queries/postgres/runner.go`

[source,go]
----
func (r *QueryRunner) ListUsers(ctx context.Context, params queries.ListUsersParams) (*queries.ListUsersResult, error) {
    sql := r.listUsersSQL
    args := []any{params.OrgId}  // Scope column first

    // ... cursor and filter logic ...
}
----

== Testing Checklist

- [ ] Config loading with global defaults
- [ ] Config loading with per-table overrides
- [ ] Scope column validation (must exist in table)
- [ ] Cursor encode/decode round-trip
- [ ] Cursor decode with invalid input
- [ ] SQL generation with configured scope
- [ ] SQL generation with configured order (asc/desc)
- [ ] Warning for tables without cursor support
- [ ] No cursor utils for offset-based tables
- [ ] Integration: full compile with config

== Open Questions (Resolved)

1. **Cursor format?** → Base64-encoded JSON with short field names (`c`, `i`)
2. **Base64 needed?** → Yes, for opacity, extensibility, and industry-standard practice
3. **Config structure?** → Global defaults in `[db]`, overrides in `[crud.<table>]`
4. **Missing created_at?** → Warn, fall back to offset pagination
5. **Scope for existing tables?** → Only apply if table has the scope column (column presence = opt-in)
6. **New tables with global scope?** → Auto-inject scope column in migrations, use `--global` flag to opt out
