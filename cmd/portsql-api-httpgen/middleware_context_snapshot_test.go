package main

import (
	"strings"
	"testing"
)

// TestMiddlewareContextGeneration_Snapshot is a golden/snapshot test that freezes the exact output format.
// This test documents the stable contract and catches any unintended changes to the generation logic.
func TestMiddlewareContextGeneration_Snapshot(t *testing.T) {
	keys := []ManifestContextKey{
		{Key: "request_id", Type: "string"},
		{Key: "user_id", Type: "int64"},
		{Key: "current_user", Type: "*User"},
		{Key: "api_key", Type: "string"},
	}

	// Generate the context file
	code, err := generateMiddlewareContextFile("middleware", keys)
	if err != nil {
		t.Fatalf("generateMiddlewareContextFile failed: %v", err)
	}

	// The expected output is deterministic and stable
	expected := `// Code generated by portsql-api-httpgen. DO NOT EDIT.

package middleware

import "context"

// zzCtxKeyAPIKey is the unexported key type for APIKey.
type zzCtxKeyAPIKey struct{}

// WithAPIKey returns a new context with the given value stored.
func WithAPIKey(ctx context.Context, v string) context.Context {
	return context.WithValue(ctx, zzCtxKeyAPIKey{}, v)
}

// APIKey retrieves the value from the context.
// Returns (value, true) if present, or (zero, false) if not present.
func APIKey(ctx context.Context) (string, bool) {
	v, ok := ctx.Value(zzCtxKeyAPIKey{}).(string)
	return v, ok
}

// MustAPIKey retrieves the value from the context.
// Panics if the value is not present.
func MustAPIKey(ctx context.Context) string {
	v, ok := APIKey(ctx)
	if !ok {
		panic("context key APIKey not found")
	}
	return v
}

// zzCtxKeyCurrentUser is the unexported key type for CurrentUser.
type zzCtxKeyCurrentUser struct{}

// WithCurrentUser returns a new context with the given value stored.
func WithCurrentUser(ctx context.Context, v *User) context.Context {
	return context.WithValue(ctx, zzCtxKeyCurrentUser{}, v)
}

// CurrentUser retrieves the value from the context.
// Returns (value, true) if present, or (zero, false) if not present.
func CurrentUser(ctx context.Context) (*User, bool) {
	v, ok := ctx.Value(zzCtxKeyCurrentUser{}).(*User)
	return v, ok
}

// MustCurrentUser retrieves the value from the context.
// Panics if the value is not present.
func MustCurrentUser(ctx context.Context) *User {
	v, ok := CurrentUser(ctx)
	if !ok {
		panic("context key CurrentUser not found")
	}
	return v
}

// zzCtxKeyRequestID is the unexported key type for RequestID.
type zzCtxKeyRequestID struct{}

// WithRequestID returns a new context with the given value stored.
func WithRequestID(ctx context.Context, v string) context.Context {
	return context.WithValue(ctx, zzCtxKeyRequestID{}, v)
}

// RequestID retrieves the value from the context.
// Returns (value, true) if present, or (zero, false) if not present.
func RequestID(ctx context.Context) (string, bool) {
	v, ok := ctx.Value(zzCtxKeyRequestID{}).(string)
	return v, ok
}

// MustRequestID retrieves the value from the context.
// Panics if the value is not present.
func MustRequestID(ctx context.Context) string {
	v, ok := RequestID(ctx)
	if !ok {
		panic("context key RequestID not found")
	}
	return v
}

// zzCtxKeyUserID is the unexported key type for UserID.
type zzCtxKeyUserID struct{}

// WithUserID returns a new context with the given value stored.
func WithUserID(ctx context.Context, v int64) context.Context {
	return context.WithValue(ctx, zzCtxKeyUserID{}, v)
}

// UserID retrieves the value from the context.
// Returns (value, true) if present, or (zero, false) if not present.
func UserID(ctx context.Context) (int64, bool) {
	v, ok := ctx.Value(zzCtxKeyUserID{}).(int64)
	return v, ok
}

// MustUserID retrieves the value from the context.
// Panics if the value is not present.
func MustUserID(ctx context.Context) int64 {
	v, ok := UserID(ctx)
	if !ok {
		panic("context key UserID not found")
	}
	return v
}
`

	if code != expected {
		t.Errorf("Generated code does not match expected snapshot.\n\nExpected:\n%s\n\nGot:\n%s", expected, code)

		// Show a diff-like output for easier debugging
		expectedLines := strings.Split(expected, "\n")
		gotLines := strings.Split(code, "\n")

		maxLines := len(expectedLines)
		if len(gotLines) > maxLines {
			maxLines = len(gotLines)
		}

		for i := 0; i < maxLines; i++ {
			var expLine, gotLine string
			if i < len(expectedLines) {
				expLine = expectedLines[i]
			}
			if i < len(gotLines) {
				gotLine = gotLines[i]
			}

			if expLine != gotLine {
				t.Logf("Line %d differs:", i+1)
				t.Logf("  Expected: %q", expLine)
				t.Logf("  Got:      %q", gotLine)
			}
		}
	}
}

// TestMiddlewareContextGeneration_SnapshotWithPackageQualifiedTypes tests that
// types with package qualifiers are handled correctly.
func TestMiddlewareContextGeneration_SnapshotWithPackageQualifiedTypes(t *testing.T) {
	keys := []ManifestContextKey{
		{Key: "db_conn", Type: "*sql.DB"},
		{Key: "logger", Type: "*slog.Logger"},
	}

	// Generate the context file
	code, err := generateMiddlewareContextFile("middleware", keys)
	if err != nil {
		t.Fatalf("generateMiddlewareContextFile failed: %v", err)
	}

	// Types from external packages should keep their package qualifier
	expectedContains := []string{
		"func WithDbConn(ctx context.Context, v *sql.DB) context.Context",
		"func DbConn(ctx context.Context) (*sql.DB, bool)",
		"v, ok := ctx.Value(zzCtxKeyDbConn{}).(*sql.DB)",
		"func WithLogger(ctx context.Context, v *slog.Logger) context.Context",
		"func Logger(ctx context.Context) (*slog.Logger, bool)",
		"v, ok := ctx.Value(zzCtxKeyLogger{}).(*slog.Logger)",
	}

	for _, expected := range expectedContains {
		if !strings.Contains(code, expected) {
			t.Errorf("Generated code missing expected content:\n%s\n\nGenerated code:\n%s", expected, code)
		}
	}
}

// TestMiddlewareContextGeneration_InitialismHandling verifies that common initialisms
// are properly uppercased in generated function names.
func TestMiddlewareContextGeneration_InitialismHandling(t *testing.T) {
	tests := []struct {
		key              string
		expectedKeyType  string
		expectedWithFunc string
		expectedGetFunc  string
		expectedMustFunc string
	}{
		{
			key:              "api_key",
			expectedKeyType:  "type zzCtxKeyAPIKey struct{}",
			expectedWithFunc: "func WithAPIKey(ctx context.Context, v string) context.Context",
			expectedGetFunc:  "func APIKey(ctx context.Context) (string, bool)",
			expectedMustFunc: "func MustAPIKey(ctx context.Context) string",
		},
		{
			key:              "user_id",
			expectedKeyType:  "type zzCtxKeyUserID struct{}",
			expectedWithFunc: "func WithUserID(ctx context.Context, v string) context.Context",
			expectedGetFunc:  "func UserID(ctx context.Context) (string, bool)",
			expectedMustFunc: "func MustUserID(ctx context.Context) string",
		},
		{
			key:              "http_client",
			expectedKeyType:  "type zzCtxKeyHTTPClient struct{}",
			expectedWithFunc: "func WithHTTPClient(ctx context.Context, v string) context.Context",
			expectedGetFunc:  "func HTTPClient(ctx context.Context) (string, bool)",
			expectedMustFunc: "func MustHTTPClient(ctx context.Context) string",
		},
		{
			key:              "json_data",
			expectedKeyType:  "type zzCtxKeyJSONData struct{}",
			expectedWithFunc: "func WithJSONData(ctx context.Context, v string) context.Context",
			expectedGetFunc:  "func JSONData(ctx context.Context) (string, bool)",
			expectedMustFunc: "func MustJSONData(ctx context.Context) string",
		},
	}

	for _, tt := range tests {
		t.Run(tt.key, func(t *testing.T) {
			keys := []ManifestContextKey{
				{Key: tt.key, Type: "string"},
			}

			code, err := generateMiddlewareContextFile("middleware", keys)
			if err != nil {
				t.Fatalf("generateMiddlewareContextFile failed: %v", err)
			}

			expectedParts := []string{
				tt.expectedKeyType,
				tt.expectedWithFunc,
				tt.expectedGetFunc,
				tt.expectedMustFunc,
			}

			for _, expected := range expectedParts {
				if !strings.Contains(code, expected) {
					t.Errorf("Generated code missing expected content:\n%s\n\nGenerated code:\n%s", expected, code)
				}
			}
		})
	}
}
