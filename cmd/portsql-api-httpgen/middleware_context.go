package main

import (
	"bytes"
	"fmt"
	"go/format"
	"regexp"
	"sort"
	"strings"
	"text/template"
)

// GeneratorError represents an error during code generation with a stable error code.
type GeneratorError struct {
	Code    string
	Message string
}

func (e *GeneratorError) Error() string {
	return fmt.Sprintf("[%s] %s", e.Code, e.Message)
}

var contextKeyPattern = regexp.MustCompile(`^[a-z][a-z0-9_]*$`)

// Common initialisms that should be uppercased
var initialisms = map[string]bool{
	"id":    true,
	"url":   true,
	"http":  true,
	"https": true,
	"ip":    true,
	"api":   true,
	"html":  true,
	"json":  true,
	"xml":   true,
	"sql":   true,
	"css":   true,
	"uri":   true,
	"uuid":  true,
	"tcp":   true,
	"udp":   true,
	"tls":   true,
	"ssl":   true,
	"rpc":   true,
	"grpc":  true,
	"ascii": true,
	"utf":   true,
}

// contextKeyToCamelCase converts a snake_case context key to CamelCase.
// It handles common initialisms (id -> ID, url -> URL, etc.).
func contextKeyToCamelCase(key string) (string, error) {
	// Validate format
	if key == "" {
		return "", &GeneratorError{
			Code:    "invalid_context_key",
			Message: "context key cannot be empty",
		}
	}

	if !contextKeyPattern.MatchString(key) {
		return "", &GeneratorError{
			Code:    "invalid_context_key",
			Message: fmt.Sprintf("context key %q must match pattern [a-z][a-z0-9_]*", key),
		}
	}

	// Check for empty segments (e.g., "user__id" or "user_")
	if strings.Contains(key, "__") {
		return "", &GeneratorError{
			Code:    "invalid_context_key",
			Message: fmt.Sprintf("context key %q cannot contain consecutive underscores", key),
		}
	}

	if strings.HasSuffix(key, "_") {
		return "", &GeneratorError{
			Code:    "invalid_context_key",
			Message: fmt.Sprintf("context key %q cannot end with underscore", key),
		}
	}

	// Split on underscore
	segments := strings.Split(key, "_")
	var result strings.Builder

	for _, seg := range segments {
		if seg == "" {
			return "", &GeneratorError{
				Code:    "invalid_context_key",
				Message: fmt.Sprintf("context key %q has empty segment", key),
			}
		}

		// Check if this segment is a common initialism
		if initialisms[seg] {
			result.WriteString(strings.ToUpper(seg))
		} else {
			// Title case: uppercase first letter, keep rest lowercase
			result.WriteString(strings.ToUpper(seg[:1]))
			result.WriteString(seg[1:])
		}
	}

	return result.String(), nil
}

// detectContextKeyCollisions checks if any keys map to the same CamelCase identifier.
func detectContextKeyCollisions(keys []ManifestContextKey) error {
	nameToKey := make(map[string]string)

	for _, key := range keys {
		camelCase, err := contextKeyToCamelCase(key.Key)
		if err != nil {
			return err
		}

		if existingKey, exists := nameToKey[camelCase]; exists {
			return &GeneratorError{
				Code:    "context_key_name_collision",
				Message: fmt.Sprintf("context keys %q and %q both map to identifier %q", existingKey, key.Key, camelCase),
			}
		}

		nameToKey[camelCase] = key.Key
	}

	return nil
}

// contextHelperData holds data for generating a single context helper.
type contextHelperData struct {
	KeyName      string // e.g., "request_id" (the original snake_case key)
	CamelName    string // e.g., "User"
	GoType       string // e.g., "*User" or "string"
	WithFuncName string // e.g., "WithUser"
	GetFuncName  string // e.g., "User"
	MustFuncName string // e.g., "MustUser"
}

var contextFileTmpl = template.Must(template.New("contextFile").Parse(`// Code generated by portsql-api-httpgen. DO NOT EDIT.

package {{.PackageName}}

import (
	"context"

	"github.com/shipq/shipq/api/portapi"
)

{{range .Helpers}}
// {{.WithFuncName}} returns a new context with the given value stored.
// Uses the stable portapi context store for interoperability with capability tokens.
func {{.WithFuncName}}(ctx context.Context, v {{.GoType}}) context.Context {
	return portapi.WithTyped(ctx, "{{.KeyName}}", v)
}

// {{.GetFuncName}} retrieves the value from the context.
// Returns (value, true) if present, or (zero, false) if not present.
// Uses the stable portapi context store for interoperability with capability tokens.
func {{.GetFuncName}}(ctx context.Context) ({{.GoType}}, bool) {
	return portapi.GetTyped[{{.GoType}}](ctx, "{{.KeyName}}")
}

// {{.MustFuncName}} retrieves the value from the context.
// Panics if the value is not present.
// Uses the stable portapi context store for interoperability with capability tokens.
func {{.MustFuncName}}(ctx context.Context) {{.GoType}} {
	return portapi.MustTyped[{{.GoType}}](ctx, "{{.KeyName}}")
}

{{end}}
`))

type contextFileTemplateData struct {
	PackageName string
	Helpers     []contextHelperData
}

// stripPackagePrefix removes the package prefix from a type string if it matches the target package.
// For example, "*middleware.User" becomes "*User" when targetPkg is "middleware".
func stripPackagePrefix(typeStr, targetPkg string) string {
	// Handle pointer types
	if strings.HasPrefix(typeStr, "*") {
		rest := stripPackagePrefix(typeStr[1:], targetPkg)
		return "*" + rest
	}

	// Handle slice types
	if strings.HasPrefix(typeStr, "[]") {
		rest := stripPackagePrefix(typeStr[2:], targetPkg)
		return "[]" + rest
	}

	// Handle map types
	if strings.HasPrefix(typeStr, "map[") {
		// For maps, we need to be careful - just strip the value type package
		// This is a simplified version; a full implementation would parse the map properly
		return typeStr
	}

	// Check if type has package prefix
	prefix := targetPkg + "."
	if strings.HasPrefix(typeStr, prefix) {
		return typeStr[len(prefix):]
	}

	return typeStr
}

// generateMiddlewareContextFile generates the content of zz_generated_middleware_context.go.
// Returns empty string if there are no context keys.
func generateMiddlewareContextFile(pkgName string, contextKeys []ManifestContextKey) (string, error) {
	if len(contextKeys) == 0 {
		return "", nil
	}

	// Sort keys deterministically by key name
	keys := make([]ManifestContextKey, len(contextKeys))
	copy(keys, contextKeys)
	sort.Slice(keys, func(i, j int) bool {
		return keys[i].Key < keys[j].Key
	})

	// Check for collisions
	if err := detectContextKeyCollisions(keys); err != nil {
		return "", err
	}

	// Build helper data for each key
	var helpers []contextHelperData
	for _, key := range keys {
		camelName, err := contextKeyToCamelCase(key.Key)
		if err != nil {
			return "", err
		}

		if key.Type == "" {
			return "", &GeneratorError{
				Code:    "invalid_context_type",
				Message: fmt.Sprintf("context key %q has empty type", key.Key),
			}
		}

		// Strip package prefix if the type is from the same package we're generating into
		goType := stripPackagePrefix(key.Type, pkgName)

		helper := contextHelperData{
			KeyName:      key.Key,
			CamelName:    camelName,
			GoType:       goType,
			WithFuncName: "With" + camelName,
			GetFuncName:  camelName,
			MustFuncName: "Must" + camelName,
		}

		helpers = append(helpers, helper)
	}

	// Execute template
	data := contextFileTemplateData{
		PackageName: pkgName,
		Helpers:     helpers,
	}

	var buf bytes.Buffer
	if err := contextFileTmpl.Execute(&buf, data); err != nil {
		return "", &GeneratorError{
			Code:    "context_helper_generation_failed",
			Message: fmt.Sprintf("template execution failed: %v", err),
		}
	}

	// Format with gofmt
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return "", &GeneratorError{
			Code:    "context_helper_generation_failed",
			Message: fmt.Sprintf("gofmt failed: %v", err),
		}
	}

	return string(formatted), nil
}
