package main

import (
	"bytes"
	"fmt"
	"go/format"
	"path"
	"sort"
	"strings"
	"text/template"
)

// wrapperInfo maps handler shapes to their runtime wrapper functions.
var wrapperInfo = map[string]string{
	"ctx_req_resp_err": "WrapCtxReqRespErr",
	"ctx_req_err":      "WrapCtxReqErr",
	"ctx_resp_err":     "WrapCtxRespErr",
	"ctx_err":          "WrapCtxErr",
}

// templateData holds data for the code generation template.
type templateData struct {
	Package       string
	RuntimeImport string
	Imports       []string
	Endpoints     []templateEndpoint
}

// templateEndpoint holds data for a single endpoint in the template.
type templateEndpoint struct {
	Pattern     string // e.g., "GET /pets"
	WrapperFunc string // e.g., "WrapCtxReqRespErr"
	HandlerRef  string // e.g., "pets.List" or full qualified reference
	Shape       string // original shape for generic instantiation
	ReqType     string // request type for generics (if needed)
	RespType    string // response type for generics (if needed)
}

var tmpl = template.Must(template.New("mux").Parse(`// Code generated by portsql-api-httpgen. DO NOT EDIT.

package {{.Package}}

import (
	"net/http"
{{range .Imports}}
	{{.}}
{{end}}
	"{{.RuntimeImport}}"
)

func NewMux() *http.ServeMux {
	mux := http.NewServeMux()
{{range .Endpoints}}
	mux.Handle("{{.Pattern}}", {{.WrapperFunc}})
{{end}}
	return mux
}
`))

// Generate produces Go source code that creates an http.ServeMux with all
// registered endpoints from the manifest.
func Generate(m Manifest, pkgName string) (string, error) {
	// 1. Sort endpoints for determinism (by path, method, handler pkg, handler name, shape)
	endpoints := make([]ManifestEndpoint, len(m.Endpoints))
	copy(endpoints, m.Endpoints)
	sort.Slice(endpoints, func(i, j int) bool {
		if endpoints[i].Path != endpoints[j].Path {
			return endpoints[i].Path < endpoints[j].Path
		}
		if endpoints[i].Method != endpoints[j].Method {
			return endpoints[i].Method < endpoints[j].Method
		}
		if endpoints[i].HandlerPkg != endpoints[j].HandlerPkg {
			return endpoints[i].HandlerPkg < endpoints[j].HandlerPkg
		}
		if endpoints[i].HandlerName != endpoints[j].HandlerName {
			return endpoints[i].HandlerName < endpoints[j].HandlerName
		}
		if endpoints[i].Shape != endpoints[j].Shape {
			return endpoints[i].Shape < endpoints[j].Shape
		}
		if endpoints[i].ReqType != endpoints[j].ReqType {
			return endpoints[i].ReqType < endpoints[j].ReqType
		}
		return endpoints[i].RespType < endpoints[j].RespType
	})

	// 2. Collect unique imports
	importSet := make(map[string]string) // import path -> alias
	for _, ep := range endpoints {
		if ep.HandlerPkg != "" {
			alias := path.Base(ep.HandlerPkg)
			importSet[ep.HandlerPkg] = alias
		}
	}

	// Build sorted import list for determinism
	var importPaths []string
	for p := range importSet {
		importPaths = append(importPaths, p)
	}
	sort.Strings(importPaths)

	var imports []string
	for _, p := range importPaths {
		alias := importSet[p]
		imports = append(imports, fmt.Sprintf("%s %q", alias, p))
	}

	// 3. Build template endpoints
	var tmplEndpoints []templateEndpoint
	for _, ep := range endpoints {
		pattern := ep.Method + " " + ep.Path
		wrapper := buildWrapperCall(ep, importSet)

		tmplEndpoints = append(tmplEndpoints, templateEndpoint{
			Pattern:     pattern,
			WrapperFunc: wrapper,
			Shape:       ep.Shape,
			ReqType:     ep.ReqType,
			RespType:    ep.RespType,
		})
	}

	// 4. Execute template
	data := templateData{
		Package:       pkgName,
		RuntimeImport: "github.com/shipq/shipq/api/portapi/runtime",
		Imports:       imports,
		Endpoints:     tmplEndpoints,
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("template execution failed: %w", err)
	}

	// 5. Run gofmt
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted code with error for debugging
		return buf.String(), fmt.Errorf("gofmt failed: %w", err)
	}

	return string(formatted), nil
}

// buildWrapperCall constructs the wrapper function call string for an endpoint.
func buildWrapperCall(ep ManifestEndpoint, importSet map[string]string) string {
	wrapperName := wrapperInfo[ep.Shape]
	if wrapperName == "" {
		wrapperName = "WrapCtxErr" // fallback
	}

	// Build the handler reference
	alias := importSet[ep.HandlerPkg]
	handlerRef := alias + "." + ep.HandlerName

	// Build wrapper call based on shape
	switch ep.Shape {
	case "ctx_req_resp_err":
		// Generic wrapper: runtime.WrapCtxReqRespErr[Req, Resp](handler)
		return fmt.Sprintf("runtime.%s[%s, %s](%s)", wrapperName, ep.ReqType, ep.RespType, handlerRef)
	case "ctx_req_err":
		// Generic wrapper: runtime.WrapCtxReqErr[Req](handler)
		return fmt.Sprintf("runtime.%s[%s](%s)", wrapperName, ep.ReqType, handlerRef)
	case "ctx_resp_err":
		// Generic wrapper: runtime.WrapCtxRespErr[Resp](handler)
		return fmt.Sprintf("runtime.%s[%s](%s)", wrapperName, ep.RespType, handlerRef)
	case "ctx_err":
		// Non-generic wrapper: runtime.WrapCtxErr(handler)
		return fmt.Sprintf("runtime.%s(%s)", wrapperName, handlerRef)
	default:
		return fmt.Sprintf("runtime.%s(%s)", wrapperName, handlerRef)
	}
}

// normalizeTypeName ensures a type name is valid for use in generated code.
// It handles pointer types, package-qualified types, etc.
func normalizeTypeName(typeName string) string {
	// Remove any leading asterisk for pointer types
	typeName = strings.TrimPrefix(typeName, "*")
	return typeName
}
