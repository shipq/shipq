= API Design Specification (MVP)

This document defines a **small, reliable MVP** for a PortSQL-style API system in Go.

The MVP goal is intentionally narrow:

- You write **pure Go handler functions** with request/response types.
- You wire them up with `Register(app)` using a small registry API (`app.Get`, `app.Post`, …).
- A build-time compiler step **executes registration code**, discovers endpoints, and **generates a standard-library `net/http` server** (using `http.ServeMux`).

Everything else (OpenAPI, middleware, clients, CRUD synthesis) is future work and is only noted as extension points.

== Goals (MVP)

- **Pure handlers**: domain handlers do not import/know about `net/http`.
- **Routing from code**: method/path come from `Register(app)` calls (not comments).
- **Stdlib router**: generated server uses `net/http` `ServeMux` patterns.
- **Deterministic codegen**: stable output for the same inputs.
- **Works package-by-package**: independent packages can define endpoints and export `Register`.

== Non-goals (MVP)

- OpenAPI/Swagger emission
- Middleware (auth/logging/tracing)
- Typed test client generation
- PortSQL CRUD route synthesis
- Client-side hooks (React/Svelte)

== Developer experience

Each package that wants to expose HTTP endpoints provides:

----
func Register(app *api.App)
----

Example:

----
package pets

type CreatePetRequest struct {
  Name string `json:"name"`
}

type CreatedPet struct {
  PublicID string `json:"public_id"`
  Name     string `json:"name"`
}

// CreatePet creates a new pet with the given name.
func CreatePet(ctx context.Context, req CreatePetRequest) (CreatedPet, error) {
  // domain logic
}

func Register(app *api.App) {
  app.Post("/pets", CreatePet)
}
----

== Registry API (compile-time, executed at build time)

The key idea (PortSQL-style) is that the build tool constructs a registry and **executes** `Register(app)` to collect an in-memory endpoint list.

Minimal API:

----
type App struct { /* records endpoints */ }

func (a *App) Get(path string, handler any)
func (a *App) Post(path string, handler any)
func (a *App) Put(path string, handler any)
func (a *App) Delete(path string, handler any)
----

Notes:

- `handler` is intentionally `any` to keep wiring frictionless.
- The compiler validates handler signatures at build time (see below).
- In production, you do **not** execute discovery; you run only the generated server code.

== Supported handler signatures (MVP)

To keep decoding/encoding and codegen simple, the MVP supports only these shapes:

- `func(ctx context.Context, req Req) (resp Resp, err error)`
- `func(ctx context.Context, req Req) error` (no response body; success defaults to 204)
- `func(ctx context.Context) (resp Resp, err error)`
- `func(ctx context.Context) error`

Constraints (MVP):

- `Req` should be a struct type (or pointer to struct) with binding tags.
- `Resp` should be JSON-serializable (structs, slices, maps, scalars, `time.Time`, named aliases of those).
- No streaming, no variadic params, no multiple non-error returns.

== Request binding (MVP)

Binding comes from **Go struct tags** on the request type. Comments are docs-only and do not affect routing/binding.

Supported tags:

- `path:"name"`: binds from path variables (e.g. `/pets/{name}`).
- `query:"q"`: binds from query string (`?q=...`).
- `header:"X-Request-Id"`: binds from headers.
- `json:"field"`: binds from JSON request body.

Rules:

- If the route pattern contains `{x}`, then `Req` must have exactly one exported field with `path:"x"`.
- Query params:
  - `T` binds from a single value (`?limit=10`).
  - `[]T` binds from repeated values (`?tag=a&tag=b`).
  - `*T` indicates optionality.
- JSON body:
  - If `Req` has any `json:"..."` fields, the request has an `application/json` body and those fields are decoded from it.
  - If `Req` has no `json:"..."` fields, there is no body (MVP).

Stdlib router note (Go 1.22+):

- Generated handlers use `r.PathValue("x")` for `{x}` variables.
- Generated routes use method-aware patterns like `"POST /pets/{public_id}"`.

== Response encoding (MVP)

- Success response body: JSON (`application/json`) for handlers returning `Resp`.
- Success status:
  - defaults to 200 for handlers returning `Resp`
  - defaults to 204 for handlers returning only `error`
- Errors:
  - decoding/binding errors: 400 with a minimal JSON error payload (exact shape TBD, but stable)
  - handler errors: 500 by default

(Typed error/status mapping is a future extension; MVP keeps it simple.)

== Generated server (MVP)

The generator emits a file like `zz_generated_http.go` that:

- creates an `*http.ServeMux`
- registers one `mux.HandleFunc("<METHOD> <PATH>", handler)` per endpoint
- implements the glue code:
  - decode request into `Req` (path/query/header/json)
  - call the pure handler
  - encode response / error

Suggested generated entrypoint shape:

----
// NewMux returns a mux with all generated routes registered.
func NewMux() *http.ServeMux
----

This keeps integration trivial:

----
mux := api.NewMux()
http.ListenAndServe(":8080", mux)
----

== Build-time compilation workflow (MVP)

The MVP can be a single generator that does “execute registration → generate HTTP code” in one step:

- `cmd/portsql-api-httpgen`
  - reads a tiny INI file that specifies the root API package
  - discovers endpoints by importing that package and executing its `Register(app)` function
  - constructs `api.App`
  - calls `root.Register(app)` (the root can call other packages’ `Register`)
  - validates endpoint signatures + bindings
  - generates `zz_generated_http.go` into the root package directory

=== Configuration file (INI)

To keep the workflow dead-simple (PortSQL-style), the generator should not require flags. The only input is a small INI file that identifies the root package.

Search order (first match wins):

- `$PORTSQL_API_HTTPGEN_CONFIG` if set
- `./portsql-api-httpgen.ini` in the current directory (where `go:generate` runs)

If no config file is found, the generator should fail with a clear message describing the expected filename and keys.

==== Example config

[source,ini]
----
[httpgen]
package = ./api
----

==== Supported keys

All keys live under the `[httpgen]` section.

- **`package`** (string, required): The root package to import and execute for discovery (module-relative like `./api` or `./cmd/server/api`). The package must export `func Register(app *api.App)`.

Conventions:

- The generator always writes `zz_generated_http.go` into the specified package directory.
- The generated file uses the package name declared by that directory (i.e. no `-pkg` override in the MVP).

=== Example `go:generate`

----
//go:generate go run ./cmd/portsql-api-httpgen
----

Determinism:

- sort endpoints by method + path + handler identity before emitting code
- stable formatting (`gofmt`) and stable identifiers

== Package composition (MVP)

To keep the MVP reliable and avoid “scan the world” behavior:

- A single root package (e.g. `./api` or `./cmd/server/api`) owns:
  - importing all feature packages
  - calling their `Register(app)` functions

This preserves independent packages while keeping discovery explicit and deterministic.

== Extension points (future)

The MVP is designed to extend without breaking the basic model:

- **Middleware**: extend the registry with `app.Use(mw)` or per-route options; generate handler chains.
- **OpenAPI**: add a second output phase that reads endpoint+types and emits OpenAPI JSON; doc comments can be parsed with `go/packages` (reflection cannot read comments).
- **Typed test client**: generate a Go client from the same endpoint/type info.
- **PortSQL CRUD synthesis**: add a higher-level builder that registers standard CRUD endpoints from a schema/PortSQL model.
- **React/Svelte hooks**: emit client-side code from the same endpoint manifest/OpenAPI.