= PortAPI Middleware Design (Codegen-first)

This document defines middleware for PortAPI in the **codegen-first** architecture.

It supersedes earlier drafts that assumed a reusable “runtime package” would own most request/response glue.
In the current approach, the generator emits the concrete server pipeline (stdlib `net/http` + `http.ServeMux`),
and middleware hooks are expressed as **stable, generator-known function signatures** plus **discovery-time declarations**.

The overarching constraints remain:

- **Pure domain handlers**: handlers do not import/know about `net/http`.
- **Deterministic codegen**: stable output for same inputs.
- **Discovery executes Go code**: build-time tool imports packages and executes registrations.
- **Generated server is stdlib**: `net/http` + `http.ServeMux` (Go 1.22+ patterns).
- **No hidden global ordering**: middleware ordering is explicit and deterministic.

Middleware must satisfy:

- Attach middleware via **groups** (`app.Group`) (no implicit global ordering from scattered packages).
- Optional, deterministic **global middleware** comes from a **single dedicated package** configured in INI.
- Middleware can:
  - read request metadata (method, route pattern, headers, path vars, query)
  - optionally read decoded request (post-bind)
  - add typed values to `context.Context` for handlers
  - short-circuit with typed errors and/or direct responses
  - observe timing/status/errors (logging/tracing), including on short-circuit

This is written as an MVP+ design: small surface area, clean extension points.

== Terms

- *Discovery*: build-time execution of registration code to collect endpoints/middleware and produce a manifest for codegen.
- *Global middleware*: middleware applied to all endpoints, declared in a single configured package.
- *Group middleware*: middleware applied to endpoints registered within `app.Group(...)` scope.
- *Around middleware*: middleware that wraps the “next” step and can run code before and after calling it.
- *Binding*: decoding path/query/header/json into the handler’s request struct (per `@DESIGN.adoc`).

== Non-goals

- Rich policy engines, DI containers, or pluggable middleware from arbitrary packages.
- Automatic inference of context values or requirements from middleware code (no AST analysis).
- Streaming bodies / websockets.
- Full OpenAPI emission (this design includes declaration hooks needed later).

== Developer experience

=== Group middleware (required API)

Handlers continue to be registered explicitly with full, unambiguous paths.
Groups do NOT add a path prefix; groups only add middleware scope.

Example:

----
package apiroot

import (
  "github.com/you/portsql/api/portapi"
  "github.com/you/app/mw"
  "github.com/you/app/pets"
)

func Register(app *portapi.App) {
  app.Group(func(g *portapi.Group) {
    g.Use(mw.RequestID)
    g.Use(mw.Logging)

    g.Get("/pets/{public_id}", pets.GetPet)
    g.Post("/pets", pets.CreatePet)

    g.Group(func(g2 *portapi.Group) {
      g2.Use(mw.AuthRequired)
      g2.Delete("/pets/{public_id}", pets.DeletePet)
    })
  })
}
----

Semantics:

- `g.Use(...)` applies to endpoints registered **in that group and its nested groups**.
- Nested groups inherit parent middleware (typical stack semantics).
- Middleware execution order is deterministic:
  - Outer group middleware runs before inner group middleware.
  - Within a group, middleware runs in the order `Use(...)` was called.
  - Global middleware (if configured) runs before any group middleware.

=== Optional global middleware package (deterministic ordering)

If configured, the generator imports exactly one global middleware package and executes:

----
func RegisterMiddleware(reg *portapi.MiddlewareRegistry)
----

That package is the only place global middleware ordering is defined.

Rules:

- The global middleware package MUST NOT import endpoint packages (avoid dependency cycles).
- If `middleware_package` is omitted in config, there is no global middleware.
- Strict mode (required for OpenAPI correctness later): any middleware used via `g.Use(...)` MUST be declared in the global middleware package registry (see “Strict middleware declaration” below). Undeclared middleware is a codegen-time error.

Example:

----
package mw

import "github.com/you/portsql/api/portapi"

func RegisterMiddleware(reg *portapi.MiddlewareRegistry) {
  // Declare typed context values (required for generated helpers).
  reg.Provide("request_id", portapi.TypeOf[string]())
  reg.Provide("user", portapi.TypeOf[*User]())

  // Register middleware in explicit order (deterministic).
  reg.Use(RequestID)
  reg.Use(Logging)
  reg.Use(AuthOptional) // may set user in context

  // Optional: attach machine-readable requirements for later OpenAPI.
  reg.Describe(AuthOptional).
    Security("bearerAuth").
    RequireHeader("Authorization").
    MayReturn(401, "unauthorized").
    MayReturn(403, "forbidden")
}
----

== Discovery-time API surface (registry + grouping)

The discovery-time `portapi.App` is extended with grouping and middleware recording.

=== `App` additions

- `func (a *App) Group(fn func(g *Group))`

Notes:

- `Group` is a separate type (not `*App`) to make scope explicit and to avoid “accidental” leakage of middleware state.
- Top-level endpoints may remain supported for backwards compatibility; however, group usage is the intended middleware path.

=== `Group` API

Minimal:

----
type Group struct { /* discovery-only scope */ }

func (g *Group) Use(mw Middleware)
func (g *Group) Group(fn func(g2 *Group))

func (g *Group) Get(path string, handler any)
func (g *Group) Post(path string, handler any)
func (g *Group) Put(path string, handler any)
func (g *Group) Delete(path string, handler any)
----

Important: `Group` does not take a prefix. All endpoint paths are specified on the route call.

=== Middleware values recorded during discovery

The registry records middleware by **function identity** (package import path + symbol name) and retains the actual value for validation.

MVP supports **functions only** for simplicity and determinism.

== Runtime model (codegen-first)

PortAPI does not rely on a hand-written “runtime pipeline” package to orchestrate middleware.
Instead, the generator emits the per-endpoint glue and middleware chain invocation directly.

The key design goal is:

- Middleware authors never import `net/http`
- The generated server can still:
  - run middleware “around” binding + handler
  - support pre-bind and post-bind visibility
  - map typed errors to HTTP responses consistently

=== Generated pipeline shape (conceptual)

For each endpoint, the generated handler performs:

1. Construct a lightweight request view (`req`) from `*http.Request` and route pattern.
2. Build `next` such that it:
   a) performs binding (if any) into the endpoint’s request type
   b) calls the domain handler
   c) converts success into a `HandlerResult`
3. Wrap `next` with the effective middleware chain (global + group) using standard “around” semantics.
4. Execute the chain starting from `ctx := r.Context()`.
5. Respond:
   - on success: encode JSON or no-content
   - on error: map typed error -> status+stable error code; otherwise 500

Because middleware is “around”, it can time and observe:
- short-circuit responses (middleware returns without calling next)
- binding failures
- handler failures
- successful responses

=== Canonical middleware signature (MVP)

Middleware is an “around” wrapper over a next step.

----
type Next func(ctx context.Context) (HandlerResult, error)

type Middleware func(ctx context.Context, req *Request, next Next) (HandlerResult, error)
----

Notes:

- Middleware receives:
  - `ctx`: request context (can be replaced with `context.WithValue` and passed to `next`)
  - `req`: request metadata wrapper (method/pattern/headers/query/path vars; optionally decoded request)
  - `next`: calls the remainder of the pipeline
- Middleware can:
  - short-circuit by returning a `HandlerResult` without calling `next`
  - wrap `next` to measure duration, observe errors, etc.
  - mutate context for the handler by calling `next(newCtx)`
- Middleware does NOT receive `*http.Request` or `http.ResponseWriter`.

This single signature covers:
- “Before binding” behavior (runs before `next` is invoked)
- “After binding/handler” behavior (runs after `next` returns)

=== Request view (`Request`)

Conceptual interface:

----
type Request struct {
  Method  string // "GET"
  Pattern string // "/pets/{public_id}" (route pattern)

  Header    func(name string) (string, bool)
  Cookie    func(name string) (string, bool)
  Query     func(name string) []string
  PathValue func(name string) string

  // DecodedReq returns the decoded request value if binding has occurred.
  // Returns (nil, false) if called before binding or if endpoint has no request type.
  DecodedReq func() (any, bool)
}
----

Notes:

- This is a **read-only** view. Middleware should not mutate decoded request values (MVP).
- The implementation is generated per endpoint (or shared helper functions generated into the server file).
- `DecodedReq` is a closure over per-request state set by the binding step.

=== Handler result (`HandlerResult`)

MVP focuses on JSON and no-content:

----
type HandlerResult struct {
  Status int // optional; default per operation/shape
  JSON   any // mutually exclusive with NoContent in MVP
  NoContent bool
}
----

Rules:

- Exactly one of `JSON` or `NoContent` should be used for success.
- Middleware may return a direct `HandlerResult` to short-circuit (rare; most should return typed errors).

== Strict middleware declaration (required)

To support reliable downstream generation (especially OpenAPI), PortAPI runs in **strict mode** when middleware is used:

- Every middleware passed to `g.Use(mw)` MUST have a corresponding declaration in the configured global middleware package’s `RegisterMiddleware`.
- If middleware is used in any group but is not declared globally, generation fails with a clear error:
  - `undeclared_middleware: middleware <pkg>.<name> used in group but not declared in middleware package registry`

This ensures the generator always has:
- a stable identity for middleware used anywhere
- deterministic global ordering constraints
- any associated schema/metadata (context values, headers/cookies/security, etc.)

Additionally:

- If any middleware is used but `middleware_package` is not configured, generation fails with a clear error:
  - `middleware_used_without_registry: middleware used via Group.Use but no middleware_package configured`

(That keeps the system deterministic and OpenAPI-ready.)

== Typed context schema (“typed thingy”)

Goal: middleware can compute values (e.g. authenticated user) and store them in `context.Context`, and handlers can access them without re-binding headers on every request struct.

We accomplish this by:

1. Declaring a schema of provided context values in the global middleware registry (`Provide`)
2. Generating typed helpers into the middleware package

=== Declaration via registry DSL (required)

The global middleware package’s `RegisterMiddleware` is the single source of truth for:

- middleware identity + ordering (`Use`)
- typed context keys (`Provide`)
- OpenAPI-relevant middleware requirements/metadata (`Describe(...)`)

Example:

----
func RegisterMiddleware(reg *portapi.MiddlewareRegistry) {
  reg.Provide("user", portapi.TypeOf[*User]())
  reg.Provide("request_id", portapi.TypeOf[string]())

  reg.Use(AuthOptional)
  reg.Use(RequestID)
}
----

Rules:

- `Provide(key, type)` is required for any key used with generated helpers.
- Key collisions are codegen-time errors:
  - duplicate key
  - same key with different type
- Keys are global to the middleware package.
- Keys should match a conservative pattern (e.g. `[a-z][a-z0-9_]*`) to generate stable identifiers.

=== Generated helpers (in middleware package)

Given `Provide("user", *User)`, generator emits:

- `func WithUser(ctx context.Context, v *User) context.Context`
- `func User(ctx context.Context) (*User, bool)` (value + presence)
- `func MustUser(ctx context.Context) *User` (panics; optional)

These helpers are the supported way for:
- middleware to inject values
- handlers to retrieve values

Handlers remain pure (no `net/http`).

Example handler:

----
func GetPet(ctx context.Context, req GetPetRequest) (GetPetResponse, error) {
  user, ok := mw.User(ctx)
  if !ok {
    return GetPetResponse{}, mw.HTTPError{Status: 401, Code: "unauthorized"}
  }
  _ = user
  ...
}
----

== Per-middleware OpenAPI metadata (declaration hooks)

To generate accurate OpenAPI specs later (cookie/header requirements, security), middleware must be able to declare what it requires.

This design attaches metadata to middleware identity in the registry:

----
func RegisterMiddleware(reg *portapi.MiddlewareRegistry) {
  reg.Use(AuthRequired)

  reg.Describe(AuthRequired).
    Security("bearerAuth").
    RequireHeader("Authorization").
    MayReturn(401, "unauthorized").
    MayReturn(403, "forbidden")

  reg.Use(SessionRequired)
  reg.Describe(SessionRequired).
    Security("cookieAuth").
    RequireCookie("session_id").
    MayReturn(401, "unauthorized")
}
----

Rules:

- `Describe(mw)` MUST reference a middleware that has been declared via `reg.Use(mw)`.
- Any middleware used in `g.Use(mw)` MUST appear in `reg.Use(mw)` (strict mode), so metadata lookup is always possible (even if empty).

Metadata is associated with middleware symbol (package + name) and is reusable:
if an endpoint’s effective chain includes `SessionRequired`, OpenAPI generation can attach the cookie requirement to that operation.

== Error and response mapping

Middleware and handlers can return typed errors (preferred) or direct responses (escape hatch).

=== Typed error mapping (preferred)

Canonical typed error interface:

----
type CodedError interface {
  error
  StatusCode() int
  ErrorCode() string
}
----

Convenience struct:

----
type HTTPError struct {
  Status int
  Code   string
  Msg    string // optional
}

func (e HTTPError) Error() string
func (e HTTPError) StatusCode() int
func (e HTTPError) ErrorCode() string
----

Generated server behavior:

- If `err` (from middleware or handler) implements `CodedError`:
  - status = `StatusCode()`
  - JSON error body includes stable `code = ErrorCode()`
- Else:
  - status = 500
  - JSON error body includes stable `code = "internal_error"`

Binding errors remain 400 with stable codes (per `@DESIGN.adoc`).

Recommended minimal JSON error shape:

----
{ "error": { "code": "unauthorized", "message": "..." } }
----

Message policy is implementation-defined; default should avoid leaking sensitive info.

=== Direct response (escape hatch)

Middleware may return a direct `HandlerResult` without calling `next` (redirect-like behavior, synthetic responses).

MVP supports:

- JSON responses
- no-content responses

Rules:

- If middleware returns `HandlerResult{Status: ...}`, the generator writes that status.
- If both a non-zero `HandlerResult` and `err` are returned, `err` wins (the generator may treat this as invalid and respond 500).

== Code generation + discovery workflow

The generator extends MVP workflow:

1. Read config (INI).
2. Import root API package (from `[httpgen] package = ...`) and execute `Register(app)`.
3. If configured, import middleware package (from `[httpgen] middleware_package = ...`) and execute `RegisterMiddleware(reg)`.
4. Validate:
   - endpoints (existing validation)
   - middleware:
     - middleware values are functions with the canonical signature
     - `Provide` keys are unique and valid
     - `Describe` only references `Use`’d middleware
     - strict mode: any `g.Use` middleware is declared via `reg.Use`
5. Generate:
   - `zz_generated_http.go` in the root API package (server + routing + middleware chains)
   - `zz_generated_middleware_context.go` in the middleware package (typed context helpers, optionally typed error helpers)

=== Config (INI)

Under `[httpgen]`:

- `middleware_package` (string, optional): module-relative package path to import for global middleware (e.g. `./api/middleware`).

Example:

[source,ini]
----
[httpgen]
package = ./api
middleware_package = ./api/middleware
----

Rules:

- If omitted, generator behaves as if there is no global middleware.
- If middleware is used via `Group.Use` and this key is omitted, generation fails (strict mode).

=== Determinism

Deterministic requirements:

- Endpoints are sorted deterministically for emission (method + path + handler identity), as in MVP.
- Middleware ordering is semantic and preserved:
  - global middleware order: the order of `reg.Use(...)` calls in `RegisterMiddleware`
  - group middleware order: the order of `g.Use(...)` calls and nesting in the root `Register` execution

The generator must not reorder middleware calls.

== Validation rules (MVP+)

=== Middleware signature validation

A middleware must be a function matching the canonical signature:

- `func(ctx context.Context, req *portapi.Request, next portapi.Next) (portapi.HandlerResult, error)`

Disallowed:

- variadic middleware
- middleware returning multiple non-error values
- middleware with additional parameters

=== Strict middleware declaration validation

During generation:

- compute the set of middleware identities used by endpoints (from group `Use`)
- compute the set declared in the middleware registry (from `reg.Use`)
- any used-but-not-declared middleware is an error (strict mode)

Additionally:

- any `Describe(mw)` that references an undeclared middleware is an error
- any `Provide` key collision is an error

=== Dependency rule

The middleware package must not import endpoint packages.

This is a documented policy; the generator may optionally enforce it via import graph checks.

== Extension points (future)

- Per-endpoint middleware options (route-level).
- Declarative capabilities: middleware can declare “needs body bytes”, “needs decoded req”, etc.
- Rich response types in `HandlerResult` (files, streaming).
- Automatic OpenAPI security scheme emission from middleware declarations.
- Structured error catalogs (codes from a registry; tags on error structs).

== Summary

This design adds middleware while preserving the MVP philosophy:

- Pure handlers and stdlib-generated server.
- Deterministic, explicit composition:
  - local middleware via `app.Group`
  - optional global middleware from a single configured package
- Typed context values via an explicit registry DSL and generated helpers.
- Middleware “around” semantics that can observe and short-circuit while remaining decoupled from `net/http`.
