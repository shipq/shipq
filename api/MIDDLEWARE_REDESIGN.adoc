= Middleware Redesign
:toc:
:toclevels: 3

== Goals

We want to redesign middleware authoring (especially *inside the middleware package itself*) to:

1. Break the “bootstrap” dependency cycle where middleware code imports generated context helpers (Phase 6) that don’t exist on first run.
2. Provide a compile-time typed experience that answers: “given this middleware ordering, what context values can I read/write?”
3. Ideally make it *impossible* (or at least very hard) to refer to context values that do not exist yet, by forcing middleware registration in DAG (data dependency) order.

This document sketches an integration plan that fits the current system:

- `portapi.MiddlewareRegistry` already exists and tracks `Use(...)`, `Provide(key, TypeOf[T]())`, and middleware metadata.
- `portsql-api-httpgen` generates `zz_generated_middleware_context.go` from `ProvidedKeys()` (Phase 6).
- The bootstrap failure happens when the middleware package code itself calls generated helpers (e.g. `WithRequestID`) before they exist.

== Current architecture (as implemented today)

At discovery time, the generator imports the middleware package and runs `RegisterMiddleware(reg)`:

- Middleware package declares middleware functions via `reg.Use(Logger)` etc.
- Middleware package declares provided context keys via `reg.Provide("request_id", portapi.TypeOf[string]())`.
- Generator creates `zz_generated_middleware_context.go` which provides `WithRequestID`, `RequestID`, `MustRequestID`, etc.

Bootstrapping problem:

- Middleware implementations in the middleware package sometimes call generated helpers (like `WithRequestID(ctx, ...)`).
- On first run, those helpers do not exist, so the middleware package fails to compile.
- Generator cannot import the middleware package, so no manifest is produced, so generation never happens.

== Proposed redesign: “Capability tokens” (stable core) + optional generated helpers (ergonomics)

=== Key idea

Split context manipulation into two layers:

1. **Stable, non-generated core API** used by middleware implementations (and available on first run).
2. **Optional generated helpers** for application/handler ergonomics.

In the redesign, middleware implementations *never need* `zz_generated_middleware_context.go` to compile.
They operate on a stable typed token API that is independent of generation.

=== Capability tokens: what they are

A capability token is a typed value that proves (at compile time) that a particular context key exists and what type it has.

- A “provider” middleware *creates* and returns a token for what it provides.
- A “consumer” middleware *requires* that token as an input.
- Without the token, you can’t call the typed accessors, so you can’t “accidentally” read or write something you haven’t declared.

This naturally forces middleware registration in data dependency order (DAG order) because you can’t call consumers until you have the tokens produced by providers.

=== How this integrates with the existing registry and generator

The existing registry tracks context keys by name + type for generation-time validation and helper generation.

We can keep that, but add a typed layer:

- Middleware package declares keys via a *typed key definition* (still backed by a string key for the generator).
- Registering a provider middleware both:
  - calls `reg.Provide("request_id", TypeOf[string]())` (for generation & manifest), and
  - returns `Cap[string]` (a stable token used to access context at runtime).

Handlers and userland code can keep using generated helpers if they want.
Middleware package code uses tokens and does not import generated helpers.

== Proposed API (sketch)

NOTE: Names are placeholders; actual package/type names should match the repo style.
This is an integration sketch, not final code.

=== Stable core types (non-generated)

Add these types in `portapi` (or a subpackage like `portapi/mwctx`), so they are always available and do not depend on generated files.

Conceptually:

- `ContextKey[T]` is a typed representation of a string context key (e.g. "request_id") with optional documentation.
- `Cap[T]` is a capability token that carries:
  - the typed key,
  - typed `With/Get/Must` methods,
  - and any debug metadata.

We also need a stable runtime storage mechanism for values.
Today, generated helpers use `context.WithValue(ctx, zzCtxKeyX{}, v)` which is per-package and non-interoperable across packages.
For token-based access, we should standardize on a storage approach that doesn’t require generating a unique Go type per key.

Two viable storage approaches:

A) `context.WithValue(ctx, internalKey{"request_id"}, any(v))` using a single internal key type + string.
B) Store a small map in context: `map[string]any` behind an unexported key, with helper functions `Set/Get`.

Option (B) avoids collisions with other libraries using context keys and allows bulk operations, but is slightly heavier.
Option (A) is simpler but uses many context values (one per key) and depends on key uniqueness.

For this sketch, we assume option (B): a single internal map.

==== Stable core API surface

- `portapi.NewContextKey[T](name string) ContextKey[T]`
- `portapi.ContextKey[T].Name() string`
- `portapi.ContextKey[T].Provide(reg *MiddlewareRegistry) (Cap[T], error)`
- `portapi.Cap[T].With(ctx context.Context, v T) context.Context`
- `portapi.Cap[T].Get(ctx context.Context) (T, bool)`
- `portapi.Cap[T].Must(ctx context.Context) T`

The key point: these are *hand-written stable APIs* in the library, not generated.

=== Registry integration

We do not remove `reg.Provide(key, TypeOf[T]())`.
Instead we provide a typed wrapper that still calls `Provide` under the hood.

Example (conceptual):

- `cap, err := portapi.DeclareProvided(reg, portapi.NewContextKey[string]("request_id"))`

or method style:

- `cap, err := portapi.NewContextKey[string]("request_id").Provide(reg)`

This ensures:

- generator still sees the provided keys and types,
- middleware code gets the token.

=== Enforcing DAG order

There are two complementary mechanisms.

1) **Token passing** (scales well, simple):
   - A consumer middleware registration function requires the tokens it needs.
   - You can’t call it until you have them, which forces order.

2) **Staged builder** (optional “golden path” ergonomics):
   - Provide a builder type with methods that only exist after prerequisite stages are reached.
   - This makes invalid ordering unrepresentable (compile-time) for the canonical pipeline.

Token passing alone already yields “you can’t access something you didn’t declare”.
The staged builder yields “you can’t even *register* middlewares in the wrong order”, but can get verbose if naively implemented for many keys.

This redesign can support both:
- Use token passing for most composition.
- Use staged builder only for the main in-package pipeline to guide correct ordering.

== Examples

These examples are written in the style of the existing Phase 6 docs, but updated for tokens.
They are sketches and will require adaptation to the actual middleware/handler signatures.

=== Example 1: Middleware package without generated helpers (bootstraps cleanly)

Suppose your middleware package defines:

- `RequestID` middleware: generates request id and stores it in context.
- `Logger` middleware: logs request id if present.

With capability tokens:

1. `RequestID` declares it provides `request_id` (string) and returns a `Cap[string]`.
2. `Logger` requires `Cap[string]` so it can read request id in a typed way.

Pseudo-structure:

- `RegisterMiddleware(reg)`:
  - `reg.Use(RequestID)` and `reg.Use(Logger)` still happen (for discovery-time ordering/metadata).
  - but we also create a pipeline in code that returns tokens.

Two possible patterns:

==== Pattern A: Token variables in `RegisterMiddleware`

- Declare keys
- Provide keys to registry
- Register middleware and wire tokens to consumers

Sketch:

- `requestIDCap := DeclareProvided("request_id", string)`
- `reg.Use(RequestID(requestIDCap))`
- `reg.Use(Logger(requestIDCap))`

Here `RequestID(...)` and `Logger(...)` are middleware constructors that close over tokens.
That is: middleware is a function value that captures capabilities.

This is a nice pattern because it prevents middleware implementations from reaching into global state.

==== Pattern B: Dedicated middleware “pipeline builder”

Provide a builder that returns “next stage” values:

- `b := middleware.New(reg)`
- `b = b.RequestID()` returns a stage struct that has `RequestID Cap[string]`.
- `b = b.Logger()` can only exist on that stage, so ordering is forced.

This is more prescriptive but gives a very guided experience.

=== Example 2: Handlers still use generated helpers (optional)

After generation, users still get:

- `WithRequestID(ctx, string) context.Context`
- `RequestID(ctx) (string, bool)`
- `MustRequestID(ctx) string`

But note: with tokens, generated helpers are not required for middleware packages to compile.
They become “nice-to-have” for application code.

We should decide how generated helpers relate to the stable token API:

Option 1 (recommended): generated helpers call into the stable storage.
- Generated helpers become thin wrappers around `portapi` storage.
- This ensures consistency between token writes and helper reads.

Option 2: keep generated helpers as today (unique key type per helper).
- Then token-based values and generated helper-based values would not interoperate unless they share the same backing storage.
- This is undesirable.

So, in the redesign, generated helpers should be updated to use the same storage mechanism as tokens.

== Concrete integration into the current portsql codebase

This section describes what changes we’d make to the current system components.

=== 1) `portapi` additions (stable, non-generated)

Add new types/functions alongside the existing `MiddlewareRegistry`:

- `type ContextKey[T any] struct { name string }`
- `func NewContextKey[T any](name string) ContextKey[T]`
- `type Cap[T any] struct { key string }` (or wrap ContextKey[T])
- `func (k ContextKey[T]) Provide(reg *MiddlewareRegistry) (Cap[T], *RegistryError)`
  - internally calls `reg.Provide(k.name, TypeOf[T]())`
  - returns `Cap[T]` on success
- `func (c Cap[T]) With(ctx context.Context, v T) context.Context`
- `func (c Cap[T]) Get(ctx context.Context) (T, bool)`
- `func (c Cap[T]) Must(ctx context.Context) T`

Runtime storage:
- Add internal helper functions in `portapi` for context map storage:
  - `set(ctx, key string, v any) context.Context`
  - `get(ctx, key string) (any, bool)`

This ensures middleware can set/get values without generated helpers.

=== 2) Middleware registry: no breaking change required

We can keep:
- `Use(mw any)`
- `Provide(key string, typ TypeToken)`

The new typed layer should be additive.

However, one subtlety: `Provide` currently only validates and stores a map of key->reflect.Type.
The capability token API will require the same validation rules.
So `ContextKey[T].Provide(reg)` should forward errors from `reg.Provide(...)` exactly, to avoid duplicated logic.

=== 3) Generator changes: generated helpers should use stable storage

Currently generated helpers use:

- `context.WithValue(ctx, zzCtxKeyRequestID{}, v)`
- `ctx.Value(zzCtxKeyRequestID{}).(T)`

In the redesign, generated helpers should instead call stable APIs in `portapi` to access the same store as tokens.

That would look like:

- `return portapi.WithValue(ctx, "request_id", v)` (typed wrapper)
- `return portapi.GetValue[T](ctx, "request_id")`

But we should avoid exposing an unsafe “stringly typed” API that users can misuse.
So the stable API should be typed and only accept known keys OR hide “raw set/get” behind unexported symbols, while generated code (same module) uses a safe exported typed function.

One reasonable compromise:

- Export a typed helper in `portapi`:

  - `func WithTyped[T any](ctx context.Context, key string, v T) context.Context`
  - `func GetTyped[T any](ctx context.Context, key string) (T, bool)`

This is still string-based, but strongly typed by `T`.
It is acceptable because it’s a low-level API; misuse is possible, but it’s no worse than today’s possibility of mismatched `Provide` vs `With...` in hand-written code.
The primary safety remains: in middleware packages, you should use `Cap[T]`, not raw strings.

If we want to prevent userland from using raw string keys, we can:

- keep `WithTyped/GetTyped` unexported (not possible across packages),
- or accept that this is an advanced API and document “prefer generated helpers or capabilities”.

Given the existing design already exposes `Provide("request_id", TypeOf[string]())`, exposing typed set/get isn’t a new category of risk.

=== 4) Middleware package authoring pattern

We should encourage middleware packages to:

- define typed keys in one place,
- in `RegisterMiddleware(reg)`:
  - declare provided keys via typed key `.Provide(reg)` (returning tokens),
  - register middleware using constructors that accept the tokens they need.

That yields:

- no dependency on generated `zz_generated_middleware_context.go`,
- compile-time capability gating,
- a natural “write in data-dependency order” style.

=== 5) Staged builder (optional, for in-package “DAG order by API shape”)

If desired, we can provide a helper builder type in `portapi` or recommend that middleware packages implement their own builder.

The builder is just sugar around token passing.

Important note: staged builders can explode combinatorially if you model every subset.
We should keep it small and focused:
- Use staged types only for the “top-level required orderings” that matter.
- For everything else, use token passing.

== Putting it all together: proposed “future” middleware package skeleton (sketch)

This is a conceptual middleware package layout:

- `middleware/keys.go`
  - define `var RequestIDKey = portapi.NewContextKey[string]("request_id")`
- `middleware/register.go`
  - `func RegisterMiddleware(reg *portapi.MiddlewareRegistry) { ... }`
- `middleware/request_id.go`
  - `func NewRequestID(cap portapi.Cap[string]) anyMiddlewareType`
- `middleware/logger.go`
  - `func NewLogger(requestID portapi.Cap[string]) anyMiddlewareType`

Then:

- `RegisterMiddleware(reg)`:
  - `requestID, err := RequestIDKey.Provide(reg)`
  - `reg.Use(NewRequestID(requestID))`
  - `reg.Use(NewLogger(requestID))`

The middleware implementations:
- `ctx = requestID.With(ctx, id)`
- `id, ok := requestID.Get(ctx)`

No generated helper usage inside middleware package.

== What changes for “compile-time knowledge of what middleware allows”

With capability tokens:

- If a middleware provides `request_id`, then any downstream middleware that needs it must accept a `Cap[string]` parameter.
- That makes the dependency explicit in function signatures.
- You can’t call `requestID.Must(ctx)` without having the token value in scope.

So the answer to “what middlewares allow you to call what context functions?” becomes: “whatever capabilities you have”.
This is compile-time enforced by Go’s typechecker.

The remaining “context functions” in userland are the generated helpers.
Those are still globally callable, but:
- they return `(T, bool)` or panic via `MustX`,
- and users can choose to structure their handlers to only call `MustX` under middleware that guarantees it.

If we want to extend the type-safety story to handlers too, we could later explore typed handler signatures that carry a “capability set” type parameter, but that is outside this redesign.

== Open questions / decisions

1. Where should the capability API live?
   - `portapi` is the obvious place because it is shared and stable.
   - Alternatively, a subpackage to keep the surface smaller.

2. Backing storage choice:
   - Map-in-context vs per-key context.WithValue.
   - The generator should align with whichever storage is used so tokens and generated helpers interoperate.

3. Should we keep string keys as the “source of truth”?
   - The registry and generator are currently based on string keys; capabilities can wrap that.
   - That’s fine as long as we keep validation centralized in `reg.Provide`.

4. How strongly do we want to enforce ordering?
   - Token passing enforces “can’t consume before provided” but doesn’t prevent someone from calling `reg.Use` in the “wrong order” if they’re not using a builder.
   - If runtime order matters, we still need to preserve `Use` ordering; the staged builder makes this easier to get right.

== Summary

This redesign keeps the existing registry + generator flow, but introduces a stable typed capability-token API that middleware packages use instead of generated helpers.

- Bootstrap problem solved: middleware package compiles without generated files.
- Typed experience improved: consuming code must receive tokens in order to access typed context values.
- DAG order encouraged or enforced: token passing forces “provide before consume”; an optional staged builder can make invalid orderings unrepresentable for the canonical pipeline.


== Demo

[source,go]
----
package middleware

import (
	"context"
	"fmt"
	"strings"
	"sync"
	"time"

	"github.com/shipq/shipq/api/portapi"
)

// User represents an authenticated user.
type User struct {
	Username string
	Email    string
}

// --- Capability-token setup (new design) ------------------------------------
//
// In the redesigned system, middleware implementations do NOT depend on any
// generated zz_* context helpers (e.g. WithCurrentUser).
//
// Instead, middleware declares a typed ContextKey and obtains a typed Cap token
// at registration time. That token is then captured by middleware constructors
// and used for typed With/Get operations.
//
// This file assumes the following stable API exists in portapi (sketch):
//
//   - func NewContextKey[T any](name string) ContextKey[T]
//   - (ContextKey[T]) Provide(reg *MiddlewareRegistry) (Cap[T], *RegistryError)
//   - type Cap[T any]
//   - (Cap[T]) With(ctx context.Context, v T) context.Context
//   - (Cap[T]) Get(ctx context.Context) (T, bool)
//   - (Cap[T]) Must(ctx context.Context) T
//
// The generator can still emit optional convenience helpers, but middleware
// packages never need them to compile.

// Keys defined in the middleware package (typed, stable, non-generated).
var currentUserKey = portapi.NewContextKey[*User]("current_user")

// RegisterMiddleware registers all middleware functions and context keys.
func RegisterMiddleware(reg *portapi.MiddlewareRegistry) {
	// Declare provided context keys and obtain capabilities.
	//
	// This both:
	//  1) informs discovery/generation via reg.Provide("current_user", TypeOf[*User]())
	//  2) returns a token that enables typed ctx access without generated helpers
	currentUser, err := currentUserKey.Provide(reg)
	if err != nil {
		panic(err)
	}

	// Register middleware in declaration order.
	//
	// Notice: Auth middleware is constructed with the capability token and closes
	// over it, so the implementation can set/get current_user without referring
	// to generated helpers.
	reg.Use(RequestLogger)
	reg.Use(RateLimiter)
	reg.Use(NewAuthOptional(currentUser))
	reg.Use(NewAuthRequired(currentUser))
}

// RequestLogger logs incoming requests.
func RequestLogger(ctx context.Context, req *portapi.Request, next portapi.Next) (portapi.HandlerResult, error) {
	start := time.Now()
	result, err := next(ctx)
	duration := time.Since(start)

	// Log request details (in a real app, use a proper logger)
	fmt.Printf("[%s] %s %s - %v\n", time.Now().Format(time.RFC3339), req.Method, req.Pattern, duration)

	return result, err
}

// RateLimiter implements simple in-memory rate limiting.
func RateLimiter(ctx context.Context, req *portapi.Request, next portapi.Next) (portapi.HandlerResult, error) {
	// Get client identifier (use Authorization header or IP in real app)
	clientID := "anonymous"
	if authHeader, ok := req.HeaderValue("Authorization"); ok && authHeader != "" {
		clientID = authHeader
	}

	if !rateLimiter.Allow(clientID) {
		return portapi.HandlerResult{}, portapi.HTTPError{
			Status: 429,
			Code:   "rate_limit_exceeded",
			Msg:    "too many requests, please try again later",
		}
	}

	return next(ctx)
}

// Simple in-memory rate limiter for demo purposes.
type simpleRateLimiter struct {
	mu       sync.Mutex
	requests map[string][]time.Time
	limit    int
	window   time.Duration
}

var rateLimiter = &simpleRateLimiter{
	requests: make(map[string][]time.Time),
	limit:    100,
	window:   time.Minute,
}

func (r *simpleRateLimiter) Allow(clientID string) bool {
	r.mu.Lock()
	defer r.mu.Unlock()

	now := time.Now()
	cutoff := now.Add(-r.window)

	// Get existing requests and filter out old ones
	times := r.requests[clientID]
	var valid []time.Time
	for _, t := range times {
		if t.After(cutoff) {
			valid = append(valid, t)
		}
	}

	// Check if under limit
	if len(valid) >= r.limit {
		r.requests[clientID] = valid
		return false
	}

	// Add current request
	valid = append(valid, now)
	r.requests[clientID] = valid
	return true
}

// NewAuthOptional extracts user from Authorization header if present, but doesn't require it.
func NewAuthOptional(currentUser portapi.Cap[*User]) any {
	return func(ctx context.Context, req *portapi.Request, next portapi.Next) (portapi.HandlerResult, error) {
		authHeader, ok := req.HeaderValue("Authorization")
		if ok && authHeader != "" {
			user := parseAuthHeader(authHeader)
			if user != nil {
				ctx = currentUser.With(ctx, user)
			}
		}
		return next(ctx)
	}
}

// NewAuthRequired requires a valid Authorization header and extracts the user.
func NewAuthRequired(currentUser portapi.Cap[*User]) any {
	return func(ctx context.Context, req *portapi.Request, next portapi.Next) (portapi.HandlerResult, error) {
		authHeader, ok := req.HeaderValue("Authorization")
		if !ok || authHeader == "" {
			return portapi.HandlerResult{}, portapi.HTTPError{
				Status: 401,
				Code:   "unauthorized",
				Msg:    "missing authorization header",
			}
		}

		user := parseAuthHeader(authHeader)
		if user == nil {
			return portapi.HandlerResult{}, portapi.HTTPError{
				Status: 401,
				Code:   "unauthorized",
				Msg:    "invalid authorization header",
			}
		}

		ctx = currentUser.With(ctx, user)
		return next(ctx)
	}
}

// parseAuthHeader extracts user information from the Authorization header.
// For demo purposes, we use a simple "Bearer username:email" format.
func parseAuthHeader(header string) *User {
	if !strings.HasPrefix(header, "Bearer ") {
		return nil
	}

	token := strings.TrimPrefix(header, "Bearer ")
	parts := strings.SplitN(token, ":", 2)
	if len(parts) != 2 {
		return nil
	}

	return &User{
		Username: parts[0],
		Email:    parts[1],
	}
}
----
