= Middleware Phase 7 (TDD): End-to-end verification, determinism, and regression coverage
:toc:
:toclevels: 3

This phase is about turning the middleware feature set into something you can trust long-term.

By Phase 7, you should already have:

- Discovery-time groups + middleware capture (Phase 1)
- Global middleware registry + strict validation (Phase 2)
- Stable `portapi` surface (`Request`, `HandlerResult`, `CodedError`, etc.) (Phase 3)
- Generator/discovery runner + manifest fields + import-graph enforcement (Phase 4)
- Middleware-aware generated server pipeline (Phase 5)
- Generated typed context helpers in the middleware package (Phase 6)

Phase 7 adds a test suite that verifies:
- end-to-end correctness (generated server behaves as intended)
- determinism (manifest and generated code are stable)
- regression coverage (edge cases won’t silently break in future refactors)

The entire phase is written TDD style: start by adding failing tests, then fill gaps in generator/runtime behavior only as needed.

== Scope and acceptance criteria

=== In scope

1. Integration tests that exercise the complete toolchain:
- config -> discovery runner -> manifest -> codegen -> compile -> execute requests

2. Determinism tests:
- manifest output stability
- generated code stability (byte-identical) given same inputs

3. Regression/edge-case tests:
- ordering rules
- strictness errors
- import-graph enforcement errors
- post-bind behavior (`DecodedReq`)
- short-circuit semantics
- error mapping semantics

=== Out of scope

- OpenAPI generation itself
- Adding new middleware capabilities (body buffering, streaming, etc.)
- Performance benchmarking (can be done later; Phase 7 focuses on correctness + determinism)

=== Acceptance criteria (Phase 7 complete)

- There is a stable set of end-to-end tests that:
  - compile and run a generated server via `httptest`
  - verify middleware order and semantics
  - verify strict mode errors are clear and stable
  - verify import-graph enforcement errors are clear and stable
- Determinism is enforced by tests:
  - running discovery twice yields identical manifest bytes
  - running codegen twice yields identical generated bytes (at least for `zz_generated_http.go` and `zz_generated_middleware_context.go`)
- These tests run reliably in CI and locally (no reliance on timing races, global mutable state, or order-dependent maps).

== Non-negotiable behavioral invariants to freeze

These are the invariants your tests should enforce and that future changes must preserve.

1) Middleware ordering
- Global middleware runs before any group middleware.
- For groups:
  - outer group middleware runs before inner group middleware
  - within a group, middleware runs in `Use(...)` call order
- Middleware is never re-sorted by the generator.

2) Strict mode
- If any endpoint uses middleware via `Group.Use`, `middleware_package` must be configured.
- Every middleware used via `Group.Use` must be declared via `reg.Use(mw)` in `RegisterMiddleware`.
- `Describe(mw)` must only reference middleware declared via `Use`.

3) Dependency rule enforcement (“compiler enforcement”)
- `middleware_package` MUST NOT import endpoint packages (directly or transitively).
- When violated, the tool must fail early with a stable error code and show an import chain.

4) Middleware semantics
- Middleware is “around”: it can run before and after calling `next`.
- Middleware can short-circuit by returning without calling `next`.
- Post-bind visibility:
  - `DecodedReq` is not available before binding.
  - After successful binding, `DecodedReq` is available as the concrete request struct value (as `any`).
  - If binding fails, `DecodedReq` should remain unavailable (or a documented alternative; whichever you chose in Phase 5 must be tested here).

5) Error mapping
- If error implements `portapi.CodedError`:
  - status = `StatusCode()`
  - error code = `ErrorCode()`
- Otherwise:
  - status = 500
  - error code = `internal_error`
- Binding errors remain 400 with stable bind error codes (per `@DESIGN.adoc`).

6) Result mapping
- `HandlerResult.NoContent` => status default 204 if `Status==0`
- `HandlerResult.JSON!=nil` => status default 200 if `Status==0`
- Contradictory `HandlerResult` is treated as internal error (freeze whatever policy you implemented in Phase 5).

== Test strategy: keep feedback loops tight

Organize tests into three layers:

1) Generator/discovery integration tests (no HTTP requests)
- Run discovery and inspect manifest / error codes.

2) Codegen integration tests (compile-only)
- Generate `zz_generated_http.go` and `zz_generated_middleware_context.go` then compile packages.

3) Full runtime behavior tests (httptest)
- Generate, compile, then instantiate mux/server and send HTTP requests; assert observable results.

The key is to avoid a single giant test that makes debugging painful. Prefer multiple focused tests.

== TDD plan

== Step 1: Add a determinism test for manifest output (failing first)

Goal: prove discovery output is byte-identical across runs.

Test setup:
- Use a stable fixture:
  - one API root package with:
    - nested groups
    - multiple endpoints
    - multiple middleware used in different scopes
  - one middleware package with:
    - `Provide` keys
    - `Use` declarations
    - `Describe` metadata

Test:
- Run discovery twice (in separate invocations so you don’t share state).
- Compare raw manifest bytes.

Assertions:
- bytes are identical

If it fails:
- fix nondeterminism sources:
  - map iteration in manifest serialization
  - non-stable sorting keys
  - any incidental timestamps or environment-dependent output

Important:
- Do not “fix” nondeterminism by removing data; fix it by sorting/normalizing.

== Step 2: Add determinism test for codegen output (failing first)

Goal: prove generated files are byte-identical for same manifest/config.

Test:
- Run codegen twice on the same fixture.
- Compare bytes for:
  - `zz_generated_http.go`
  - `zz_generated_middleware_context.go` (if present)

Assertions:
- byte-identical outputs

Notes:
- If you run `gofmt`, run it consistently and snapshot the formatted output.
- Avoid embedding any generation timestamps or run IDs.

== Step 3: Add a “golden” end-to-end behavioral test (happy path)

Goal: verify the feature end-to-end without focusing on edge cases.

Fixture:
- middleware package:
  - `GlobalA`, `GlobalB` middlewares
  - `GroupA`, `GroupB` middlewares
  - `Provide("request_id", string)` plus helpers generated in Phase 6
- API root:
  - endpoint with request binding (path var and JSON body, for example)
  - groups:
    - outer group uses `GroupA`
    - inner group uses `GroupB`
  - endpoint inside inner group uses handler that:
    - reads typed context values if set by middleware
    - returns a JSON response

Test request:
- Send request with headers/query/path set so middleware can observe them.
- Ensure binding succeeds.

Assertions:
- middleware order is correct (global then group)
- handler is invoked exactly once
- response status and body match expected success response
- any expected context injection works (middleware sets ctx value, handler reads it)

This test should initially fail if any piece is not fully wired; then you fix only what’s required.

== Step 4: Add “short-circuit via typed error” test

Goal: prove auth-like middleware behavior.

Fixture:
- middleware `AuthRequired`:
  - checks header/cookie
  - if missing returns `portapi.HTTPError{Status: 401, Code: "unauthorized"}` without calling `next`
- handler increments a counter

Test:
- Send request missing auth header.

Assertions:
- status 401
- JSON error contains code `unauthorized`
- handler counter remains 0
- any outer “logging” middleware’s deferred logic runs appropriately (only if your middleware defers around `next`; be explicit in the test)

== Step 5: Add “short-circuit via HandlerResult” test

Goal: prove direct response escape hatch works.

Fixture:
- middleware returns `HandlerResult{Status: 204, NoContent: true}` without calling `next`
- handler increments a counter

Assertions:
- status 204, empty body
- handler counter remains 0

== Step 6: Add post-bind `DecodedReq` visibility tests (success + failure)

Goal: freeze behavior of `DecodedReq` around binding.

Test A (success):
- middleware calls `next(ctx)` then inspects `DecodedReq`
- record:
  - `ok == true`
  - value is of expected request type (by type assertion or reflect)
- handler returns success

Assertions:
- decoded request is present and correct type

Test B (binding failure):
- middleware calls `next(ctx)`; it should receive an error
- decide the frozen behavior:
  - typically: because `next` returns error, middleware doesn’t proceed to inspect decoded request unless it chooses to
- assert:
  - response is 400 with binding error code(s)
  - decoded request not available (if inspected)
  - ensure error mapping is stable

== Step 7: Add strict-mode regression tests (error codes + messages)

These should be integration tests over discovery, not runtime HTTP.

Tests:
1) middleware used but no `middleware_package` configured
- expect error code `middleware_used_without_registry`
- message must mention configuring `[httpgen] middleware_package`

2) middleware used but undeclared in registry
- expect error code `undeclared_middleware`
- message includes middleware identity (package + name)

3) `Describe(mw)` for undeclared mw
- expect stable error code from Phase 2
- message includes middleware identity

Goal:
- freeze error codes and ensure the error output is actionable.

== Step 8: Add import-graph enforcement regression tests

These tests ensure the “compiler” enforces the dependency rule reliably.

Fixture:
- middleware package imports an endpoint package (directly or via helper package)
- ensure it’s a transitive import in at least one test to validate graph walking

Assertions:
- error code `middleware_imports_endpoints`
- error message includes:
  - middleware package path
  - endpoint package path (or api root)
  - import chain

Determinism:
- if multiple chains exist, the selected chain must be deterministic (BFS/lexical sort). Write the test to assert the chosen chain exactly.

== Step 9: Add “mixed endpoints” regression tests (shape coverage)

Goal: ensure middleware wrapping applies consistently to all supported handler shapes.

Create endpoints covering your supported handler signatures, for example:
- `func(ctx context.Context) (Resp, error)`
- `func(ctx context.Context, req Req) (Resp, error)`
- (and any other supported MVP shapes)

Assertions:
- middleware is invoked for each endpoint consistently
- request view fields (`Method`, `Pattern`, path vars) are correct
- error mapping and success mapping work across shapes

== Step 10: Add concurrency safety regression test (optional but valuable)

Goal: ensure generated code doesn’t accidentally share per-request state.

Test:
- run N parallel requests to the same endpoint
- middleware appends to a per-request slice (must be per-request, not global)
- verify no cross-request contamination

This test catches bugs such as:
- using package-level variables for decoded request storage
- reusing a `Request` instance across requests
- storing request-specific state in shared structures

If you keep any global counters in fixtures, use atomic or per-request capture.

== Step 11: Freeze “no hidden global ordering” policy with a test

Goal: prevent accidental middleware ordering drift.

Test:
- Declare global middleware in registry as `Use(A)`, `Use(B)`
- Use group middleware `Use(C)`, `Use(D)`
- Ensure emitted effective chain is `A, B, C, D`

If future changes introduce reordering (sorting by name, etc.), this test must fail loudly.

== Step 12: Establish a regression harness for future additions

To keep the test suite maintainable:
- Create a small helper in tests that:
  - runs discovery
  - runs codegen
  - compiles packages
  - returns a mux/handler to run `httptest` requests
- Keep fixtures small and purpose-built.
- Avoid over-asserting incidental details (like error messages) except where you deliberately freeze them.

== Deliverables summary

By the end of Phase 7, you will have:

- Determinism tests:
  - manifest is byte-identical across runs
  - generated code is byte-identical across runs
- End-to-end behavioral tests via `httptest`:
  - middleware ordering (global + groups)
  - short-circuit via typed error (`CodedError`)
  - short-circuit via `HandlerResult`
  - post-bind visibility (`DecodedReq`) success + failure
  - multiple handler shape coverage
- Strict-mode tests:
  - missing registry config error
  - undeclared middleware error
  - bad `Describe` error
- Import-graph enforcement tests:
  - middleware package importing endpoints rejected with stable error code and deterministic import chain
- Optional concurrency regression test ensuring request-local state isolation

Once these tests exist and are green, the middleware system is “locked in”: future refactors to generator/discovery can proceed with confidence.

== Notes for Phase 8

Phase 8 should focus on:
- documentation polish (examples)
- migration guidance for existing APIs
- optional ergonomics improvements that do not change frozen contracts
- (optionally) new capabilities gated behind explicit declarations (e.g. body buffering), each introduced with new TDD phases and locked by tests.
