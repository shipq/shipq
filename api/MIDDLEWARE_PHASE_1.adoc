= Middleware Phase 1 (TDD): Discovery-time grouping + endpoint middleware capture
:toc:
:toclevels: 3

This phase implements the discovery-time plumbing in `portsql/api/portapi` to support:

- `app.Group(func(g *Group){ ... })`
- `g.Use(mw)`
- endpoints registered within groups capture an ordered middleware identity list

The goal is to end Phase 1 with a buildable codebase and failing/passing tests that prove deterministic middleware ordering and correct attachment to endpoints.

== Scope and acceptance criteria

=== In scope

- New `Group` type and `App.Group`
- `Group.Use` and nested `Group.Group`
- Endpoints registered inside groups carry a `Middlewares` slice with stable middleware identity refs (ordered)
- Middleware signature type exists (at least enough to store and validate; validation can be minimal here if later phases expand it)

=== Out of scope

- Global middleware registry package (`MiddlewareRegistry`) and strict-mode enforcement (Phase 2)
- Generator/discovery runner changes (Phase 4+)
- Generated server pipeline / runtime behavior (Phase 5+)
- Typed context helpers generation (Phase 6)

=== Acceptance criteria (Phase 1 complete)

- Unit tests demonstrate:
  - nesting order: outer group middleware precedes inner group middleware
  - within-group order: middleware runs/records in `Use(...)` call order
  - groups do not share mutable middleware slices (no accidental mutation via shared backing arrays)
  - endpoints registered outside groups still work (if supported in current MVP)
- Endpoint model contains a deterministic middleware identity representation that is stable across runs.

== TDD plan

== Step 1: Define failing tests for group scoping and ordering

Create a new test file under `portsql/api/portapi` (exact filename up to you; keep it near other registry tests).

Write tests that compile against the *desired* API, even if it does not exist yet.

=== Test 1.1: middleware ordering across nested groups

Arrange:

- define middleware functions `A`, `B`, `C` with the canonical signature (even if the signature type is not yet defined, define them to match the design expectation)
- register endpoints:

- outer group: `Use(A)`, `Use(B)`
- inner group: `Use(C)`
- endpoint inside inner group: `Get("/x", handlerX)`

Assert:

- endpoint `"/x"` has middleware refs in the order: `A, B, C`

Notes:

- This test must not depend on runtime execution; it should only inspect the discovery-time endpoint model.
- If endpoints are stored in a slice, locate the one with path `"/x"` and method `GET`.

=== Test 1.2: within-group order is preserved

Arrange:

- single group with `Use(A)`, `Use(B)`, `Use(C)`
- register a single endpoint

Assert:

- middleware refs are `[A, B, C]` in that exact order

=== Test 1.3: child group does not mutate parent’s middleware slice

This catches the classic “slice aliasing” bug.

Arrange:

- outer group: `Use(A)`
- inner group: `Use(B)` then register endpoint `/inner`
- after inner group is defined, register endpoint `/outer` in the outer group scope

Assert:

- `/inner` has `[A, B]`
- `/outer` has `[A]` (not `[A, B]`)

Implementation guidance:

- Ensure the group implementation copies middleware slices when descending into nested groups.

== Step 2: Minimal production code to make tests compile

Implement only what’s necessary to get tests compiling before making them pass.

=== Step 2.1: Add `Group` and `App.Group`

In `portsql/api/portapi`:

- add `type Group struct { ... }`
- add `func (a *App) Group(fn func(g *Group))`

Suggested `Group` state:

- `app *App` pointer
- `mws []MiddlewareRef` or `[]Middleware` + a way to derive identity at registration time

Keep it discovery-time only; avoid any runtime coupling.

=== Step 2.2: Add `Group.Group` and `Group.Use`

- `Group.Use(mw Middleware)` appends in order
- `Group.Group(fn func(g2 *Group))` creates child group inheriting middleware, then calls `fn(g2)`

Important:

- child group must inherit a COPY of the parent middleware list (not the same backing slice)

== Step 3: Record middleware identity on endpoints

Update the endpoint registration path so that `Group.Get/Post/...` results in endpoints carrying middleware refs.

=== Step 3.1: Extend endpoint model

In the endpoint model (wherever `Endpoint` is defined):

- add field `Middlewares []MiddlewareRef` (or similar)
- ensure it is included in any validation / manifest structs later (Phase 4+ will serialize it)

`MiddlewareRef` must include a stable identity (at least):

- middleware package import path
- middleware symbol name (function)

Optionally:

- store the raw function value for validation/debugging

=== Step 3.2: Capture middleware refs when registering endpoints

When `Group.Get` (etc.) delegates to the underlying app endpoint registration, it must attach:

- a copy of the group’s current middleware refs list

Do not share slices between endpoints.

== Step 4: Make tests pass (ordering + slice isolation)

Run the unit tests and fix:

- ordering bugs (outer before inner)
- slice aliasing bugs (copy on group nesting and endpoint capture)

At this step you should have Phase 1 acceptance criteria green.

== Suggested follow-up refactors (optional, but keep Phase 1 small)

- Extract a helper to copy middleware slices safely
- Add small internal helpers for “register endpoint with middleware chain”

Avoid adding global registry or generator-related logic in this phase.

== Deliverables summary

- Tests:
  - nested group ordering
  - within-group ordering
  - slice isolation between parent/child and between endpoints
- Implementation:
  - `App.Group`, `Group`, `Group.Use`, `Group.Group`
  - endpoint model includes ordered middleware refs and group registration attaches them deterministically
