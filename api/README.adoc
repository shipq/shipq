= PortAPI: Write Functions, Compile HTTP
:toc:
:toc-placement!:
:source-highlighter: highlight.js

PortAPI is a code generation framework that lets you define HTTP APIs as plain Go functions and compiles them into fully-wired `http.ServeMux` handlers with automatic request binding, middleware chains, and typed context propagation.

toc::[]

== Philosophy

Traditional Go HTTP frameworks require you to write handlers that manually extract parameters from requests, parse JSON bodies, and wire everything together. PortAPI inverts this: **you write business logic as typed functions, and the framework generates the HTTP plumbing**.

[source,go]
----
// You write this:
func CreatePet(ctx context.Context, req CreatePetRequest) (Pet, error) {
    // Your business logic here
}

// PortAPI generates the HTTP handler, request binding, error handling,
// and middleware integration automatically.
----

The result is:

* **Type safety**: Your handlers receive strongly-typed request structs
* **Separation of concerns**: Business logic stays clean of HTTP details
* **Discoverability**: The generator understands your API structure for documentation
* **Testability**: Handlers are plain functions you can call directly in tests

== Core Concepts

=== Handler Shapes

PortAPI recognizes four handler function signatures:

[cols="1,2,2"]
|===
|Shape |Signature |Use Case

|Request + Response
|`func(ctx, Req) (Resp, error)`
|Most common - CRUD operations

|Request Only
|`func(ctx, Req) error`
|Deletes, actions without response body

|Response Only
|`func(ctx) (Resp, error)`
|List all, get current user

|Context Only
|`func(ctx) error`
|Health checks, side-effect actions
|===

=== Request Binding

Request types use struct tags to declare where each field comes from:

[source,go]
----
type GetPetRequest struct {
    ID      string  `path:"id"`              // From URL path: /pets/{id}
    Verbose *bool   `query:"verbose"`        // From query string: ?verbose=true
    Auth    string  `header:"Authorization"` // From HTTP header
}

type UpdatePetRequest struct {
    ID   string `path:"id"`           // Path parameter
    Name string `json:"name"`         // JSON body field
    Age  int    `json:"age,omitempty"`
}
----

Supported binding sources:

* **`path:"name"`**: URL path parameters (e.g., `/pets/{id}`)
* **`query:"name"`**: Query string parameters (supports scalars, pointers for optional, slices for multi-value)
* **`header:"name"`**: HTTP headers
* **`json:"name"`**: JSON request body fields

The generator validates that:

* All path variables in the route have corresponding struct field bindings
* Types are compatible with their binding source
* No duplicate bindings exist

=== Endpoint Registration

Endpoints are registered through the `App` type using a familiar routing syntax:

[source,go]
----
func Register(app *portapi.App) {
    // Simple registration
    app.Get("/health", HealthCheck)
    app.Get("/pets", ListPets)
    app.Post("/pets", CreatePet)
    app.Get("/pets/{id}", GetPet)
    app.Put("/pets/{id}", UpdatePet)
    app.Delete("/pets/{id}", DeletePet)
}
----

=== Middleware Groups

Middleware is applied through groups, enabling clean separation of public and protected routes:

[source,go]
----
func Register(app *portapi.App) {
    // Public endpoints
    app.Group(func(g *portapi.Group) {
        g.Use(middleware.RequestLogger)
        g.Use(middleware.AuthOptional)

        g.Get("/health", HealthCheck)
        g.Get("/pets", ListPets)
    })

    // Protected endpoints
    app.Group(func(g *portapi.Group) {
        g.Use(middleware.RequestLogger)
        g.Use(middleware.AuthRequired)
        g.Use(middleware.RateLimiter)

        g.Post("/pets", CreatePet)
        g.Delete("/pets/{id}", DeletePet)
    })
}
----

Groups can be nested, with child groups inheriting parent middleware:

[source,go]
----
app.Group(func(outer *portapi.Group) {
    outer.Use(middleware.RequestLogger)

    outer.Group(func(inner *portapi.Group) {
        inner.Use(middleware.AuthRequired)
        // Endpoints here get both RequestLogger AND AuthRequired
    })
})
----

== Middleware System

=== The Middleware Signature

All middleware follows a single, canonical signature:

[source,go]
----
type Middleware func(ctx context.Context, req *Request, next Next) (HandlerResult, error)

type Next func(ctx context.Context) (HandlerResult, error)
----

The `Request` type provides a read-only view of the HTTP request without exposing `net/http`:

[source,go]
----
type Request struct {
    Method    string
    Pattern   string
    Header    func(name string) (string, bool)
    Cookie    func(name string) (string, bool)
    Query     func(name string) []string
    PathValue func(name string) string
    DecodedReq func() (any, bool)  // Access decoded request struct after binding
}
----

=== Context Capabilities

Middleware often needs to pass data to handlers (e.g., authenticated user info). PortAPI provides a type-safe capability system:

==== Defining Context Keys

In your middleware package, define typed context keys:

[source,go]
----
var currentUserKey = portapi.NewContextKey[*User]("current_user")
----

==== Registering Capabilities

During middleware registration, obtain capability tokens:

[source,go]
----
func RegisterMiddleware(reg *portapi.MiddlewareRegistry) {
    // Obtain a typed capability token
    currentUser, err := currentUserKey.Provide(reg)
    if err != nil {
        panic(err)
    }

    // Construct middleware with the capability
    AuthRequired = NewAuthRequired(currentUser)

    reg.Use(RequestLogger)
    reg.Use(AuthRequired)
}
----

==== Using Capabilities in Middleware

The capability token provides typed context operations:

[source,go]
----
func NewAuthRequired(currentUser portapi.Cap[*User]) portapi.Middleware {
    return func(ctx context.Context, req *portapi.Request, next portapi.Next) (portapi.HandlerResult, error) {
        authHeader, ok := req.HeaderValue("Authorization")
        if !ok {
            return portapi.HandlerResult{}, portapi.HTTPError{
                Status: 401, Code: "unauthorized", Msg: "missing auth header",
            }
        }

        user := parseAuthHeader(authHeader)
        if user == nil {
            return portapi.HandlerResult{}, portapi.HTTPError{
                Status: 401, Code: "unauthorized", Msg: "invalid auth header",
            }
        }

        // Store user in context using the capability
        ctx = currentUser.With(ctx, user)
        return next(ctx)
    }
}
----

==== Reading Values in Handlers

The generator creates convenience helpers in the middleware package:

[source,go]
----
// Generated in zz_generated_middleware_context.go
func MustCurrentUser(ctx context.Context) *User {
    return portapi.MustTyped[*User](ctx, "current_user")
}

// Usage in handler
func CreatePet(ctx context.Context, req CreatePetRequest) (Pet, error) {
    user := middleware.MustCurrentUser(ctx)
    // ... use user.Username, user.Email, etc.
}
----

=== Middleware Metadata

Middleware can declare metadata for documentation generation:

[source,go]
----
desc, _ := reg.Describe(AuthRequired)
desc.RequireHeader("Authorization").
     Security("bearerAuth").
     MayReturn(401, "Authentication required")
----

== Error Handling

=== Coded Errors

Return structured errors with HTTP status codes:

[source,go]
----
func GetPet(ctx context.Context, req GetPetRequest) (Pet, error) {
    pet, ok := pets[req.ID]
    if !ok {
        return Pet{}, portapi.HTTPError{
            Status: 404,
            Code:   "pet_not_found",
            Msg:    fmt.Sprintf("Pet %s not found", req.ID),
        }
    }
    return *pet, nil
}
----

Errors implementing `CodedError` are serialized as:

[source,json]
----
{
  "error": {
    "code": "pet_not_found",
    "message": "Pet abc123 not found"
  }
}
----

=== Binding Errors

Request binding failures automatically return 400 Bad Request with details about which field failed.

== Generated Code

When you run the code generator, it produces:

=== Handler Wrappers (`zz_generated_http.go`)

For each endpoint, the generator creates:

1. **Bind functions** that extract and parse request parameters
2. **Handler wrappers** that build the middleware chain and call your function
3. **`NewMux()` function** that wires everything to an `http.ServeMux`

[source,go]
----
// Generated
func NewMux() *http.ServeMux {
    mux := http.NewServeMux()

    mux.Handle("GET /health", handleHealthCheck())
    mux.Handle("GET /pets", handleListPets())
    mux.Handle("POST /pets", handleCreatePet())
    mux.Handle("DELETE /pets/{id}", handleDeletePet())
    mux.Handle("GET /pets/{id}", handleGetPet())
    mux.Handle("PUT /pets/{id}", handleUpdatePet())

    return mux
}
----

=== Context Helpers (`zz_generated_middleware_context.go`)

For each provided context key, the generator creates typed accessors:

[source,go]
----
// Generated in middleware package
func WithCurrentUser(ctx context.Context, v *User) context.Context
func CurrentUser(ctx context.Context) (*User, bool)
func MustCurrentUser(ctx context.Context) *User
----

== Project Structure

=== Simple Single-Package Layout

For small APIs, a flat structure works well:

----
myapp/
├── main.go                          # Server startup
├── api/
│   ├── handlers.go                  # Your handler functions
│   └── zz_generated_http.go         # Generated HTTP wiring
├── middleware/
│   ├── middleware.go                # Middleware implementations
│   └── zz_generated_middleware_context.go  # Generated context helpers
└── portsql-api-httpgen.ini          # Generator configuration
----

=== Multi-Package Layout (Recommended)

For larger APIs, organize handlers by domain in separate packages:

----
myapp/
├── main.go
├── api/
│   ├── register.go                  # Root Register function - wires sub-packages
│   └── zz_generated_http.go         # Generated HTTP wiring
├── pets/
│   └── handlers.go                  # Pet domain handlers
├── authors/
│   └── handlers.go                  # Author domain handlers
├── middleware/
│   ├── middleware.go
│   └── zz_generated_middleware_context.go
└── portsql-api-httpgen.ini
----

The key is the root `api/register.go` file, which composes sub-packages:

[source,go]
----
// api/register.go
package api

import (
    "github.com/myorg/myapp/authors"
    "github.com/myorg/myapp/pets"
    "github.com/myorg/myapp/middleware"
    "github.com/shipq/shipq/api/portapi"
)

func Register(app *portapi.App) {
    // Public endpoints
    app.Group(func(g *portapi.Group) {
        g.Use(middleware.RequestLogger)

        // Delegate to domain packages
        pets.Register(g)
        authors.Register(g)
    })

    // Protected endpoints
    app.Group(func(g *portapi.Group) {
        g.Use(middleware.RequestLogger)
        g.Use(middleware.AuthRequired)

        pets.RegisterProtected(g)
        authors.RegisterProtected(g)
    })
}
----

Each domain package defines its own handlers and registration:

[source,go]
----
// pets/handlers.go
package pets

import (
    "context"
    "github.com/shipq/shipq/api/portapi"
)

type Pet struct {
    ID   string `json:"id"`
    Name string `json:"name"`
}

func Register(g *portapi.Group) {
    g.Get("/pets", ListPets)
    g.Get("/pets/{id}", GetPet)
}

func RegisterProtected(g *portapi.Group) {
    g.Post("/pets", CreatePet)
    g.Delete("/pets/{id}", DeletePet)
}

func ListPets(ctx context.Context) ([]Pet, error) {
    // ...
}

func GetPet(ctx context.Context, req GetPetRequest) (Pet, error) {
    // ...
}

// ... more handlers
----

The generator discovers all endpoints by executing the root `Register(app)` function.
Since the root function calls into sub-packages, handlers from all packages are collected.
The generated code correctly imports each handler's package and references handlers by their fully-qualified names.

NOTE: Sub-packages can accept either `*portapi.App` or `*portapi.Group` depending on whether you want to apply shared middleware at the root level.

=== Configuration

The generator is configured via `portsql-api-httpgen.ini`:

[source,ini]
----
[httpgen]
package = github.com/myorg/myapp/api
middleware_package = github.com/myorg/myapp/middleware
----

== Usage Example

=== 1. Define Your Handlers

Best practice: Keep request/response types directly above the handlers that use them.
This makes it easy to see the full contract for each endpoint at a glance.

[source,go]
----
// api/handlers.go
package api

import "context"

// --- List Pets ---

type Pet struct {
    ID   string `json:"id"`
    Name string `json:"name"`
}

func ListPets(ctx context.Context) ([]Pet, error) {
    return getAllPets(), nil
}

// --- Create Pet ---

type CreatePetRequest struct {
    Name string `json:"name"`
}

func CreatePet(ctx context.Context, req CreatePetRequest) (Pet, error) {
    return savePet(req.Name), nil
}
----

=== 2. Wire Up Registration

Keep registration in a separate file for clarity:

[source,go]
----
// api/register.go
package api

import "github.com/shipq/shipq/api/portapi"

func Register(app *portapi.App) {
    app.Get("/pets", ListPets)
    app.Post("/pets", CreatePet)
}
----

=== 3. Run the Generator

[source,bash]
----
portsql-api-httpgen ./api
----

=== 4. Start Your Server

[source,go]
----
// main.go
package main

func main() {
    mux := api.NewMux()
    http.ListenAndServe(":8080", mux)
}
----

== Design Principles

=== Discovery-Time vs Runtime

PortAPI separates two phases:

* **Discovery time**: The `App` and `Group` types record endpoint registrations. This information is used by the generator to produce code.
* **Runtime**: The generated code uses Go 1.22+ `http.ServeMux` patterns directly. The `portapi` package provides runtime utilities (`Request`, `Middleware`, context helpers) but no routing.

This means:

* No reflection at runtime
* No dynamic route matching overhead
* Full type safety in generated code

=== Middleware Independence

Middleware implementations depend only on the stable `portapi` types (`Middleware`, `Request`, `Cap[T]`), never on generated code. This allows:

* Middleware packages to compile before generation runs
* Middleware to be shared across projects
* Clean separation between framework and application code

=== Validation at Generation Time

The generator validates your API surface:

* Handler signatures match supported shapes
* Request type bindings are valid for their sources
* Path variables all have corresponding bindings
* Middleware used by endpoints is properly declared

Errors are caught before runtime, not at server startup.

== OpenAPI and API Documentation

PortAPI can generate an OpenAPI 3.0.3 specification from your registered endpoints and Go types. The same source of truth that drives code generation also produces accurate API documentation—no separate schema files to maintain.

=== Enabling OpenAPI Generation

Add these settings to your `portsql-api-httpgen.ini`:

[source,ini]
----
[httpgen]
package = ./api

# Enable OpenAPI JSON generation
openapi = true
openapi_output = openapi.json       # Output filename (default)
openapi_title = My API              # API title (defaults to package name)
openapi_version = 1.0.0             # API version (defaults to 0.0.0)
openapi_description = My API docs   # Optional description
openapi_servers = http://localhost:8080, https://api.example.com
----

Running the generator will produce an `openapi.json` file alongside your generated code. The specification includes:

* All registered endpoints with their HTTP methods and paths
* Request parameters extracted from `path:`, `query:`, and `header:` struct tags
* Request body schemas for handlers that accept JSON
* Response schemas derived from your Go return types
* Error response schemas (400, 500) where applicable
* Operation IDs and tags derived from handler names and paths

=== Interactive API Documentation UI

PortAPI includes built-in support for serving interactive API documentation using Stoplight Elements. Enable it by adding:

[source,ini]
----
[httpgen]
package = ./api

docs_ui = true                      # Enable docs UI (implies openapi=true)
docs_path = /docs                   # Where to serve the UI
openapi_json_path = /openapi.json   # Where to serve the spec (default)
----

This generates a `zz_generated_openapi.go` file with a `RegisterDocs` function:

[source,go]
----
func main() {
    mux := http.NewServeMux()

    // Register your API endpoints
    api.RegisterRoutes(mux)

    // Register docs UI endpoints
    api.RegisterDocs(mux)

    http.ListenAndServe(":8080", mux)
}
----

Your API documentation will be available at `/docs/`, with the raw OpenAPI spec at `/openapi.json`. The UI is fully self-contained—all assets are embedded in the generated code with no external CDN dependencies.

=== How It Works

The OpenAPI generator reads the discovery manifest that the code generator already produces. This manifest contains:

* Endpoint paths, methods, and handler metadata
* Request/response type information with full field details
* Struct tag bindings (path, query, header, JSON)
* Middleware metadata including possible error responses

Because OpenAPI generation uses the same manifest as code generation, your documentation always matches your implementation. Change a handler's signature or add a new endpoint, and the next generator run updates both the routing code and the API spec.
