= Bootstrap problem: middleware context helpers (Phase 6) “chicken-and-egg” and planned fix
:toc:
:toclevels: 3

== Summary

When a middleware package uses the *generated* typed context helpers (from Phase 6) inside the middleware implementations themselves, you can end up with a circular bootstrap failure:

1. Middleware code calls `reg.Provide("request_id", TypeOf[string]())` (good).
2. Middleware code also calls `WithRequestID(ctx, "...")` (generated helper).
3. On a fresh checkout / first run, `zz_generated_middleware_context.go` does not exist yet.
4. Discovery executes a runner that imports the middleware package to call `RegisterMiddleware(reg)`.
5. The middleware package fails to compile because `WithRequestID` is undefined.
6. Discovery fails => manifest not produced => generation never happens.

This is a classic "generated code needed to compile code that is required to run the generator" problem.

== Why this matters

- It breaks “first run” experience.
- It makes onboarding brittle and confusing.
- It can cause CI failures when generated files are absent or stale.
- It undermines the Phase 6 ergonomics goal (use typed helpers everywhere) because users will avoid them.

== Constraints (from existing design)

- Discovery (Phase 4) currently uses `go run` on a generated runner that imports the API package and optionally the middleware package.
- Middleware registry declarations (`Provide`, `Use`, `Describe`) are executed at runtime by the runner.
- Phase 6 helper generation uses the discovery manifest (`Manifest.ContextKeys`).

Therefore: without *some* compilation path for the middleware package before helpers exist, discovery cannot run.

== Options considered

=== Option A: Document a manual bootstrap workflow (no code changes)

Tell users:
- Write `Provide(...)` declarations.
- Do NOT call `WithX` / `X` / `MustX` until after first generator run.
- Run generator once.
- Then refactor to use generated helpers.

Pros:
- No code changes.

Cons:
- Bad DX; easy to forget; conflicts with “typed helpers everywhere”.
- Breaks “delete generated files then regenerate” workflows.

=== Option B: Generate placeholder/stub helpers that panic

On first run, generate `zz_generated_middleware_context.go` with placeholder implementations.

Pros:
- Middleware compiles; discovery runs.

Cons:
- You still need the manifest to know which keys to generate.
- Unless you introduce a separate source of truth, you can’t create correct stubs before discovery.
- Stub behavior risk: runtime panic if used before regeneration.

=== Option C: Change Phase 2/4 input model (static scanning of `Provide(...)`)

Parse middleware source code to extract `Provide(key, TypeOf[T]())` without compiling.

Pros:
- Avoids runtime execution dependency.

Cons:
- Much more complex (AST+types, evaluation of `TypeOf`).
- Out of scope for current architecture.

=== Option D (recommended): Two-stage/bootstrapping mode for discovery + codegen

Goal:
- Allow generating `zz_generated_middleware_context.go` *without requiring the middleware package to compile*.

Approach:
- In “bootstrap discovery mode”, the runner imports the middleware package but only needs to compile enough to evaluate `RegisterMiddleware`.
- However, importing the package requires compilation. So we must avoid referencing missing symbols during compilation.

The practical way is:
1) Provide a small, stable non-generated fallback API in `portapi` (runtime) that middleware can use *without generated helpers*.
2) Encourage middleware to use this fallback until generated helpers exist, OR make generated helpers call into it.

But the user request suggests we want to keep typed helpers usable inside middleware without manual steps.
So we need an automated bootstrap.

Given Go’s compile model, the only way to make the middleware compile before generation is:
- Ensure middleware source can compile even when generated helpers are missing.

That implies we either:
- Always have a committed/generated file (not desired), or
- Always have a non-generated file providing those helper symbols, or
- Make those symbols not required for compilation (build tags), or
- Have the generator create them before compiling middleware (but that requires keys).

The best fit is a small *non-generated* fallback plus a “first-pass helper generation” that does not require middleware compilation.

== Planned implementation fix (recommended)

Implement a dedicated, explicit “bootstrap” path that unblocks first-run generation with minimal surface area changes:

=== 1) Introduce a “context helper fallback” API in the middleware package template

Add a small, handwritten file pattern users can keep in their middleware package:

- File: `context_fallback.go` (hand-written, not generated)
- It defines untyped helpers based on string keys (or a private key map), e.g.:
  - `func With(ctx context.Context, key string, v any) context.Context`
  - `func Get[T any](ctx context.Context, key string) (T, bool)`

This file is stable and does not depend on generation.
Users can temporarily call:
- `ctx = middleware.With(ctx, "request_id", requestID)`

Then once generated helpers exist, they can migrate to `WithRequestID`.

However, this still leaves a migration step.

=== 2) Add an automatic bootstrap generator mode that creates typed helpers from a config-declared list

To eliminate the migration step, add optional config:

- `[httpgen] context_keys = request_id:string,current_user:*middleware.User,...`

On first run:
- The generator can create `zz_generated_middleware_context.go` from config alone.
- Middleware compiles.
- Discovery runs and produces manifest.
- Subsequent runs ignore config and use discovered keys (or validate they match).

This is explicit but requires duplication.

=== 3) Preferred automated approach: generate helpers by compiling only a tiny registry file

Add a new convention:
- Middleware package contains a separate file (no generated helper usage) that only declares `RegisterMiddleware(reg)` and `Provide(...)`.
- Middleware implementations can use generated helpers, but `RegisterMiddleware` must not.

This works because:
- Discovery imports the package; package compile still sees missing helper references in middleware implementations.

So it *does not work* unless we split packages, use build tags, or otherwise avoid compiling the files that reference helpers.

=== 4) Final recommended approach: build-tag bootstrap for middleware compilation

This is the robust, Go-idiomatic solution:

- Provide build tags to exclude middleware implementation files that reference generated helpers during discovery/bootstrap runs.

Plan:
1. Discovery runner invokes `go run` with a special build tag, e.g. `-tags=portsql_bootstrap`.
2. Middleware implementation files that reference generated helpers are guarded with:
   `//go:build !portsql_bootstrap`
3. A minimal registry-only file (or subset) is guarded with:
   `//go:build portsql_bootstrap`
   and includes:
   - `RegisterMiddleware(reg)` with `Provide(...)`, `Use(...)`, `Describe(...)`
   - NO references to generated helpers

Then:
- Bootstrap discovery runs with `portsql_bootstrap`, compiles only the registry declarations.
- Generator emits `zz_generated_middleware_context.go`.
- Normal builds (no tag) compile full middleware including typed helper usage.

This provides a clean, deterministic, and fully automated bootstrap flow.

== Detailed step-by-step implementation plan

=== Step 0: Add a doc + tests for the bootstrap behavior

1. Add an integration test that sets up a middleware package where:
   - middleware implementation file references `WithRequestID` (generated)
   - registry file under bootstrap tag does not
   - discovery is run with bootstrap tag
2. Assert:
   - manifest includes context keys
   - generator emits `zz_generated_middleware_context.go`
   - normal `go test ./...` passes afterwards

=== Step 1: Extend discovery runner to accept build tags

- Update discovery execution to set `GOFLAGS` or pass `-tags`:
  - `go run -tags=portsql_bootstrap .`
- Ensure deterministic environment and no global side effects.

=== Step 2: Add config support for controlling bootstrap tag (optional)

- Default tag name: `portsql_bootstrap`
- Allow override:
  - `[httpgen] bootstrap_tag = portsql_bootstrap`

=== Step 3: Update demo + documentation

- Demo middleware package includes:
  - `register_bootstrap.go` with `//go:build portsql_bootstrap`
  - `middleware.go` with `//go:build !portsql_bootstrap`
- Demo shows “first run” works without manual steps.

=== Step 4: Error messaging / UX polish

If discovery fails due to missing generated helpers (without bootstrap tag), detect common failure patterns and emit an actionable hint:
- “Your middleware appears to reference generated context helpers before they exist. Use the bootstrap build tag flow: …”

== Risks and mitigations

- Risk: users forget to maintain bootstrap registry file.
  - Mitigation: document best practice; add validation that bootstrap registry declares the same middleware keys as normal builds (future enhancement).

- Risk: additional complexity in build tags.
  - Mitigation: provide copy-pastable template + demo project.

== Rollout plan

1. Add the build-tag bootstrap mechanism in generator/discovery.
2. Add demo app showcasing:
   - middleware registry bootstrap file
   - generated context helpers
   - middleware implementations using typed helpers
3. Add integration tests to freeze behavior.

== Success criteria

- Fresh checkout with no generated files:
  - Running the generator succeeds and creates both `zz_generated_http.go` and `zz_generated_middleware_context.go`.
- Middleware packages can safely use generated typed helpers inside middleware implementations.
- Determinism preserved (no timestamps; stable ordering).
- CI-friendly: no manual bootstrap steps required.
