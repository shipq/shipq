= PortAPI Implementation Plan (TDD-first)
:toc:
:toclevels: 3

This document is the implementation plan for the MVP described in `api/DESIGN.adoc`.

== Scope (MVP)

Implement a Go API system where:

- Feature packages define `Register(app *portapi.App)` and register routes with `app.Get/Post/Put/Delete`.
- A build-time generator *executes* `Register` to discover endpoints and generates a stdlib `net/http` server using `http.ServeMux` method-aware patterns (Go 1.22+).
- Handlers remain pure (no `net/http` import); request binding is via struct tags and response encoding is JSON.

Non-goals (MVP): OpenAPI, middleware, typed clients, CRUD synthesis.

== Key technical decisions (lock early via tests)

- **Go version**: target Go 1.22+ (needs `ServeMux` method patterns and `(*http.Request).PathValue`).
- **Generated entrypoint**: `func NewMux() *http.ServeMux`.
- **Generator configuration**: generator reads a tiny INI config that specifies the root package only (`[httpgen] package = ./api`).
- **Discovery**: generator runs a tiny, generated “discovery runner” `main` that imports the configured root package and calls `root.Register(app)`, then prints a JSON endpoint manifest to stdout. The generator reads that manifest and emits `zz_generated_http.go` into the configured package directory.
- **Runtime helpers**: generated code should be small and stable by calling a `portapi/runtime` helper layer for:
  - handler signature adaptation (4 supported shapes)
  - request binding (path/query/header/json)
  - response encoding + stable error responses

This keeps codegen deterministic and makes the core logic testable without “golden file” brittleness.

== Proposed package / file layout

[source]
----
api/portapi/
  doc.go
  app.go                 # App registry + endpoint recording
  endpoint.go            # Endpoint model and normalization (method/path)
  validate.go            # Reflection-based handler signature + binding validation (during discovery)
  sort.go                # Deterministic ordering

api/portapi/runtime/
  bind.go                # Decode path/query/header/json into request struct
  convert.go             # String -> typed conversion (T, []T, *T)
  respond.go             # JSON success responses, stable error responses
  wrap.go                # Wrap the four handler shapes into http.HandlerFunc

cmd/portsql-api-httpgen/
  main.go                # CLI reads INI: root package only (no flag soup)
  discover.go            # Create temp runner program and execute it
  manifest.go            # Manifest types (JSON) + reading/writing
  generate.go            # Emit zz_generated_http.go from manifest
  format.go              # go/format (gofmt) and deterministic identifiers
----

== Testing strategy (thorough TDD)

We will drive each layer with tests first, keeping feedback loops short:

- **Unit tests** (`go test ./api/...`):
  - No filesystem or external processes.
  - Heavy use of table tests, `httptest`, and `net/url`.
- **Property tests** (`//go:build property`):
  - Use `github.com/shipq/shipq/db/proptest` for seeded, reproducible randomized coverage.
  - Log seeds on failure; re-run via `PROPTEST_SEED=<seed> ...`.
- **Integration tests** (`//go:build integration`):
  - Execute the generator in a temp workspace with a small synthetic root package.
  - Compile the generated file and run HTTP requests against the resulting mux.

== Phase 1: Endpoint model + registry (pure data, easy unit tests)

=== 1.1 Define the core model

Create `Endpoint` with (minimum) fields:

- HTTP method (`GET/POST/PUT/DELETE`)
- route pattern (Go 1.22 method-aware mux patterns, e.g. `"POST /pets/{public_id}"`)
- handler identity (package path + symbol name, for stable sorting)
- request/response type metadata (enough to validate binding and to generate wrappers)

TDD:

- Unit tests for:
  - method normalization and rejection of invalid methods
  - path normalization and rejection of invalid patterns
  - stable string representation used for sorting

=== 1.2 Implement `portapi.App`

Implement:

[source]
----
type App struct { /* records endpoints */ }
func (a *App) Get(path string, handler any)
func (a *App) Post(path string, handler any)
func (a *App) Put(path string, handler any)
func (a *App) Delete(path string, handler any)
----

Behavior:

- Record endpoints; do not attempt any `net/http` work.
- Minimal validation at registration time (method/path non-empty, path begins with `/`).
- Defer deep validation (handler signature, binding) to a dedicated validator step.

TDD:

- Unit tests: registering N endpoints yields the expected list and ordering after sorting.

Property tests:

- Generate random (valid) method/path combinations and assert:
  - recorded endpoints count matches registrations
  - sort order is deterministic (same inputs → same ordered output)

== Phase 2: Handler signature + binding validation (compile-time safety via discovery-time reflection)

Validation happens during discovery runner execution (build-time), using reflection on the handler values.

=== 2.1 Handler signature validator

Support exactly the four shapes from `api/DESIGN.adoc`:

- `func(context.Context, Req) (Resp, error)`
- `func(context.Context, Req) error`
- `func(context.Context) (Resp, error)`
- `func(context.Context) error`

TDD:

- Unit tests with many small local functions exercising:
  - wrong arity
  - missing/extra returns
  - non-`error` final return
  - wrong first arg type
  - variadic and generic edge cases (reject)

Property tests:

- Generate random combinations of “bad” function shapes from a predeclared set and assert they are rejected with stable error messages/codes.

=== 2.2 Binding validator

Validate request struct tags against route pattern rules:

- For each `{x}` in the pattern, require exactly one exported field with `path:"x"`.
- For query binding:
  - `T`, `[]T`, `*T` supported
  - repeated query keys fill slices
  - `*T` is optional, missing key ⇒ `nil`
- For JSON body:
  - If request type has any `json:"..."` field, treat as JSON body request.
  - If request type has no `json:"..."` fields, body is not used in MVP.

TDD:

- Unit tests for:
  - path variables: exact match required; errors for missing/duplicate
  - query binding: scalar, slice, pointer; missing required scalar ⇒ 400
  - header binding: missing required header ⇒ 400
  - json binding: invalid JSON ⇒ 400; wrong content-type handling policy (decide and lock)

Property tests (use `db/proptest`):

- For a fixed set of request struct types, generate random values, encode to query/header/JSON, decode, and assert roundtrip equality.
- Randomly omit optional fields and assert optional pointers become `nil` (and never error).

== Phase 3: Runtime HTTP glue helpers (unit-testable, minimal generated code)

Implement in `api/portapi/runtime`:

=== 3.1 Request binding

`bind.go`:

- `Bind[Req any](r *http.Request) (Req, *Error)` (or non-generic equivalent)
- Pull values from:
  - `r.PathValue("x")`
  - `r.URL.Query()`
  - `r.Header.Get("X-...")`
  - JSON body via `encoding/json`

`convert.go`:

- Convert strings into supported types (`string`, `int`, `int64`, `bool`, `float64`, `time.Time`, and named aliases of these).
- Convert slices and pointers according to MVP rules.

TDD:

- Unit tests around conversion edge cases:
  - empty string to numeric/bool should fail (400)
  - overflow behavior (400)
  - repeated query keys for slices preserves order
  - time parsing policy (choose one format, lock it with tests; default suggestion: RFC3339)

Property tests:

- Random valid `int64/bool/float64` values → string → parse → equal.
- Random invalid strings (including `EdgeCaseString`) for numeric/bool/time inputs always produce a *binding error* (never panic).

=== 3.2 Response encoding + stable errors

`respond.go`:

- For `Resp` returns: status 200, `Content-Type: application/json`, JSON body.
- For `error`-only handlers: status 204, empty body.
- Errors:
  - binding/decoding errors: 400 with a minimal stable JSON payload
  - handler errors: 500 with a minimal stable JSON payload

Define a stable error payload now (MVP), e.g.:

[source]
----
{ "error": { "code": "bad_request", "message": "..." } }
----

TDD:

- Unit tests for headers/status/body for each handler shape and error case.
- Property tests to ensure error JSON is always valid JSON and never empty for error responses.

=== 3.3 Handler wrappers

`wrap.go`:

- `WrapCtxReqResp`, `WrapCtxReqErr`, `WrapCtxResp`, `WrapCtxErr` (names TBD)
- Each wrapper:
  - creates `context.Context` from `r.Context()`
  - binds `Req` if applicable
  - calls the pure handler
  - writes success/error response using `respond.go`

TDD:

- Unit tests using `httptest.NewRecorder` for each wrapper shape.

== Phase 4: Generator (discovery + deterministic codegen)

=== 4.0 Config (INI)

The generator reads config via INI with exactly one required key:

[source,ini]
----
[httpgen]
package = ./api
----

Search order (first match wins):

- `$PORTSQL_API_HTTPGEN_CONFIG` if set (path to an INI file)
- `./portsql-api-httpgen.ini` in the current directory (where `go:generate` runs)

Behavior:

- Missing config: fail with a clear error describing the expected filename and keys.
- Missing `[httpgen]` or missing `package`: fail with a clear error.

=== 4.1 Manifest format

Define a JSON manifest produced by discovery runner containing:

- endpoints (method, path)
- handler identity (import path + symbol)
- handler “shape” (which of the 4 supported signatures)
- request/response type strings as needed for codegen (and imports)

TDD:

- Unit tests for JSON roundtrip (marshal/unmarshal) and stable ordering.

=== 4.2 Discovery runner execution

Implement:

- Generator writes a temp directory with:
  - `go.mod` (or uses the repo module) and a `main.go` that imports the configured root package and `api/portapi`
  - calls `root.Register(app)` and runs the validator
  - prints manifest JSON to stdout
- Generator executes `go run` for that runner and captures stdout/stderr.

TDD:

- Integration tests with a synthetic root package under a temp module:
  - valid handlers produce a manifest
  - invalid handlers fail with a clear, stable error message

=== 4.3 Code generation (`zz_generated_http.go`)

Generator emits:

- a DO NOT EDIT header
- package declaration derived from the configured root package directory (no package override in the MVP)
- imports (only what is needed)
- `func NewMux() *http.ServeMux` that registers:
  - `mux.HandleFunc("<METHOD> <PATH>", runtime.Wrap...(handlerSymbol))`

Output location:

- Always write `zz_generated_http.go` into the configured root package directory.

Determinism requirements:

- sort endpoints by method + path + handler identity before emission
- stable import ordering
- stable wrapper naming rules (no randomness)
- run `gofmt` on output

TDD:

- Golden tests for small fixed manifests.

Property tests:

- Randomly generated manifests (within constraints) must produce:
  - gofmt-able output
  - Go-parseable output (`go/parser`)
  - deterministic output: generating twice yields identical bytes

== Phase 5: End-to-end integration tests (generated mux works)

Add a minimal example root package used only by tests:

- `Register(app)` registers a few endpoints covering all four handler shapes and all binding sources (path/query/header/json).

Integration tests (`//go:build integration`):

- Run generator → compile → call `NewMux()` → send HTTP requests via `httptest`.
- Assert:
  - correct routing/method matching
  - correct binding behavior
  - correct status codes and JSON responses
  - handler errors become 500

Property tests (required):

- For a fixed set of endpoints, generate random request values (query/header/json) and assert roundtrip invariants.

== Running the tests

[source,bash]
----
# Unit tests
go test ./api/...

# Property tests
go test -tags=property ./api/...
PROPTEST_SEED=12345 go test -tags=property ./api/... -run TestProperty_

# Integration tests (generator + build + HTTP)
go test -tags=integration ./api/...
----

== Deliverables checklist (MVP “done”)

- `portapi.App` supports `Get/Post/Put/Delete` and records endpoints.
- Validator enforces the 4 handler shapes and binding/tag constraints.
- Generator `cmd/portsql-api-httpgen` produces deterministic `zz_generated_http.go`.
- Generated `NewMux()` registers method-aware mux patterns and works on Go 1.22+.
- Comprehensive unit tests + targeted integration tests.
- Property tests using `db/proptest` for determinism and binding conversion robustness.
