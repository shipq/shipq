package cli

import (
	"strings"
	"testing"
)

// TestMiddlewareContextGeneration_Snapshot is a golden/snapshot test that freezes the exact output format.
// This test documents the stable contract and catches any unintended changes to the generation logic.
//
// NOTE: As of the capability-token redesign (Phase 3), generated helpers now use the stable
// portapi.WithTyped/GetTyped/MustTyped functions instead of per-key context types. This ensures
// interoperability between generated helpers and capability tokens (Cap[T]).
func TestMiddlewareContextGeneration_Snapshot(t *testing.T) {
	keys := []ManifestContextKey{
		{Key: "request_id", Type: "string"},
		{Key: "user_id", Type: "int64"},
		{Key: "current_user", Type: "*User"},
		{Key: "api_key", Type: "string"},
	}

	// Generate the context file
	code, err := generateMiddlewareContextFile("middleware", keys)
	if err != nil {
		t.Fatalf("generateMiddlewareContextFile failed: %v", err)
	}

	// The expected output is deterministic and stable
	// Uses portapi.WithTyped/GetTyped/MustTyped for interop with capability tokens
	expected := `// Code generated by shipq api. DO NOT EDIT.

package middleware

import (
	"context"

	"github.com/shipq/shipq/api/portapi"
)

// WithAPIKey returns a new context with the given value stored.
// Uses the stable portapi context store for interoperability with capability tokens.
func WithAPIKey(ctx context.Context, v string) context.Context {
	return portapi.WithTyped(ctx, "api_key", v)
}

// APIKey retrieves the value from the context.
// Returns (value, true) if present, or (zero, false) if not present.
// Uses the stable portapi context store for interoperability with capability tokens.
func APIKey(ctx context.Context) (string, bool) {
	return portapi.GetTyped[string](ctx, "api_key")
}

// MustAPIKey retrieves the value from the context.
// Panics if the value is not present.
// Uses the stable portapi context store for interoperability with capability tokens.
func MustAPIKey(ctx context.Context) string {
	return portapi.MustTyped[string](ctx, "api_key")
}

// WithCurrentUser returns a new context with the given value stored.
// Uses the stable portapi context store for interoperability with capability tokens.
func WithCurrentUser(ctx context.Context, v *User) context.Context {
	return portapi.WithTyped(ctx, "current_user", v)
}

// CurrentUser retrieves the value from the context.
// Returns (value, true) if present, or (zero, false) if not present.
// Uses the stable portapi context store for interoperability with capability tokens.
func CurrentUser(ctx context.Context) (*User, bool) {
	return portapi.GetTyped[*User](ctx, "current_user")
}

// MustCurrentUser retrieves the value from the context.
// Panics if the value is not present.
// Uses the stable portapi context store for interoperability with capability tokens.
func MustCurrentUser(ctx context.Context) *User {
	return portapi.MustTyped[*User](ctx, "current_user")
}

// WithRequestID returns a new context with the given value stored.
// Uses the stable portapi context store for interoperability with capability tokens.
func WithRequestID(ctx context.Context, v string) context.Context {
	return portapi.WithTyped(ctx, "request_id", v)
}

// RequestID retrieves the value from the context.
// Returns (value, true) if present, or (zero, false) if not present.
// Uses the stable portapi context store for interoperability with capability tokens.
func RequestID(ctx context.Context) (string, bool) {
	return portapi.GetTyped[string](ctx, "request_id")
}

// MustRequestID retrieves the value from the context.
// Panics if the value is not present.
// Uses the stable portapi context store for interoperability with capability tokens.
func MustRequestID(ctx context.Context) string {
	return portapi.MustTyped[string](ctx, "request_id")
}

// WithUserID returns a new context with the given value stored.
// Uses the stable portapi context store for interoperability with capability tokens.
func WithUserID(ctx context.Context, v int64) context.Context {
	return portapi.WithTyped(ctx, "user_id", v)
}

// UserID retrieves the value from the context.
// Returns (value, true) if present, or (zero, false) if not present.
// Uses the stable portapi context store for interoperability with capability tokens.
func UserID(ctx context.Context) (int64, bool) {
	return portapi.GetTyped[int64](ctx, "user_id")
}

// MustUserID retrieves the value from the context.
// Panics if the value is not present.
// Uses the stable portapi context store for interoperability with capability tokens.
func MustUserID(ctx context.Context) int64 {
	return portapi.MustTyped[int64](ctx, "user_id")
}
`

	if code != expected {
		t.Errorf("Generated code does not match expected snapshot.\n\nExpected:\n%s\n\nGot:\n%s", expected, code)

		// Show a diff-like output for easier debugging
		expectedLines := strings.Split(expected, "\n")
		gotLines := strings.Split(code, "\n")

		maxLines := len(expectedLines)
		if len(gotLines) > maxLines {
			maxLines = len(gotLines)
		}

		for i := 0; i < maxLines; i++ {
			var expLine, gotLine string
			if i < len(expectedLines) {
				expLine = expectedLines[i]
			}
			if i < len(gotLines) {
				gotLine = gotLines[i]
			}

			if expLine != gotLine {
				t.Logf("Line %d differs:", i+1)
				t.Logf("  Expected: %q", expLine)
				t.Logf("  Got:      %q", gotLine)
			}
		}
	}
}

// TestMiddlewareContextGeneration_SnapshotWithPackageQualifiedTypes tests that
// types with package qualifiers are handled correctly.
func TestMiddlewareContextGeneration_SnapshotWithPackageQualifiedTypes(t *testing.T) {
	keys := []ManifestContextKey{
		{Key: "db_conn", Type: "*sql.DB"},
		{Key: "logger", Type: "*slog.Logger"},
	}

	// Generate the context file
	code, err := generateMiddlewareContextFile("middleware", keys)
	if err != nil {
		t.Fatalf("generateMiddlewareContextFile failed: %v", err)
	}

	// Types from external packages should keep their package qualifier
	// Now using portapi.WithTyped/GetTyped/MustTyped
	expectedContains := []string{
		"func WithDbConn(ctx context.Context, v *sql.DB) context.Context",
		"func DbConn(ctx context.Context) (*sql.DB, bool)",
		`portapi.GetTyped[*sql.DB](ctx, "db_conn")`,
		"func WithLogger(ctx context.Context, v *slog.Logger) context.Context",
		"func Logger(ctx context.Context) (*slog.Logger, bool)",
		`portapi.GetTyped[*slog.Logger](ctx, "logger")`,
	}

	for _, expected := range expectedContains {
		if !strings.Contains(code, expected) {
			t.Errorf("Generated code missing expected content:\n%s\n\nGenerated code:\n%s", expected, code)
		}
	}
}

// TestMiddlewareContextGeneration_InitialismHandling verifies that common initialisms
// are properly uppercased in generated function names.
func TestMiddlewareContextGeneration_InitialismHandling(t *testing.T) {
	tests := []struct {
		key              string
		expectedWithFunc string
		expectedGetFunc  string
		expectedMustFunc string
	}{
		{
			key:              "api_key",
			expectedWithFunc: "func WithAPIKey(ctx context.Context, v string) context.Context",
			expectedGetFunc:  "func APIKey(ctx context.Context) (string, bool)",
			expectedMustFunc: "func MustAPIKey(ctx context.Context) string",
		},
		{
			key:              "user_id",
			expectedWithFunc: "func WithUserID(ctx context.Context, v string) context.Context",
			expectedGetFunc:  "func UserID(ctx context.Context) (string, bool)",
			expectedMustFunc: "func MustUserID(ctx context.Context) string",
		},
		{
			key:              "http_client",
			expectedWithFunc: "func WithHTTPClient(ctx context.Context, v string) context.Context",
			expectedGetFunc:  "func HTTPClient(ctx context.Context) (string, bool)",
			expectedMustFunc: "func MustHTTPClient(ctx context.Context) string",
		},
		{
			key:              "json_data",
			expectedWithFunc: "func WithJSONData(ctx context.Context, v string) context.Context",
			expectedGetFunc:  "func JSONData(ctx context.Context) (string, bool)",
			expectedMustFunc: "func MustJSONData(ctx context.Context) string",
		},
	}

	for _, tt := range tests {
		t.Run(tt.key, func(t *testing.T) {
			keys := []ManifestContextKey{
				{Key: tt.key, Type: "string"},
			}

			code, err := generateMiddlewareContextFile("middleware", keys)
			if err != nil {
				t.Fatalf("generateMiddlewareContextFile failed: %v", err)
			}

			expectedParts := []string{
				tt.expectedWithFunc,
				tt.expectedGetFunc,
				tt.expectedMustFunc,
			}

			for _, expected := range expectedParts {
				if !strings.Contains(code, expected) {
					t.Errorf("Generated code missing expected content:\n%s\n\nGenerated code:\n%s", expected, code)
				}
			}
		})
	}
}
