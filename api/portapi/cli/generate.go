package cli

import (
	"bytes"
	"fmt"
	"go/format"
	"path"
	"sort"
	"strings"
	"text/template"
)

// templateData holds data for the code generation template.
type templateData struct {
	Package         string
	Imports         []string
	Endpoints       []templateEndpoint
	Helpers         templateHelpers
	HasMiddleware   bool
	MiddlewarePkg   string
	MiddlewareAlias string
}

// templateEndpoint holds data for a single endpoint in the template.
type templateEndpoint struct {
	Pattern         string // e.g., "GET /pets"
	HandlerName     string // e.g., "Get"
	HandlerPkgPath  string // import path
	HandlerRef      string // e.g., "pets.Get"
	Shape           string // ctx_req_resp_err, etc.
	ReqType         string // short type name for request
	RespType        string // short type name for response
	HasRequest      bool
	HasResponse     bool
	IsSliceResponse bool // true if response type starts with []
	Bindings        *BindingInfo
	Middlewares     []string // middleware references like "mw.Logger"
}

// templateHelpers tracks which parsing helpers are needed.
type templateHelpers struct {
	NeedsBool    bool
	NeedsInt     bool
	NeedsInt8    bool
	NeedsInt16   bool
	NeedsInt32   bool
	NeedsInt64   bool
	NeedsUint    bool
	NeedsUint8   bool
	NeedsUint16  bool
	NeedsUint32  bool
	NeedsUint64  bool
	NeedsFloat32 bool
	NeedsFloat64 bool
	NeedsTime    bool
}

// parserForType returns the parser function name for a given type kind.
// Returns empty string for types that don't need parsing (string).
func parserForType(typeKind string) string {
	switch typeKind {
	case "string":
		return ""
	case "bool":
		return "parseBool"
	case "int":
		return "parseInt"
	case "int8":
		return "parseInt8"
	case "int16":
		return "parseInt16"
	case "int32":
		return "parseInt32"
	case "int64":
		return "parseInt64"
	case "uint":
		return "parseUint"
	case "uint8":
		return "parseUint8"
	case "uint16":
		return "parseUint16"
	case "uint32":
		return "parseUint32"
	case "uint64":
		return "parseUint64"
	case "float32":
		return "parseFloat32"
	case "float64":
		return "parseFloat64"
	case "time.Time":
		return "parseTime"
	default:
		return ""
	}
}

// goTypeForKind returns the Go type for a type kind (for slice element declarations).
func goTypeForKind(kind string) string {
	if kind == "time.Time" {
		return "time.Time"
	}
	return kind
}

var templateFuncs = template.FuncMap{
	"parserForType": parserForType,
	"goTypeForKind": goTypeForKind,
}

var mainTmpl = template.Must(template.New("main").Funcs(templateFuncs).Parse(`// Code generated by shipq api. DO NOT EDIT.

package {{.Package}}

import (
{{- if .HasMiddleware}}
	"context"
{{- end}}
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
{{- if .Helpers.NeedsInt}}
	"strconv"
{{- else if .Helpers.NeedsInt8}}
	"strconv"
{{- else if .Helpers.NeedsInt16}}
	"strconv"
{{- else if .Helpers.NeedsInt32}}
	"strconv"
{{- else if .Helpers.NeedsInt64}}
	"strconv"
{{- else if .Helpers.NeedsUint}}
	"strconv"
{{- else if .Helpers.NeedsUint8}}
	"strconv"
{{- else if .Helpers.NeedsUint16}}
	"strconv"
{{- else if .Helpers.NeedsUint32}}
	"strconv"
{{- else if .Helpers.NeedsUint64}}
	"strconv"
{{- else if .Helpers.NeedsFloat32}}
	"strconv"
{{- else if .Helpers.NeedsFloat64}}
	"strconv"
{{- end}}
{{- if .Helpers.NeedsTime}}
	"time"
{{- end}}
{{- if .HasMiddleware}}

	"github.com/shipq/shipq/api/portapi"
{{- end}}
{{range .Imports}}
	{{.}}
{{- end}}
)

// BindError represents an error that occurred during request binding.
type BindError struct {
	Source string // "path", "query", "header", "body"
	Field  string
	Err    error
}

func (e *BindError) Error() string {
	if e.Field != "" {
		return fmt.Sprintf("%s %s: %s", e.Source, e.Field, e.Err.Error())
	}
	return fmt.Sprintf("%s: %s", e.Source, e.Err.Error())
}

func (e *BindError) Unwrap() error {
	return e.Err
}

var errMissing = errors.New("missing required value")

// ErrorResponse is the standard error response structure.
type ErrorResponse struct {
	Error ErrorDetail ` + "`json:\"error\"`" + `
}

// ErrorDetail contains the error code and message.
type ErrorDetail struct {
	Code    string ` + "`json:\"code\"`" + `
	Message string ` + "`json:\"message\"`" + `
}

func writeJSON(w http.ResponseWriter, status int, data any) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	_ = json.NewEncoder(w).Encode(data)
}

func writeError(w http.ResponseWriter, err error) {
	status := http.StatusInternalServerError
	code := "internal_error"
	message := err.Error()

	var bindErr *BindError
	if errors.As(err, &bindErr) {
		status = http.StatusBadRequest
		code = "bad_request"
	}

	// Check for CodedError interface
	type codedError interface {
		StatusCode() int
		ErrorCode() string
	}
	var ce codedError
	if errors.As(err, &ce) {
		status = ce.StatusCode()
		code = ce.ErrorCode()
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	_ = json.NewEncoder(w).Encode(ErrorResponse{
		Error: ErrorDetail{
			Code:    code,
			Message: message,
		},
	})
}

{{- if .HasMiddleware}}

// zzChain builds a middleware chain in the correct execution order.
func zzChain(req *portapi.Request, mws []portapi.Middleware, final portapi.Next) portapi.Next {
	if len(mws) == 0 {
		return final
	}

	// Build chain in reverse order so first middleware wraps all others
	next := final
	for i := len(mws) - 1; i >= 0; i-- {
		mw := mws[i]
		if mw == nil {
			// Treat nil middleware as internal error
			return func(ctx context.Context) (portapi.HandlerResult, error) {
				return portapi.HandlerResult{}, errors.New("nil middleware in chain")
			}
		}
		// Capture loop variables properly
		currentMw := mw
		prevNext := next
		next = func(ctx context.Context) (portapi.HandlerResult, error) {
			return currentMw(ctx, req, prevNext)
		}
	}
	return next
}

// writeResult writes a HandlerResult to the response.
func writeResult(w http.ResponseWriter, res portapi.HandlerResult) error {
	// Validate result
	if err := res.Validate(); err != nil {
		// Invalid result - treat as internal error
		writeError(w, fmt.Errorf("invalid handler result: %w", err))
		return err
	}

	if res.NoContent {
		status := res.Status
		if status == 0 {
			status = http.StatusNoContent
		}
		w.WriteHeader(status)
		return nil
	}

	if res.JSON != nil {
		status := res.Status
		if status == 0 {
			status = http.StatusOK
		}
		writeJSON(w, status, res.JSON)
		return nil
	}

	// Empty result - treat as 204
	w.WriteHeader(http.StatusNoContent)
	return nil
}
{{- end}}

{{- if .Helpers.NeedsBool}}

func parseBool(s string) (bool, error) {
	switch s {
	case "true", "True", "TRUE", "1":
		return true, nil
	case "false", "False", "FALSE", "0":
		return false, nil
	default:
		return false, errors.New("invalid bool: " + s)
	}
}
{{- end}}

{{- if .Helpers.NeedsInt}}

func parseInt(s string) (int, error) {
	return strconv.Atoi(s)
}
{{- end}}

{{- if .Helpers.NeedsInt8}}

func parseInt8(s string) (int8, error) {
	v, err := strconv.ParseInt(s, 10, 8)
	if err != nil {
		return 0, err
	}
	return int8(v), nil
}
{{- end}}

{{- if .Helpers.NeedsInt16}}

func parseInt16(s string) (int16, error) {
	v, err := strconv.ParseInt(s, 10, 16)
	if err != nil {
		return 0, err
	}
	return int16(v), nil
}
{{- end}}

{{- if .Helpers.NeedsInt32}}

func parseInt32(s string) (int32, error) {
	v, err := strconv.ParseInt(s, 10, 32)
	if err != nil {
		return 0, err
	}
	return int32(v), nil
}
{{- end}}

{{- if .Helpers.NeedsInt64}}

func parseInt64(s string) (int64, error) {
	return strconv.ParseInt(s, 10, 64)
}
{{- end}}

{{- if .Helpers.NeedsUint}}

func parseUint(s string) (uint, error) {
	v, err := strconv.ParseUint(s, 10, 64)
	if err != nil {
		return 0, err
	}
	return uint(v), nil
}
{{- end}}

{{- if .Helpers.NeedsUint8}}

func parseUint8(s string) (uint8, error) {
	v, err := strconv.ParseUint(s, 10, 8)
	if err != nil {
		return 0, err
	}
	return uint8(v), nil
}
{{- end}}

{{- if .Helpers.NeedsUint16}}

func parseUint16(s string) (uint16, error) {
	v, err := strconv.ParseUint(s, 10, 16)
	if err != nil {
		return 0, err
	}
	return uint16(v), nil
}
{{- end}}

{{- if .Helpers.NeedsUint32}}

func parseUint32(s string) (uint32, error) {
	v, err := strconv.ParseUint(s, 10, 32)
	if err != nil {
		return 0, err
	}
	return uint32(v), nil
}
{{- end}}

{{- if .Helpers.NeedsUint64}}

func parseUint64(s string) (uint64, error) {
	return strconv.ParseUint(s, 10, 64)
}
{{- end}}

{{- if .Helpers.NeedsFloat32}}

func parseFloat32(s string) (float32, error) {
	v, err := strconv.ParseFloat(s, 32)
	if err != nil {
		return 0, err
	}
	return float32(v), nil
}
{{- end}}

{{- if .Helpers.NeedsFloat64}}

func parseFloat64(s string) (float64, error) {
	return strconv.ParseFloat(s, 64)
}
{{- end}}

{{- if .Helpers.NeedsTime}}

func parseTime(s string) (time.Time, error) {
	return time.Parse(time.RFC3339, s)
}
{{- end}}

{{range .Endpoints}}
{{- if .HasRequest}}
{{template "binder" .}}
{{end}}
{{template "handler" .}}
{{end}}

func NewMux() *http.ServeMux {
	mux := http.NewServeMux()
{{range .Endpoints}}
	mux.Handle("{{.Pattern}}", handle{{.HandlerName}}())
{{- end}}
	return mux
}
`))

var binderTmpl = template.Must(mainTmpl.New("binder").Parse(`
func bind{{.HandlerName}}(r *http.Request) ({{.ReqType}}, error) {
	var req {{.ReqType}}
{{- if .Bindings}}
{{- if .Bindings.PathBindings}}

	// Path bindings
{{- range .Bindings.PathBindings}}
	{
		v := r.PathValue("{{.TagValue}}")
		if v == "" {
			return req, &BindError{Source: "path", Field: "{{.TagValue}}", Err: errMissing}
		}
{{- $parser := parserForType .TypeKind}}
{{- if $parser}}
		parsed, err := {{$parser}}(v)
		if err != nil {
			return req, &BindError{Source: "path", Field: "{{.TagValue}}", Err: err}
		}
		req.{{.FieldName}} = parsed
{{- else}}
		req.{{.FieldName}} = v
{{- end}}
	}
{{- end}}
{{- end}}
{{- if .Bindings.QueryBindings}}

	// Query bindings
	q := r.URL.Query()
{{- range .Bindings.QueryBindings}}
{{- if .IsPointer}}
	if q.Has("{{.TagValue}}") {
		s := q.Get("{{.TagValue}}")
{{- $parser := parserForType .TypeKind}}
{{- if $parser}}
		parsed, err := {{$parser}}(s)
		if err != nil {
			return req, &BindError{Source: "query", Field: "{{.TagValue}}", Err: err}
		}
		req.{{.FieldName}} = &parsed
{{- else}}
		req.{{.FieldName}} = &s
{{- end}}
	}
{{- else if .IsSlice}}
	if vs, ok := q["{{.TagValue}}"]; ok && len(vs) > 0 {
{{- $parser := parserForType .ElemKind}}
{{- if $parser}}
		slice := make([]{{goTypeForKind .ElemKind}}, len(vs))
		for i, s := range vs {
			parsed, err := {{$parser}}(s)
			if err != nil {
				return req, &BindError{Source: "query", Field: "{{.TagValue}}", Err: err}
			}
			slice[i] = parsed
		}
		req.{{.FieldName}} = slice
{{- else}}
		req.{{.FieldName}} = vs
{{- end}}
	}
{{- else}}
	if !q.Has("{{.TagValue}}") {
		return req, &BindError{Source: "query", Field: "{{.TagValue}}", Err: errMissing}
	}
	{
		s := q.Get("{{.TagValue}}")
{{- $parser := parserForType .TypeKind}}
{{- if $parser}}
		parsed, err := {{$parser}}(s)
		if err != nil {
			return req, &BindError{Source: "query", Field: "{{.TagValue}}", Err: err}
		}
		req.{{.FieldName}} = parsed
{{- else}}
		req.{{.FieldName}} = s
{{- end}}
	}
{{- end}}
{{- end}}
{{- end}}
{{- if .Bindings.HeaderBindings}}

	// Header bindings
{{- range .Bindings.HeaderBindings}}
{{- if .IsPointer}}
	if h := r.Header.Get("{{.TagValue}}"); h != "" {
{{- $parser := parserForType .TypeKind}}
{{- if $parser}}
		parsed, err := {{$parser}}(h)
		if err != nil {
			return req, &BindError{Source: "header", Field: "{{.TagValue}}", Err: err}
		}
		req.{{.FieldName}} = &parsed
{{- else}}
		req.{{.FieldName}} = &h
{{- end}}
	}
{{- else}}
	{
		h := r.Header.Get("{{.TagValue}}")
		if h == "" {
			return req, &BindError{Source: "header", Field: "{{.TagValue}}", Err: errMissing}
		}
{{- $parser := parserForType .TypeKind}}
{{- if $parser}}
		parsed, err := {{$parser}}(h)
		if err != nil {
			return req, &BindError{Source: "header", Field: "{{.TagValue}}", Err: err}
		}
		req.{{.FieldName}} = parsed
{{- else}}
		req.{{.FieldName}} = h
{{- end}}
	}
{{- end}}
{{- end}}
{{- end}}
{{- if .Bindings.HasJSONBody}}

	// JSON body binding
	if r.Body == nil {
		return req, &BindError{Source: "body", Err: errMissing}
	}
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		return req, &BindError{Source: "body", Err: err}
	}
{{- end}}
{{- end}}

	return req, nil
}
`))

var handlerTmpl = template.Must(mainTmpl.New("handler").Parse(`
func handle{{.HandlerName}}() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
{{- if .Middlewares}}
		// Initialize decoded request storage
		var zzDecoded any
		var zzDecodedOK bool

		// Build request view
		reqView := &portapi.Request{
			Method:  r.Method,
			Pattern: "{{.Pattern}}",
			Header: func(name string) (string, bool) {
				v := r.Header.Get(name)
				return v, v != ""
			},
			Cookie: func(name string) (string, bool) {
				c, err := r.Cookie(name)
				if err != nil {
					return "", false
				}
				return c.Value, true
			},
			Query: func(name string) []string {
				return r.URL.Query()[name]
			},
			PathValue: func(name string) string {
				return r.PathValue(name)
			},
			DecodedReq: func() (any, bool) {
				return zzDecoded, zzDecodedOK
			},
		}

		// Build the final handler that performs binding and calls the handler
		final := func(ctx context.Context) (portapi.HandlerResult, error) {
{{- if .HasRequest}}
			req, err := bind{{.HandlerName}}(r)
			if err != nil {
				return portapi.HandlerResult{}, err
			}

			// Mark decoded request as available
			zzDecoded = req
			zzDecodedOK = true

{{- end}}
{{- if eq .Shape "ctx_req_resp_err"}}
			resp, err := {{.HandlerRef}}(ctx, req)
			if err != nil {
				return portapi.HandlerResult{}, err
			}
{{- if .IsSliceResponse}}
			if resp == nil {
				resp = {{.RespType}}{}
			}
{{- end}}
			return portapi.HandlerResult{JSON: resp}, nil
{{- else if eq .Shape "ctx_req_err"}}
			if err := {{.HandlerRef}}(ctx, req); err != nil {
				return portapi.HandlerResult{}, err
			}
			return portapi.HandlerResult{NoContent: true}, nil
{{- else if eq .Shape "ctx_resp_err"}}
			resp, err := {{.HandlerRef}}(ctx)
			if err != nil {
				return portapi.HandlerResult{}, err
			}
{{- if .IsSliceResponse}}
			if resp == nil {
				resp = {{.RespType}}{}
			}
{{- end}}
			return portapi.HandlerResult{JSON: resp}, nil
{{- else if eq .Shape "ctx_err"}}
			if err := {{.HandlerRef}}(ctx); err != nil {
				return portapi.HandlerResult{}, err
			}
			return portapi.HandlerResult{NoContent: true}, nil
{{- end}}
		}

		// Build middleware chain
		mws := []portapi.Middleware{ {{- range .Middlewares}}{{.}}, {{end -}} }
		next := zzChain(reqView, mws, final)

		// Execute chain
		result, err := next(r.Context())
		if err != nil {
			writeError(w, err)
			return
		}

		// Write result
		if err := writeResult(w, result); err != nil {
			return
		}
{{- else}}
{{- if .HasRequest}}
		req, err := bind{{.HandlerName}}(r)
		if err != nil {
			writeError(w, err)
			return
		}

{{- end}}
{{- if eq .Shape "ctx_req_resp_err"}}
		resp, err := {{.HandlerRef}}(r.Context(), req)
		if err != nil {
			writeError(w, err)
			return
		}
{{- if .IsSliceResponse}}
		if resp == nil {
			resp = {{.RespType}}{}
		}
{{- end}}
		writeJSON(w, http.StatusOK, resp)
{{- else if eq .Shape "ctx_req_err"}}
		if err := {{.HandlerRef}}(r.Context(), req); err != nil {
			writeError(w, err)
			return
		}
		w.WriteHeader(http.StatusNoContent)
{{- else if eq .Shape "ctx_resp_err"}}
		resp, err := {{.HandlerRef}}(r.Context())
		if err != nil {
			writeError(w, err)
			return
		}
{{- if .IsSliceResponse}}
		if resp == nil {
			resp = {{.RespType}}{}
		}
{{- end}}
		writeJSON(w, http.StatusOK, resp)
{{- else if eq .Shape "ctx_err"}}
		if err := {{.HandlerRef}}(r.Context()); err != nil {
			writeError(w, err)
			return
		}
		w.WriteHeader(http.StatusNoContent)
{{- end}}
{{- end}}
	})
}
`))

// Generate produces Go source code that creates an http.ServeMux with all
// registered endpoints from the manifest.
// targetPkgPath is the full import path of the package being generated (e.g., "example.com/app/api")
// to avoid importing itself.
func Generate(m Manifest, pkgName string, targetPkgPath string) (string, error) {
	// 1. Sort endpoints for determinism (by path, method, handler pkg, handler name, shape)
	endpoints := make([]ManifestEndpoint, len(m.Endpoints))
	copy(endpoints, m.Endpoints)
	sort.Slice(endpoints, func(i, j int) bool {
		if endpoints[i].Path != endpoints[j].Path {
			return endpoints[i].Path < endpoints[j].Path
		}
		if endpoints[i].Method != endpoints[j].Method {
			return endpoints[i].Method < endpoints[j].Method
		}
		if endpoints[i].HandlerPkg != endpoints[j].HandlerPkg {
			return endpoints[i].HandlerPkg < endpoints[j].HandlerPkg
		}
		if endpoints[i].HandlerName != endpoints[j].HandlerName {
			return endpoints[i].HandlerName < endpoints[j].HandlerName
		}
		if endpoints[i].Shape != endpoints[j].Shape {
			return endpoints[i].Shape < endpoints[j].Shape
		}
		if endpoints[i].ReqType != endpoints[j].ReqType {
			return endpoints[i].ReqType < endpoints[j].ReqType
		}
		return endpoints[i].RespType < endpoints[j].RespType
	})

	// 2. Collect unique imports and determine which helpers are needed
	importSet := make(map[string]string) // import path -> alias
	helpers := templateHelpers{}
	hasMiddleware := false
	middlewarePkg := ""
	middlewareAlias := ""

	// Check if manifest has middleware
	if len(m.Middlewares) > 0 && len(m.Middlewares[0].Pkg) > 0 {
		hasMiddleware = true
		middlewarePkg = m.Middlewares[0].Pkg
		middlewareAlias = path.Base(middlewarePkg)
		importSet[middlewarePkg] = middlewareAlias
	}

	for _, ep := range endpoints {
		// Skip importing the target package (avoid self-import)
		if ep.HandlerPkg != "" && ep.HandlerPkg != targetPkgPath {
			alias := path.Base(ep.HandlerPkg)
			importSet[ep.HandlerPkg] = alias
		}

		// Analyze bindings to determine which parse helpers are needed
		if ep.Bindings != nil {
			collectRequiredHelpers(ep.Bindings, &helpers)
		}

		// Check if endpoint has middleware
		if len(ep.Middlewares) > 0 {
			hasMiddleware = true
		}
	}

	// Build sorted import list for determinism
	var importPaths []string
	for p := range importSet {
		importPaths = append(importPaths, p)
	}
	sort.Strings(importPaths)

	var imports []string
	for _, p := range importPaths {
		alias := importSet[p]
		imports = append(imports, fmt.Sprintf("%s %q", alias, p))
	}

	// 3. Build template endpoints
	var tmplEndpoints []templateEndpoint
	for _, ep := range endpoints {
		pattern := ep.Method + " " + ep.Path

		// Determine handler reference
		var handlerRef string
		if ep.HandlerPkg == targetPkgPath {
			// Handler is in the same package as generated code
			handlerRef = ep.HandlerName
		} else {
			alias := importSet[ep.HandlerPkg]
			handlerRef = alias + "." + ep.HandlerName
		}

		// Extract short type names for req/resp
		reqType := extractShortTypeName(ep.ReqType, importSet)
		respType := extractShortTypeName(ep.RespType, importSet)

		hasRequest := ep.Shape == "ctx_req_resp_err" || ep.Shape == "ctx_req_err"
		hasResponse := ep.Shape == "ctx_req_resp_err" || ep.Shape == "ctx_resp_err"

		// Detect if response is a slice type
		isSliceResponse := strings.HasPrefix(ep.RespType, "[]")

		// Build middleware references for this endpoint
		var mwRefs []string
		for _, mw := range ep.Middlewares {
			mwAlias := importSet[mw.Pkg]
			mwRefs = append(mwRefs, mwAlias+"."+mw.Name)
		}

		tmplEndpoints = append(tmplEndpoints, templateEndpoint{
			Pattern:         pattern,
			HandlerName:     ep.HandlerName,
			HandlerPkgPath:  ep.HandlerPkg,
			HandlerRef:      handlerRef,
			Shape:           ep.Shape,
			ReqType:         reqType,
			RespType:        respType,
			HasRequest:      hasRequest,
			HasResponse:     hasResponse,
			IsSliceResponse: isSliceResponse,
			Bindings:        ep.Bindings,
			Middlewares:     mwRefs,
		})
	}

	// 4. Execute template
	data := templateData{
		Package:         pkgName,
		Imports:         imports,
		Endpoints:       tmplEndpoints,
		Helpers:         helpers,
		HasMiddleware:   hasMiddleware,
		MiddlewarePkg:   middlewarePkg,
		MiddlewareAlias: middlewareAlias,
	}

	var buf bytes.Buffer
	if err := mainTmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("template execution failed: %w", err)
	}

	// 5. Run gofmt
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted code with error for debugging
		return buf.String(), fmt.Errorf("gofmt failed: %w\n\nGenerated code:\n%s", err, buf.String())
	}

	return string(formatted), nil
}

// collectRequiredHelpers examines bindings and sets flags for which parse helpers are needed.
func collectRequiredHelpers(info *BindingInfo, helpers *templateHelpers) {
	allBindings := append(append(info.PathBindings, info.QueryBindings...), info.HeaderBindings...)

	for _, b := range allBindings {
		kind := b.TypeKind
		if b.IsSlice {
			kind = b.ElemKind
		}

		switch kind {
		case "bool":
			helpers.NeedsBool = true
		case "int":
			helpers.NeedsInt = true
		case "int8":
			helpers.NeedsInt8 = true
		case "int16":
			helpers.NeedsInt16 = true
		case "int32":
			helpers.NeedsInt32 = true
		case "int64":
			helpers.NeedsInt64 = true
		case "uint":
			helpers.NeedsUint = true
		case "uint8":
			helpers.NeedsUint8 = true
		case "uint16":
			helpers.NeedsUint16 = true
		case "uint32":
			helpers.NeedsUint32 = true
		case "uint64":
			helpers.NeedsUint64 = true
		case "float32":
			helpers.NeedsFloat32 = true
		case "float64":
			helpers.NeedsFloat64 = true
		case "time.Time":
			helpers.NeedsTime = true
		}
	}
}

// extractShortTypeName converts a full type path to a short reference.
// e.g., "example.com/app/pets.GetReq" -> "pets.GetReq"
// For the target package, returns just the type name without package prefix.
func extractShortTypeName(fullType string, importSet map[string]string) string {
	if fullType == "" {
		return ""
	}

	// Handle slice types
	if strings.HasPrefix(fullType, "[]") {
		elemType := extractShortTypeName(fullType[2:], importSet)
		return "[]" + elemType
	}

	// Handle pointer types
	if strings.HasPrefix(fullType, "*") {
		elemType := extractShortTypeName(fullType[1:], importSet)
		return "*" + elemType
	}

	// Find the last dot to split package path from type name
	lastDot := strings.LastIndex(fullType, ".")
	if lastDot == -1 {
		return fullType // no package path, just a type name
	}

	pkgPath := fullType[:lastDot]
	typeName := fullType[lastDot+1:]

	// Look up the alias for this package
	if alias, ok := importSet[pkgPath]; ok {
		return alias + "." + typeName
	}

	// If the package is not imported (e.g., it's the target package), use just the type name
	return typeName
}
