package {{.PackageName}}

import (
{{- range .Imports}}
	"{{.}}"
{{- end}}
)

// =============================================================================
// Request Types
// =============================================================================

// Get{{.SingularPascal}}Request contains the path parameters for fetching a single {{.SingularPascal}}.
type Get{{.SingularPascal}}Request struct {
	PublicID string `path:"public_id"`
}

// List{{.PluralPascal}}Request contains the query parameters for listing {{.PluralPascal}}.
type List{{.PluralPascal}}Request struct {
	Limit int `query:"limit"`
{{- if .SupportsCursor}}
	Cursor *string `query:"cursor"`
{{- else}}
	Offset int `query:"offset"`
{{- end}}
}

// Create{{.SingularPascal}}Request contains the JSON body for creating a new {{.SingularPascal}}.
type Create{{.SingularPascal}}Request struct {
{{- range .UserColumns}}
	{{.FieldName}} {{.GoType}} `json:"{{.JSONTag}}"`
{{- end}}
}

// Update{{.SingularPascal}}Request contains the path parameters and JSON body for updating a {{.SingularPascal}}.
type Update{{.SingularPascal}}Request struct {
	PublicID string `path:"public_id"`
{{- range .UserColumns}}
	{{.FieldName}} {{.GoType}} `json:"{{.JSONTag}}"`
{{- end}}
}

// Delete{{.SingularPascal}}Request contains the path parameters for deleting a {{.SingularPascal}}.
type Delete{{.SingularPascal}}Request struct {
	PublicID string `path:"public_id"`
}

// =============================================================================
// Response Types
// =============================================================================

// {{.SingularPascal}}Response represents a single {{.SingularPascal}} in API responses.
type {{.SingularPascal}}Response struct {
{{- range .ResultColumns}}
	{{.FieldName}} {{.GoType}} `json:"{{.JSONTag}}"`
{{- end}}
}

// List{{.PluralPascal}}Response contains the paginated list of {{.PluralPascal}}.
type List{{.PluralPascal}}Response struct {
	Items []{{.SingularPascal}}Response `json:"items"`
{{- if .SupportsCursor}}
	NextCursor *string `json:"next_cursor,omitempty"`
{{- else}}
	Total int `json:"total"`
{{- end}}
}

{{if .HasDBIntegration}}
// =============================================================================
// Handlers
// =============================================================================

// Get{{.SingularPascal}} handles GET {{.BasePath}}/{public_id}
func Get{{.SingularPascal}}(ctx context.Context, req Get{{.SingularPascal}}Request) ({{.SingularPascal}}Response, error) {
	result, err := {{.DBGenPkg}}.Querier.Get{{.SingularPascal}}(ctx, {{.QueriesPkg}}.Get{{.SingularPascal}}Params{
		PublicID: req.PublicID,
	})
	if err != nil {
		return {{.SingularPascal}}Response{}, err
	}
	if result == nil {
		return {{.SingularPascal}}Response{}, portapi.NotFoundError("{{.SingularName}} not found")
	}
	return map{{.SingularPascal}}ToResponse(result), nil
}

// List{{.PluralPascal}} handles GET {{.BasePath}}
func List{{.PluralPascal}}(ctx context.Context, req List{{.PluralPascal}}Request) (List{{.PluralPascal}}Response, error) {
	limit := req.Limit
	if limit <= 0 || limit > 100 {
		limit = 20
	}

{{- if .SupportsCursor}}
	result, err := {{.DBGenPkg}}.Querier.List{{.PluralPascal}}(ctx, {{.QueriesPkg}}.List{{.PluralPascal}}Params{
		Limit:  limit,
		Cursor: parseCursorFor{{.PluralPascal}}(req.Cursor),
	})
	if err != nil {
		return List{{.PluralPascal}}Response{}, err
	}
	if result == nil {
		return List{{.PluralPascal}}Response{Items: []{{.SingularPascal}}Response{}}, nil
	}
	items := make([]{{.SingularPascal}}Response, len(result.Items))
	for i, item := range result.Items {
		items[i] = map{{.SingularPascal}}ItemToResponse(item)
	}
	var nextCursor *string
	if result.NextCursor != nil {
		cursor := encodeCursorFor{{.PluralPascal}}(result.NextCursor)
		nextCursor = &cursor
	}
	return List{{.PluralPascal}}Response{
		Items:      items,
		NextCursor: nextCursor,
	}, nil
{{- else}}
	result, err := {{.DBGenPkg}}.Querier.List{{.PluralPascal}}(ctx, {{.QueriesPkg}}.List{{.PluralPascal}}Params{
		Limit:  limit,
		Offset: req.Offset,
	})
	if err != nil {
		return List{{.PluralPascal}}Response{}, err
	}
	items := make([]{{.SingularPascal}}Response, len(result))
	for i, item := range result {
		items[i] = map{{.SingularPascal}}ResultToResponse(item)
	}
	return List{{.PluralPascal}}Response{
		Items: items,
		Total: len(items),
	}, nil
{{- end}}
}

// Create{{.SingularPascal}} handles POST {{.BasePath}}
func Create{{.SingularPascal}}(ctx context.Context, req Create{{.SingularPascal}}Request) ({{.SingularPascal}}Response, error) {
	publicID, err := {{.DBGenPkg}}.Querier.Insert{{.SingularPascal}}(ctx, {{.QueriesPkg}}.Insert{{.SingularPascal}}Params{
{{- range .UserColumns}}
		{{.FieldName}}: req.{{.FieldName}},
{{- end}}
	})
	if err != nil {
		return {{.SingularPascal}}Response{}, err
	}
	// Fetch the created record to return the full response
	result, err := {{.DBGenPkg}}.Querier.Get{{.SingularPascal}}(ctx, {{.QueriesPkg}}.Get{{.SingularPascal}}Params{
		PublicID: publicID,
	})
	if err != nil {
		return {{.SingularPascal}}Response{}, err
	}
	if result == nil {
		return {{.SingularPascal}}Response{}, portapi.InternalError("failed to fetch created {{.SingularName}}")
	}
	return map{{.SingularPascal}}ToResponse(result), nil
}

// Update{{.SingularPascal}} handles PUT {{.BasePath}}/{public_id}
func Update{{.SingularPascal}}(ctx context.Context, req Update{{.SingularPascal}}Request) ({{.SingularPascal}}Response, error) {
	err := {{.DBGenPkg}}.Querier.Update{{.SingularPascal}}(ctx, {{.QueriesPkg}}.Update{{.SingularPascal}}Params{
		PublicID: req.PublicID,
{{- range .UserColumns}}
		{{.FieldName}}: req.{{.FieldName}},
{{- end}}
	})
	if err != nil {
		return {{.SingularPascal}}Response{}, err
	}
	// Fetch the updated record to return the full response
	result, err := {{.DBGenPkg}}.Querier.Get{{.SingularPascal}}(ctx, {{.QueriesPkg}}.Get{{.SingularPascal}}Params{
		PublicID: req.PublicID,
	})
	if err != nil {
		return {{.SingularPascal}}Response{}, err
	}
	if result == nil {
		return {{.SingularPascal}}Response{}, portapi.NotFoundError("{{.SingularName}} not found")
	}
	return map{{.SingularPascal}}ToResponse(result), nil
}

// Delete{{.SingularPascal}} handles DELETE {{.BasePath}}/{public_id}
func Delete{{.SingularPascal}}(ctx context.Context, req Delete{{.SingularPascal}}Request) error {
	return {{.DBGenPkg}}.Querier.Delete{{.SingularPascal}}(ctx, {{.QueriesPkg}}.Delete{{.SingularPascal}}Params{
		PublicID: req.PublicID,
	})
}

// =============================================================================
// Response Mappers
// =============================================================================

// map{{.SingularPascal}}ToResponse converts a Get query result to a response.
func map{{.SingularPascal}}ToResponse(r *{{.QueriesPkg}}.Get{{.SingularPascal}}Result) {{.SingularPascal}}Response {
	return {{.SingularPascal}}Response{
{{- range .ResultColumns}}
		{{.FieldName}}: r.{{.FieldName}},
{{- end}}
	}
}

{{- if .SupportsCursor}}

// map{{.SingularPascal}}ItemToResponse converts a List item to a response.
func map{{.SingularPascal}}ItemToResponse(r {{.QueriesPkg}}.List{{.PluralPascal}}Item) {{.SingularPascal}}Response {
	return {{.SingularPascal}}Response{
{{- range .ResultColumns}}
		{{.FieldName}}: r.{{.FieldName}},
{{- end}}
	}
}

// parseCursorFor{{.PluralPascal}} parses the cursor string into cursor params.
func parseCursorFor{{.PluralPascal}}(cursor *string) *{{.QueriesPkg}}.List{{.PluralPascal}}Cursor {
	if cursor == nil || *cursor == "" {
		return nil
	}
	// TODO: Implement cursor parsing based on your cursor format
	return nil
}

// encodeCursorFor{{.PluralPascal}} encodes a cursor struct to a string.
func encodeCursorFor{{.PluralPascal}}(cursor *{{.QueriesPkg}}.List{{.PluralPascal}}Cursor) string {
	if cursor == nil {
		return ""
	}
	// TODO: Implement cursor encoding based on your cursor format
	return ""
}
{{- else}}

// map{{.SingularPascal}}ResultToResponse converts a List result item to a response.
func map{{.SingularPascal}}ResultToResponse(r {{.QueriesPkg}}.List{{.PluralPascal}}Result) {{.SingularPascal}}Response {
	return {{.SingularPascal}}Response{
{{- range .ResultColumns}}
		{{.FieldName}}: r.{{.FieldName}},
{{- end}}
	}
}
{{- end}}

// =============================================================================
// Registration
// =============================================================================

// Register registers all {{.TableName}} endpoints with the portapi App.
func Register(app *portapi.App) {
	app.Get("{{.BasePath}}/{public_id}", Get{{.SingularPascal}})
	app.Get("{{.BasePath}}", List{{.PluralPascal}})
	app.Post("{{.BasePath}}", Create{{.SingularPascal}})
	app.Put("{{.BasePath}}/{public_id}", Update{{.SingularPascal}})
	app.Delete("{{.BasePath}}/{public_id}", Delete{{.SingularPascal}})
}

{{else}}
// =============================================================================
// Stub Handlers (implement these or configure db.queries_out for DB-backed handlers)
// =============================================================================

// Get{{.SingularPascal}} handles GET {{.BasePath}}/{public_id}
func Get{{.SingularPascal}}(ctx context.Context, req Get{{.SingularPascal}}Request) ({{.SingularPascal}}Response, error) {
	// TODO: Implement this handler
	//
	// To generate DB-backed handlers, configure queries_out in shipq.ini:
	//   [db]
	//   queries_out = queries
	//
	// Then run: shipq db compile && shipq api resource {{.TableName}}
	return {{.SingularPascal}}Response{}, nil
}

// List{{.PluralPascal}} handles GET {{.BasePath}}
func List{{.PluralPascal}}(ctx context.Context, req List{{.PluralPascal}}Request) (List{{.PluralPascal}}Response, error) {
	limit := req.Limit
	if limit <= 0 || limit > 100 {
		limit = 20
	}
	_ = limit // TODO: use limit in query

	return List{{.PluralPascal}}Response{Items: []{{.SingularPascal}}Response{}}, nil
}

// Create{{.SingularPascal}} handles POST {{.BasePath}}
func Create{{.SingularPascal}}(ctx context.Context, req Create{{.SingularPascal}}Request) ({{.SingularPascal}}Response, error) {
	// TODO: Implement this handler
	return {{.SingularPascal}}Response{}, nil
}

// Update{{.SingularPascal}} handles PUT {{.BasePath}}/{public_id}
func Update{{.SingularPascal}}(ctx context.Context, req Update{{.SingularPascal}}Request) ({{.SingularPascal}}Response, error) {
	// TODO: Implement this handler
	return {{.SingularPascal}}Response{}, nil
}

// Delete{{.SingularPascal}} handles DELETE {{.BasePath}}/{public_id}
func Delete{{.SingularPascal}}(ctx context.Context, req Delete{{.SingularPascal}}Request) error {
	// TODO: Implement this handler
	return nil
}

// =============================================================================
// Registration
// =============================================================================

// Register registers all {{.TableName}} endpoints with the portapi App.
func Register(app *portapi.App) {
	app.Get("{{.BasePath}}/{public_id}", Get{{.SingularPascal}})
	app.Get("{{.BasePath}}", List{{.PluralPascal}})
	app.Post("{{.BasePath}}", Create{{.SingularPascal}})
	app.Put("{{.BasePath}}/{public_id}", Update{{.SingularPascal}})
	app.Delete("{{.BasePath}}/{public_id}", Delete{{.SingularPascal}})
}
{{end}}
