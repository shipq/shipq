package cli

import (
	"embed"
	"fmt"
	"io/fs"
	"path/filepath"
	"sort"
	"strings"
)

//go:embed assets/stoplight/*
var stoplightAssets embed.FS

// GenerateDocsUI generates the zz_generated_openapi.go file content.
// Returns empty string if DocsUIEnabled is false.
func GenerateDocsUI(cfg *Config, manifest *Manifest) (string, error) {
	return GenerateDocsUIWithPackage(cfg, manifest, "api")
}

// GenerateDocsUIWithPackage generates the zz_generated_openapi.go file content with a custom package name.
func GenerateDocsUIWithPackage(cfg *Config, manifest *Manifest, pkgName string) (string, error) {
	if !cfg.DocsUIEnabled {
		return "", nil
	}

	docsPath := cfg.DocsPath
	openAPIJSONPath := cfg.OpenAPIJSONPath
	openAPIOutput := cfg.OpenAPIOutput
	if openAPIOutput == "" {
		openAPIOutput = "openapi.json"
	}
	title := cfg.OpenAPITitle
	if title == "" {
		title = "API Documentation"
	}

	// Build the HTML template
	html := buildDocsHTML(docsPath, openAPIJSONPath, title)

	// Generate the code
	var sb strings.Builder

	sb.WriteString("// Code generated by portsql-api-httpgen. DO NOT EDIT.\n\n")
	sb.WriteString(fmt.Sprintf("package %s\n\n", pkgName))

	// Imports
	sb.WriteString("import (\n")
	sb.WriteString("\t\"embed\"\n")
	sb.WriteString("\t\"io/fs\"\n")
	sb.WriteString("\t\"net/http\"\n")
	sb.WriteString(")\n\n")

	// Embed directives
	sb.WriteString(fmt.Sprintf("//go:embed %s\n", openAPIOutput))
	sb.WriteString("var zzOpenAPIJSON []byte\n\n")

	sb.WriteString("//go:embed zz_generated_docs_assets/*\n")
	sb.WriteString("var zzDocsAssets embed.FS\n\n")

	// OpenAPIJSON function
	sb.WriteString("// OpenAPIJSON returns the embedded OpenAPI specification as JSON bytes.\n")
	sb.WriteString("func OpenAPIJSON() []byte {\n")
	sb.WriteString("\treturn zzOpenAPIJSON\n")
	sb.WriteString("}\n\n")

	// HTML constant
	sb.WriteString("// zzDocsHTML is the HTML page for the docs UI.\n")
	sb.WriteString(fmt.Sprintf("const zzDocsHTML = `%s`\n\n", html))

	// RegisterDocs function
	sb.WriteString("// RegisterDocs registers the OpenAPI JSON and Docs UI routes on the given mux.\n")
	sb.WriteString("func RegisterDocs(mux *http.ServeMux) {\n")

	// OpenAPI JSON endpoint
	sb.WriteString(fmt.Sprintf("\t// Serve OpenAPI JSON at %s\n", openAPIJSONPath))
	sb.WriteString(fmt.Sprintf("\tmux.HandleFunc(\"GET %s\", func(w http.ResponseWriter, r *http.Request) {\n", openAPIJSONPath))
	sb.WriteString("\t\tw.Header().Set(\"Content-Type\", \"application/json; charset=utf-8\")\n")
	sb.WriteString("\t\tw.Header().Set(\"Cache-Control\", \"no-store\")\n")
	sb.WriteString("\t\tw.Write(zzOpenAPIJSON)\n")
	sb.WriteString("\t})\n\n")

	// Docs HTML endpoint - redirect /docs to /docs/
	sb.WriteString(fmt.Sprintf("\t// Redirect %s to %s/\n", docsPath, docsPath))
	sb.WriteString(fmt.Sprintf("\tmux.HandleFunc(\"GET %s\", func(w http.ResponseWriter, r *http.Request) {\n", docsPath))
	sb.WriteString(fmt.Sprintf("\t\thttp.Redirect(w, r, \"%s/\", http.StatusMovedPermanently)\n", docsPath))
	sb.WriteString("\t})\n\n")

	// Docs HTML endpoint - serve at /docs/
	sb.WriteString(fmt.Sprintf("\t// Serve Docs UI HTML at %s/\n", docsPath))
	sb.WriteString(fmt.Sprintf("\tmux.HandleFunc(\"GET %s/\", func(w http.ResponseWriter, r *http.Request) {\n", docsPath))
	sb.WriteString(fmt.Sprintf("\t\t// Only serve HTML at exactly %s/\n", docsPath))
	sb.WriteString(fmt.Sprintf("\t\tif r.URL.Path != \"%s/\" {\n", docsPath))
	sb.WriteString("\t\t\thttp.NotFound(w, r)\n")
	sb.WriteString("\t\t\treturn\n")
	sb.WriteString("\t\t}\n")
	sb.WriteString("\t\tw.Header().Set(\"Content-Type\", \"text/html; charset=utf-8\")\n")
	sb.WriteString("\t\tw.Header().Set(\"Cache-Control\", \"no-store\")\n")
	sb.WriteString("\t\tw.Write([]byte(zzDocsHTML))\n")
	sb.WriteString("\t})\n\n")

	// Assets endpoint
	sb.WriteString(fmt.Sprintf("\t// Serve static assets at %s/assets/\n", docsPath))
	sb.WriteString("\tassetsFS, _ := fs.Sub(zzDocsAssets, \"zz_generated_docs_assets\")\n")
	sb.WriteString(fmt.Sprintf("\tassetsHandler := http.StripPrefix(\"%s/assets/\", http.FileServer(http.FS(assetsFS)))\n", docsPath))
	sb.WriteString(fmt.Sprintf("\tmux.Handle(\"GET %s/assets/\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n", docsPath))
	sb.WriteString("\t\t// Set cache headers for assets\n")
	sb.WriteString("\t\tw.Header().Set(\"Cache-Control\", \"public, max-age=3600\")\n")
	sb.WriteString("\t\tassetsHandler.ServeHTTP(w, r)\n")
	sb.WriteString("\t}))\n")

	sb.WriteString("}\n")

	return sb.String(), nil
}

// buildDocsHTML generates the HTML page for the docs UI.
func buildDocsHTML(docsPath, openAPIJSONPath, title string) string {
	assetsPath := docsPath + "/assets"

	return fmt.Sprintf(`<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>%s</title>
    <link rel="stylesheet" href="%s/stoplight/elements.min.css">
    <style>
        body {
            margin: 0;
            padding: 0;
        }
        elements-api {
            display: block;
            min-height: 100vh;
        }
    </style>
</head>
<body>
    <elements-api
        apiDescriptionUrl="%s"
        router="hash"
        layout="sidebar"
    />
    <script src="%s/stoplight/elements.min.js"></script>
</body>
</html>`, title, assetsPath, openAPIJSONPath, assetsPath)
}

// GetDocsAssets returns the list of asset files to be written.
// Returns a map of relative path -> content.
func GetDocsAssets() (map[string][]byte, error) {
	assets := make(map[string][]byte)

	err := fs.WalkDir(stoplightAssets, "assets/stoplight", func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() {
			return nil
		}

		content, err := stoplightAssets.ReadFile(path)
		if err != nil {
			return fmt.Errorf("reading embedded file %s: %w", path, err)
		}

		// Convert path from assets/stoplight/... to stoplight/...
		relPath := strings.TrimPrefix(path, "assets/")
		assets[relPath] = content

		return nil
	})

	if err != nil {
		return nil, err
	}

	return assets, nil
}

// GetDocsAssetPaths returns the sorted list of asset paths for deterministic iteration.
func GetDocsAssetPaths(assets map[string][]byte) []string {
	paths := make([]string, 0, len(assets))
	for p := range assets {
		paths = append(paths, p)
	}
	sort.Strings(paths)
	return paths
}

// WriteDocsAssets writes the docs assets to the target directory.
func WriteDocsAssets(targetDir string) error {
	assets, err := GetDocsAssets()
	if err != nil {
		return err
	}

	assetsDir := filepath.Join(targetDir, "zz_generated_docs_assets")

	// Write each asset
	for relPath, content := range assets {
		fullPath := filepath.Join(assetsDir, relPath)

		// Ensure directory exists
		dir := filepath.Dir(fullPath)
		if err := mkdirAllIfNotExists(dir); err != nil {
			return fmt.Errorf("creating directory %s: %w", dir, err)
		}

		// Write file
		if err := writeFileIfChanged(fullPath, content); err != nil {
			return fmt.Errorf("writing asset %s: %w", fullPath, err)
		}
	}

	return nil
}

// mkdirAllIfNotExists creates a directory if it doesn't exist.
func mkdirAllIfNotExists(dir string) error {
	return mkdirAll(dir, 0755)
}

// mkdirAll is a variable to allow testing
var mkdirAll = func(path string, perm uint32) error {
	return nil // Will be replaced with os.MkdirAll in main
}

// writeFileIfChanged writes a file only if content changed (for determinism).
var writeFileIfChanged = func(path string, content []byte) error {
	return nil // Will be replaced with actual write in main
}
