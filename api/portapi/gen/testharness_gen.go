// Package gen provides code generation utilities for PortAPI.
//
// This file implements the test harness generator which produces helpers
// for integration tests: NewTestClient and NewTestServer.
package gen

import (
	"bytes"
	"fmt"
	"go/format"
	"sort"
	"strings"
	"text/template"
)

// TestHarnessGenerator generates test harness helpers for integration testing.
type TestHarnessGenerator struct {
	// PackageName is the Go package name for the generated file.
	PackageName string

	// HasNewMux indicates whether a NewMux() function exists in the package.
	// If true, NewTestServer will use it to create the server mux.
	HasNewMux bool

	// NeedsHandlerImpl indicates whether NewMux requires handler implementation.
	// If true, NewTestServer signature will be different.
	NeedsHandlerImpl bool

	// HandlerImplType is the type name for handler implementation if needed.
	HandlerImplType string
}

// Generate produces the test harness Go source code.
func (g *TestHarnessGenerator) Generate() ([]byte, error) {
	// Validate inputs
	if g.PackageName == "" {
		return nil, fmt.Errorf("PackageName is required")
	}

	// Build template data
	data := g.buildTemplateData()

	// Execute template
	var buf bytes.Buffer
	if err := testHarnessTemplate.Execute(&buf, data); err != nil {
		return nil, fmt.Errorf("execute template: %w", err)
	}

	// Format the output
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted source for debugging
		return buf.Bytes(), fmt.Errorf("format source: %w\n\nUnformatted source:\n%s", err, buf.String())
	}

	return formatted, nil
}

// harnessTemplateData contains all data needed to render the template.
type harnessTemplateData struct {
	PackageName      string
	Imports          []harnessImportSpec
	HasNewMux        bool
	NeedsHandlerImpl bool
	HandlerImplType  string
}

type harnessImportSpec struct {
	Alias string
	Path  string
}

// buildTemplateData creates the data structure for template rendering.
func (g *TestHarnessGenerator) buildTemplateData() harnessTemplateData {
	data := harnessTemplateData{
		PackageName:      g.PackageName,
		HasNewMux:        g.HasNewMux,
		NeedsHandlerImpl: g.NeedsHandlerImpl,
		HandlerImplType:  g.HandlerImplType,
	}

	// Collect required imports
	imports := make(map[string]string) // path -> alias

	// Always needed for NewTestClient
	imports["net/http/httptest"] = ""

	// Needed for NewTestServer
	imports["testing"] = ""
	imports["net/http"] = ""

	// Convert to sorted slice
	var paths []string
	for path := range imports {
		paths = append(paths, path)
	}
	sort.Strings(paths)

	for _, path := range paths {
		data.Imports = append(data.Imports, harnessImportSpec{
			Alias: imports[path],
			Path:  path,
		})
	}

	return data
}

// testHarnessTemplate is the main template for generating test harness code.
var testHarnessTemplate = template.Must(template.New("testharness").Funcs(template.FuncMap{
	"lower": strings.ToLower,
}).Parse(`// Code generated by portapi testharness generator. DO NOT EDIT.
// This file is test-only and will not be included in production builds.

package {{.PackageName}}

import (
{{- range .Imports}}
	{{if .Alias}}{{.Alias}} {{end}}"{{.Path}}"
{{- end}}
)

// NewTestClient creates a test client configured for the given httptest.Server.
//
// It uses ts.Client() to get an HTTP client properly configured for the test server
// (handling cookies, redirects, and TLS settings), and ts.URL as the base URL.
//
// This function panics if ts is nil, as that indicates a bug in the test setup.
//
// Example usage:
//
//	ts := httptest.NewServer(NewMux())
//	defer ts.Close()
//	client := NewTestClient(ts)
//	resp, err := client.SomeEndpoint(ctx, req)
func NewTestClient(ts *httptest.Server) *Client {
	if ts == nil {
		panic("NewTestClient: nil httptest.Server")
	}
	return &Client{
		BaseURL: ts.URL,
		HTTP:    ts.Client(),
	}
}

{{if .HasNewMux}}
{{if .NeedsHandlerImpl}}
// NewTestServer creates an httptest.Server with the generated API routes.
//
// It requires a handler implementation to be passed. The server is automatically
// closed when the test completes via t.Cleanup.
//
// Example usage:
//
//	ts := NewTestServer(t, myImpl)
//	client := NewTestClient(ts)
//	resp, err := client.SomeEndpoint(ctx, req)
func NewTestServer(t *testing.T, impl {{.HandlerImplType}}) *httptest.Server {
	t.Helper()
	mux := NewMux(impl)
	ts := httptest.NewServer(mux)
	t.Cleanup(ts.Close)
	return ts
}
{{else}}
// NewTestServer creates an httptest.Server with the generated API routes.
//
// It uses NewMux() to create the server mux with all routes registered.
// The server is automatically closed when the test completes via t.Cleanup.
//
// Example usage:
//
//	ts := NewTestServer(t)
//	client := NewTestClient(ts)
//	resp, err := client.SomeEndpoint(ctx, req)
func NewTestServer(t *testing.T) *httptest.Server {
	t.Helper()
	mux := NewMux()
	ts := httptest.NewServer(mux)
	t.Cleanup(ts.Close)
	return ts
}
{{end}}
{{else}}
// NewTestServer creates an httptest.Server from the provided handler.
//
// The server is automatically closed when the test completes via t.Cleanup.
//
// Example usage:
//
//	mux := http.NewServeMux()
//	// ... register your handlers ...
//	ts := NewTestServer(t, mux)
//	client := NewTestClient(ts)
//	resp, err := client.SomeEndpoint(ctx, req)
func NewTestServer(t *testing.T, handler http.Handler) *httptest.Server {
	t.Helper()
	ts := httptest.NewServer(handler)
	t.Cleanup(ts.Close)
	return ts
}
{{end}}
`))
