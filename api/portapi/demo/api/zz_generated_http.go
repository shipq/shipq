// Code generated by portsql-api-httpgen. DO NOT EDIT.

package api

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"strconv"

	"github.com/shipq/shipq/api/portapi"

	middleware "github.com/shipq/shipq/api/portapi/demo/middleware"
)

// BindError represents an error that occurred during request binding.
type BindError struct {
	Source string // "path", "query", "header", "body"
	Field  string
	Err    error
}

func (e *BindError) Error() string {
	if e.Field != "" {
		return fmt.Sprintf("%s %s: %s", e.Source, e.Field, e.Err.Error())
	}
	return fmt.Sprintf("%s: %s", e.Source, e.Err.Error())
}

func (e *BindError) Unwrap() error {
	return e.Err
}

var errMissing = errors.New("missing required value")

// ErrorResponse is the standard error response structure.
type ErrorResponse struct {
	Error ErrorDetail `json:"error"`
}

// ErrorDetail contains the error code and message.
type ErrorDetail struct {
	Code    string `json:"code"`
	Message string `json:"message"`
}

func writeJSON(w http.ResponseWriter, status int, data any) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	_ = json.NewEncoder(w).Encode(data)
}

func writeError(w http.ResponseWriter, err error) {
	status := http.StatusInternalServerError
	code := "internal_error"
	message := err.Error()

	var bindErr *BindError
	if errors.As(err, &bindErr) {
		status = http.StatusBadRequest
		code = "bad_request"
	}

	// Check for CodedError interface
	type codedError interface {
		StatusCode() int
		ErrorCode() string
	}
	var ce codedError
	if errors.As(err, &ce) {
		status = ce.StatusCode()
		code = ce.ErrorCode()
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	_ = json.NewEncoder(w).Encode(ErrorResponse{
		Error: ErrorDetail{
			Code:    code,
			Message: message,
		},
	})
}

// zzChain builds a middleware chain in the correct execution order.
func zzChain(req *portapi.Request, mws []portapi.Middleware, final portapi.Next) portapi.Next {
	if len(mws) == 0 {
		return final
	}

	// Build chain in reverse order so first middleware wraps all others
	next := final
	for i := len(mws) - 1; i >= 0; i-- {
		mw := mws[i]
		if mw == nil {
			// Treat nil middleware as internal error
			return func(ctx context.Context) (portapi.HandlerResult, error) {
				return portapi.HandlerResult{}, errors.New("nil middleware in chain")
			}
		}
		// Capture loop variables properly
		currentMw := mw
		prevNext := next
		next = func(ctx context.Context) (portapi.HandlerResult, error) {
			return currentMw(ctx, req, prevNext)
		}
	}
	return next
}

// writeResult writes a HandlerResult to the response.
func writeResult(w http.ResponseWriter, res portapi.HandlerResult) error {
	// Validate result
	if err := res.Validate(); err != nil {
		// Invalid result - treat as internal error
		writeError(w, fmt.Errorf("invalid handler result: %w", err))
		return err
	}

	if res.NoContent {
		status := res.Status
		if status == 0 {
			status = http.StatusNoContent
		}
		w.WriteHeader(status)
		return nil
	}

	if res.JSON != nil {
		status := res.Status
		if status == 0 {
			status = http.StatusOK
		}
		writeJSON(w, status, res.JSON)
		return nil
	}

	// Empty result - treat as 204
	w.WriteHeader(http.StatusNoContent)
	return nil
}

func parseInt(s string) (int, error) {
	return strconv.Atoi(s)
}

func handleHealthCheck() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Initialize decoded request storage
		var zzDecoded any
		var zzDecodedOK bool

		// Build request view
		reqView := &portapi.Request{
			Method:  r.Method,
			Pattern: "GET /health",
			Header: func(name string) (string, bool) {
				v := r.Header.Get(name)
				return v, v != ""
			},
			Cookie: func(name string) (string, bool) {
				c, err := r.Cookie(name)
				if err != nil {
					return "", false
				}
				return c.Value, true
			},
			Query: func(name string) []string {
				return r.URL.Query()[name]
			},
			PathValue: func(name string) string {
				return r.PathValue(name)
			},
			DecodedReq: func() (any, bool) {
				return zzDecoded, zzDecodedOK
			},
		}

		// Build the final handler that performs binding and calls the handler
		final := func(ctx context.Context) (portapi.HandlerResult, error) {
			if err := HealthCheck(ctx); err != nil {
				return portapi.HandlerResult{}, err
			}
			return portapi.HandlerResult{NoContent: true}, nil
		}

		// Build middleware chain
		mws := []portapi.Middleware{middleware.RequestLogger, middleware.AuthOptional}
		next := zzChain(reqView, mws, final)

		// Execute chain
		result, err := next(r.Context())
		if err != nil {
			writeError(w, err)
			return
		}

		// Write result
		if err := writeResult(w, result); err != nil {
			return
		}
	})
}

func bindListPets(r *http.Request) (ListPetsRequest, error) {
	var req ListPetsRequest

	// Query bindings
	q := r.URL.Query()
	if !q.Has("species") {
		return req, &BindError{Source: "query", Field: "species", Err: errMissing}
	}
	{
		s := q.Get("species")
		req.Species = s
	}
	if !q.Has("limit") {
		return req, &BindError{Source: "query", Field: "limit", Err: errMissing}
	}
	{
		s := q.Get("limit")
		parsed, err := parseInt(s)
		if err != nil {
			return req, &BindError{Source: "query", Field: "limit", Err: err}
		}
		req.Limit = parsed
	}

	return req, nil
}

func handleListPets() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Initialize decoded request storage
		var zzDecoded any
		var zzDecodedOK bool

		// Build request view
		reqView := &portapi.Request{
			Method:  r.Method,
			Pattern: "GET /pets",
			Header: func(name string) (string, bool) {
				v := r.Header.Get(name)
				return v, v != ""
			},
			Cookie: func(name string) (string, bool) {
				c, err := r.Cookie(name)
				if err != nil {
					return "", false
				}
				return c.Value, true
			},
			Query: func(name string) []string {
				return r.URL.Query()[name]
			},
			PathValue: func(name string) string {
				return r.PathValue(name)
			},
			DecodedReq: func() (any, bool) {
				return zzDecoded, zzDecodedOK
			},
		}

		// Build the final handler that performs binding and calls the handler
		final := func(ctx context.Context) (portapi.HandlerResult, error) {
			req, err := bindListPets(r)
			if err != nil {
				return portapi.HandlerResult{}, err
			}

			// Mark decoded request as available
			zzDecoded = req
			zzDecodedOK = true
			resp, err := ListPets(ctx, req)
			if err != nil {
				return portapi.HandlerResult{}, err
			}
			if resp == nil {
				resp = []Pet{}
			}
			return portapi.HandlerResult{JSON: resp}, nil
		}

		// Build middleware chain
		mws := []portapi.Middleware{middleware.RequestLogger, middleware.AuthOptional}
		next := zzChain(reqView, mws, final)

		// Execute chain
		result, err := next(r.Context())
		if err != nil {
			writeError(w, err)
			return
		}

		// Write result
		if err := writeResult(w, result); err != nil {
			return
		}
	})
}

func bindCreatePet(r *http.Request) (CreatePetRequest, error) {
	var req CreatePetRequest

	// JSON body binding
	if r.Body == nil {
		return req, &BindError{Source: "body", Err: errMissing}
	}
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		return req, &BindError{Source: "body", Err: err}
	}

	return req, nil
}

func handleCreatePet() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Initialize decoded request storage
		var zzDecoded any
		var zzDecodedOK bool

		// Build request view
		reqView := &portapi.Request{
			Method:  r.Method,
			Pattern: "POST /pets",
			Header: func(name string) (string, bool) {
				v := r.Header.Get(name)
				return v, v != ""
			},
			Cookie: func(name string) (string, bool) {
				c, err := r.Cookie(name)
				if err != nil {
					return "", false
				}
				return c.Value, true
			},
			Query: func(name string) []string {
				return r.URL.Query()[name]
			},
			PathValue: func(name string) string {
				return r.PathValue(name)
			},
			DecodedReq: func() (any, bool) {
				return zzDecoded, zzDecodedOK
			},
		}

		// Build the final handler that performs binding and calls the handler
		final := func(ctx context.Context) (portapi.HandlerResult, error) {
			req, err := bindCreatePet(r)
			if err != nil {
				return portapi.HandlerResult{}, err
			}

			// Mark decoded request as available
			zzDecoded = req
			zzDecodedOK = true
			resp, err := CreatePet(ctx, req)
			if err != nil {
				return portapi.HandlerResult{}, err
			}
			return portapi.HandlerResult{JSON: resp}, nil
		}

		// Build middleware chain
		mws := []portapi.Middleware{middleware.RequestLogger, middleware.AuthRequired, middleware.RateLimiter}
		next := zzChain(reqView, mws, final)

		// Execute chain
		result, err := next(r.Context())
		if err != nil {
			writeError(w, err)
			return
		}

		// Write result
		if err := writeResult(w, result); err != nil {
			return
		}
	})
}

func bindDeletePet(r *http.Request) (DeletePetRequest, error) {
	var req DeletePetRequest

	// Path bindings
	{
		v := r.PathValue("id")
		if v == "" {
			return req, &BindError{Source: "path", Field: "id", Err: errMissing}
		}
		req.ID = v
	}

	return req, nil
}

func handleDeletePet() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Initialize decoded request storage
		var zzDecoded any
		var zzDecodedOK bool

		// Build request view
		reqView := &portapi.Request{
			Method:  r.Method,
			Pattern: "DELETE /pets/{id}",
			Header: func(name string) (string, bool) {
				v := r.Header.Get(name)
				return v, v != ""
			},
			Cookie: func(name string) (string, bool) {
				c, err := r.Cookie(name)
				if err != nil {
					return "", false
				}
				return c.Value, true
			},
			Query: func(name string) []string {
				return r.URL.Query()[name]
			},
			PathValue: func(name string) string {
				return r.PathValue(name)
			},
			DecodedReq: func() (any, bool) {
				return zzDecoded, zzDecodedOK
			},
		}

		// Build the final handler that performs binding and calls the handler
		final := func(ctx context.Context) (portapi.HandlerResult, error) {
			req, err := bindDeletePet(r)
			if err != nil {
				return portapi.HandlerResult{}, err
			}

			// Mark decoded request as available
			zzDecoded = req
			zzDecodedOK = true
			if err := DeletePet(ctx, req); err != nil {
				return portapi.HandlerResult{}, err
			}
			return portapi.HandlerResult{NoContent: true}, nil
		}

		// Build middleware chain
		mws := []portapi.Middleware{middleware.RequestLogger, middleware.AuthRequired, middleware.RateLimiter}
		next := zzChain(reqView, mws, final)

		// Execute chain
		result, err := next(r.Context())
		if err != nil {
			writeError(w, err)
			return
		}

		// Write result
		if err := writeResult(w, result); err != nil {
			return
		}
	})
}

func bindGetPet(r *http.Request) (GetPetRequest, error) {
	var req GetPetRequest

	// Path bindings
	{
		v := r.PathValue("id")
		if v == "" {
			return req, &BindError{Source: "path", Field: "id", Err: errMissing}
		}
		req.ID = v
	}

	return req, nil
}

func handleGetPet() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Initialize decoded request storage
		var zzDecoded any
		var zzDecodedOK bool

		// Build request view
		reqView := &portapi.Request{
			Method:  r.Method,
			Pattern: "GET /pets/{id}",
			Header: func(name string) (string, bool) {
				v := r.Header.Get(name)
				return v, v != ""
			},
			Cookie: func(name string) (string, bool) {
				c, err := r.Cookie(name)
				if err != nil {
					return "", false
				}
				return c.Value, true
			},
			Query: func(name string) []string {
				return r.URL.Query()[name]
			},
			PathValue: func(name string) string {
				return r.PathValue(name)
			},
			DecodedReq: func() (any, bool) {
				return zzDecoded, zzDecodedOK
			},
		}

		// Build the final handler that performs binding and calls the handler
		final := func(ctx context.Context) (portapi.HandlerResult, error) {
			req, err := bindGetPet(r)
			if err != nil {
				return portapi.HandlerResult{}, err
			}

			// Mark decoded request as available
			zzDecoded = req
			zzDecodedOK = true
			resp, err := GetPet(ctx, req)
			if err != nil {
				return portapi.HandlerResult{}, err
			}
			return portapi.HandlerResult{JSON: resp}, nil
		}

		// Build middleware chain
		mws := []portapi.Middleware{middleware.RequestLogger, middleware.AuthOptional}
		next := zzChain(reqView, mws, final)

		// Execute chain
		result, err := next(r.Context())
		if err != nil {
			writeError(w, err)
			return
		}

		// Write result
		if err := writeResult(w, result); err != nil {
			return
		}
	})
}

func bindUpdatePet(r *http.Request) (UpdatePetRequest, error) {
	var req UpdatePetRequest

	// Path bindings
	{
		v := r.PathValue("id")
		if v == "" {
			return req, &BindError{Source: "path", Field: "id", Err: errMissing}
		}
		req.ID = v
	}

	// JSON body binding
	if r.Body == nil {
		return req, &BindError{Source: "body", Err: errMissing}
	}
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		return req, &BindError{Source: "body", Err: err}
	}

	return req, nil
}

func handleUpdatePet() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Initialize decoded request storage
		var zzDecoded any
		var zzDecodedOK bool

		// Build request view
		reqView := &portapi.Request{
			Method:  r.Method,
			Pattern: "PUT /pets/{id}",
			Header: func(name string) (string, bool) {
				v := r.Header.Get(name)
				return v, v != ""
			},
			Cookie: func(name string) (string, bool) {
				c, err := r.Cookie(name)
				if err != nil {
					return "", false
				}
				return c.Value, true
			},
			Query: func(name string) []string {
				return r.URL.Query()[name]
			},
			PathValue: func(name string) string {
				return r.PathValue(name)
			},
			DecodedReq: func() (any, bool) {
				return zzDecoded, zzDecodedOK
			},
		}

		// Build the final handler that performs binding and calls the handler
		final := func(ctx context.Context) (portapi.HandlerResult, error) {
			req, err := bindUpdatePet(r)
			if err != nil {
				return portapi.HandlerResult{}, err
			}

			// Mark decoded request as available
			zzDecoded = req
			zzDecodedOK = true
			resp, err := UpdatePet(ctx, req)
			if err != nil {
				return portapi.HandlerResult{}, err
			}
			return portapi.HandlerResult{JSON: resp}, nil
		}

		// Build middleware chain
		mws := []portapi.Middleware{middleware.RequestLogger, middleware.AuthRequired, middleware.RateLimiter}
		next := zzChain(reqView, mws, final)

		// Execute chain
		result, err := next(r.Context())
		if err != nil {
			writeError(w, err)
			return
		}

		// Write result
		if err := writeResult(w, result); err != nil {
			return
		}
	})
}

func handleGetProfile() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Initialize decoded request storage
		var zzDecoded any
		var zzDecodedOK bool

		// Build request view
		reqView := &portapi.Request{
			Method:  r.Method,
			Pattern: "GET /profile",
			Header: func(name string) (string, bool) {
				v := r.Header.Get(name)
				return v, v != ""
			},
			Cookie: func(name string) (string, bool) {
				c, err := r.Cookie(name)
				if err != nil {
					return "", false
				}
				return c.Value, true
			},
			Query: func(name string) []string {
				return r.URL.Query()[name]
			},
			PathValue: func(name string) string {
				return r.PathValue(name)
			},
			DecodedReq: func() (any, bool) {
				return zzDecoded, zzDecodedOK
			},
		}

		// Build the final handler that performs binding and calls the handler
		final := func(ctx context.Context) (portapi.HandlerResult, error) {
			resp, err := GetProfile(ctx)
			if err != nil {
				return portapi.HandlerResult{}, err
			}
			return portapi.HandlerResult{JSON: resp}, nil
		}

		// Build middleware chain
		mws := []portapi.Middleware{middleware.RequestLogger, middleware.AuthRequired, middleware.RateLimiter}
		next := zzChain(reqView, mws, final)

		// Execute chain
		result, err := next(r.Context())
		if err != nil {
			writeError(w, err)
			return
		}

		// Write result
		if err := writeResult(w, result); err != nil {
			return
		}
	})
}

func NewMux() *http.ServeMux {
	mux := http.NewServeMux()

	mux.Handle("GET /health", handleHealthCheck())
	mux.Handle("GET /pets", handleListPets())
	mux.Handle("POST /pets", handleCreatePet())
	mux.Handle("DELETE /pets/{id}", handleDeletePet())
	mux.Handle("GET /pets/{id}", handleGetPet())
	mux.Handle("PUT /pets/{id}", handleUpdatePet())
	mux.Handle("GET /profile", handleGetProfile())
	return mux
}
