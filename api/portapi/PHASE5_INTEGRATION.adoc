= Phase 5: End-to-End Integration Tests
:toc:
:toclevels: 3

Verifies the complete pipeline works: generator produces code that compiles and serves HTTP correctly.

== Goal

Prove the system works end-to-end with real HTTP requests against generated code.

== Deliverables

- Test fixtures: minimal example API package
- Integration tests covering all handler shapes and binding sources
- Property tests for request/response roundtrips

== Step 1: Create test fixtures

=== 1.1 Create example API package

Create `api/portapi/testdata/exampleapi/handlers.go`:

[source,go]
----
package exampleapi

import "context"

// Shape 1: ctx + req → resp + err
type CreatePetReq struct {
    Name string `json:"name"`
}
type CreatePetResp struct {
    ID   string `json:"id"`
    Name string `json:"name"`
}
func CreatePet(ctx context.Context, req CreatePetReq) (CreatePetResp, error) {
    return CreatePetResp{ID: "pet-123", Name: req.Name}, nil
}

// Shape 2: ctx + req → err
type DeletePetReq struct {
    ID string `path:"id"`
}
func DeletePet(ctx context.Context, req DeletePetReq) error {
    return nil
}

// Shape 3: ctx → resp + err
type ListPetsResp struct {
    Pets []string `json:"pets"`
}
func ListPets(ctx context.Context) (ListPetsResp, error) {
    return ListPetsResp{Pets: []string{"fluffy", "spot"}}, nil
}

// Shape 4: ctx → err
func HealthCheck(ctx context.Context) error {
    return nil
}

// Mixed bindings
type GetPetReq struct {
    ID      string  `path:"id"`
    Verbose *bool   `query:"verbose"`
    Auth    string  `header:"Authorization"`
}
type GetPetResp struct {
    ID   string `json:"id"`
    Name string `json:"name"`
}
func GetPet(ctx context.Context, req GetPetReq) (GetPetResp, error) {
    return GetPetResp{ID: req.ID, Name: "fluffy"}, nil
}
----

=== 1.2 Create Register function

Create `api/portapi/testdata/exampleapi/register.go`:

[source,go]
----
package exampleapi

import "your/module/api/portapi"

func Register(app *portapi.App) {
    app.Post("/pets", CreatePet)
    app.Delete("/pets/{id}", DeletePet)
    app.Get("/pets", ListPets)
    app.Get("/health", HealthCheck)
    app.Get("/pets/{id}", GetPet)
}
----

== Step 2: Integration tests

=== 2.1 Test generated mux routing

Create `api/portapi/integration_test.go`:

[source,go]
----
//go:build integration

func TestIntegration_Routing(t *testing.T) {
    // Run generator on testdata/exampleapi
    // Compile generated code
    // Get NewMux()

    mux := getGeneratedMux(t)

    tests := []struct {
        method string
        path   string
        want   int
    }{
        {"GET", "/pets", 200},
        {"POST", "/pets", 200},
        {"DELETE", "/pets/123", 204},
        {"GET", "/pets/123", 200},
        {"GET", "/health", 204},
        {"GET", "/notfound", 404},
        {"POST", "/health", 405}, // method not allowed
    }

    for _, tt := range tests {
        t.Run(tt.method+" "+tt.path, func(t *testing.T) {
            r := httptest.NewRequest(tt.method, tt.path, nil)
            if tt.method == "GET" && tt.path == "/pets/123" {
                r.Header.Set("Authorization", "Bearer token")
            }
            w := httptest.NewRecorder()

            mux.ServeHTTP(w, r)

            assert.Equal(t, tt.want, w.Code)
        })
    }
}
----

=== 2.2 Test JSON body binding

[source,go]
----
//go:build integration

func TestIntegration_JSONBody(t *testing.T) {
    mux := getGeneratedMux(t)

    t.Run("valid JSON", func(t *testing.T) {
        body := strings.NewReader(`{"name":"Fluffy"}`)
        r := httptest.NewRequest("POST", "/pets", body)
        r.Header.Set("Content-Type", "application/json")
        w := httptest.NewRecorder()

        mux.ServeHTTP(w, r)

        assert.Equal(t, 200, w.Code)
        assert.JSONEq(t, `{"id":"pet-123","name":"Fluffy"}`, w.Body.String())
    })

    t.Run("invalid JSON → 400", func(t *testing.T) {
        body := strings.NewReader(`{invalid}`)
        r := httptest.NewRequest("POST", "/pets", body)
        r.Header.Set("Content-Type", "application/json")
        w := httptest.NewRecorder()

        mux.ServeHTTP(w, r)

        assert.Equal(t, 400, w.Code)
    })
}
----

=== 2.3 Test path variable binding

[source,go]
----
//go:build integration

func TestIntegration_PathVariables(t *testing.T) {
    mux := getGeneratedMux(t)

    t.Run("binds path variable", func(t *testing.T) {
        r := httptest.NewRequest("GET", "/pets/abc123", nil)
        r.Header.Set("Authorization", "Bearer token")
        w := httptest.NewRecorder()

        mux.ServeHTTP(w, r)

        assert.Equal(t, 200, w.Code)
        var resp map[string]string
        json.Unmarshal(w.Body.Bytes(), &resp)
        assert.Equal(t, "abc123", resp["id"])
    })
}
----

=== 2.4 Test query parameter binding

[source,go]
----
//go:build integration

func TestIntegration_QueryParams(t *testing.T) {
    mux := getGeneratedMux(t)

    t.Run("optional query param absent", func(t *testing.T) {
        r := httptest.NewRequest("GET", "/pets/123", nil)
        r.Header.Set("Authorization", "Bearer token")
        w := httptest.NewRecorder()

        mux.ServeHTTP(w, r)

        assert.Equal(t, 200, w.Code)
    })

    t.Run("optional query param present", func(t *testing.T) {
        r := httptest.NewRequest("GET", "/pets/123?verbose=true", nil)
        r.Header.Set("Authorization", "Bearer token")
        w := httptest.NewRecorder()

        mux.ServeHTTP(w, r)

        assert.Equal(t, 200, w.Code)
    })
}
----

=== 2.5 Test header binding

[source,go]
----
//go:build integration

func TestIntegration_Headers(t *testing.T) {
    mux := getGeneratedMux(t)

    t.Run("missing required header → 400", func(t *testing.T) {
        r := httptest.NewRequest("GET", "/pets/123", nil)
        // No Authorization header
        w := httptest.NewRecorder()

        mux.ServeHTTP(w, r)

        assert.Equal(t, 400, w.Code)
    })
}
----

=== 2.6 Test error responses

[source,go]
----
//go:build integration

func TestIntegration_ErrorResponses(t *testing.T) {
    mux := getGeneratedMux(t)

    t.Run("bind error is 400 with JSON body", func(t *testing.T) {
        r := httptest.NewRequest("GET", "/pets/123", nil)
        w := httptest.NewRecorder()

        mux.ServeHTTP(w, r)

        assert.Equal(t, 400, w.Code)
        assert.Equal(t, "application/json", w.Header().Get("Content-Type"))

        var resp map[string]any
        json.Unmarshal(w.Body.Bytes(), &resp)
        assert.NotEmpty(t, resp["error"])
    })
}
----

== Step 3: Property tests

=== 3.1 Roundtrip property tests

[source,go]
----
//go:build property

func TestProperty_JSONRoundtrip(t *testing.T) {
    mux := getGeneratedMux(t)

    // Generate random valid CreatePetReq
    // POST to /pets
    // Assert response contains the same name
}

func TestProperty_PathVariableRoundtrip(t *testing.T) {
    mux := getGeneratedMux(t)

    // Generate random valid IDs (alphanumeric)
    // GET /pets/{id}
    // Assert response.id == request id
}
----

=== 3.2 Error handling property tests

[source,go]
----
//go:build property

func TestProperty_InvalidJSON_Never500(t *testing.T) {
    mux := getGeneratedMux(t)

    // Generate random invalid JSON strings
    // POST to /pets
    // Assert status is 400, never 500
}

func TestProperty_ErrorResponse_AlwaysValidJSON(t *testing.T) {
    mux := getGeneratedMux(t)

    // Generate requests that cause errors
    // Assert response body is valid JSON with "error" key
}
----

== Step 4: Generator determinism tests

=== 4.1 Test output stability

[source,go]
----
//go:build integration

func TestIntegration_GeneratorDeterminism(t *testing.T) {
    // Run generator twice on same input
    // Assert output files are byte-identical

    code1 := runGenerator(t, "testdata/exampleapi")
    code2 := runGenerator(t, "testdata/exampleapi")

    assert.Equal(t, code1, code2, "generator output must be deterministic")
}
----

== Verification checklist

- [ ] `go test -tags=integration ./api/...` passes
- [ ] `go test -tags=property ./api/...` passes
- [ ] All 4 handler shapes work correctly
- [ ] All binding sources (path, query, header, JSON) work
- [ ] Error responses are always 400 for bind errors, 500 for handler errors
- [ ] Generator output is deterministic

== Files created

----
api/portapi/testdata/exampleapi/
  handlers.go
  register.go

api/portapi/
  integration_test.go
----

== Running all tests

[source,bash]
----
# Unit tests (fast, no external deps)
go test ./api/...

# Property tests
go test -tags=property ./api/...

# Integration tests (runs generator, compiles, HTTP)
go test -tags=integration ./api/...

# All tests
go test -tags=property,integration ./api/...
----
