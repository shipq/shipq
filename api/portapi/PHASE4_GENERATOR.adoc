= Phase 4: Generator (INI Config + Discovery + Codegen)
:toc:
:toclevels: 3

Implements `cmd/portsql-api-httpgen`: reads INI config, discovers endpoints, generates `zz_generated_http.go`.

== Goal

Build the complete generator pipeline: config parsing → discovery runner → manifest → code generation.

== Deliverables

- `cmd/portsql-api-httpgen/main.go` — entry point
- `cmd/portsql-api-httpgen/config.go` — INI parsing
- `cmd/portsql-api-httpgen/discover.go` — temp runner execution
- `cmd/portsql-api-httpgen/manifest.go` — JSON manifest types
- `cmd/portsql-api-httpgen/generate.go` — code emission

== Step 1: INI config parsing

=== 1.1 Write tests for config loading

Create `cmd/portsql-api-httpgen/config_test.go`:

[source,go]
----
func TestLoadConfig(t *testing.T) {
    t.Run("loads valid config", func(t *testing.T) {
        ini := "[httpgen]\npackage = ./api\n"
        cfg, err := ParseConfig(strings.NewReader(ini))
        require.NoError(t, err)
        assert.Equal(t, "./api", cfg.Package)
    })

    t.Run("missing section", func(t *testing.T) {
        ini := "package = ./api\n"
        _, err := ParseConfig(strings.NewReader(ini))
        require.Error(t, err)
        assert.Contains(t, err.Error(), "[httpgen]")
    })

    t.Run("missing package key", func(t *testing.T) {
        ini := "[httpgen]\n"
        _, err := ParseConfig(strings.NewReader(ini))
        require.Error(t, err)
        assert.Contains(t, err.Error(), "package")
    })

    t.Run("trims whitespace", func(t *testing.T) {
        ini := "[httpgen]\npackage =   ./api  \n"
        cfg, err := ParseConfig(strings.NewReader(ini))
        require.NoError(t, err)
        assert.Equal(t, "./api", cfg.Package)
    })
}

func TestFindConfig(t *testing.T) {
    t.Run("uses env var if set", func(t *testing.T) {
        // Create temp file, set env, call FindConfig
    })

    t.Run("falls back to ./portsql-api-httpgen.ini", func(t *testing.T) {
        // Create temp dir with ini file, chdir, call FindConfig
    })

    t.Run("error if no config found", func(t *testing.T) {
        // Empty temp dir, call FindConfig, expect error
    })
}
----

=== 1.2 Implement config parsing

Create `cmd/portsql-api-httpgen/config.go`:

[source,go]
----
package main

import (
    "bufio"
    "errors"
    "io"
    "os"
    "strings"
)

type Config struct {
    Package string // e.g. "./api"
}

func FindConfig() (string, error) {
    if p := os.Getenv("PORTSQL_API_HTTPGEN_CONFIG"); p != "" {
        return p, nil
    }
    if _, err := os.Stat("./portsql-api-httpgen.ini"); err == nil {
        return "./portsql-api-httpgen.ini", nil
    }
    return "", errors.New("config not found: set PORTSQL_API_HTTPGEN_CONFIG or create ./portsql-api-httpgen.ini")
}

func LoadConfig(path string) (*Config, error) {
    f, err := os.Open(path)
    if err != nil {
        return nil, err
    }
    defer f.Close()
    return ParseConfig(f)
}

func ParseConfig(r io.Reader) (*Config, error) {
    var inSection bool
    var pkg string

    scanner := bufio.NewScanner(r)
    for scanner.Scan() {
        line := strings.TrimSpace(scanner.Text())
        if line == "[httpgen]" {
            inSection = true
            continue
        }
        if strings.HasPrefix(line, "[") {
            inSection = false
            continue
        }
        if inSection && strings.HasPrefix(line, "package") {
            parts := strings.SplitN(line, "=", 2)
            if len(parts) == 2 {
                pkg = strings.TrimSpace(parts[1])
            }
        }
    }

    if pkg == "" {
        return nil, errors.New("missing [httpgen] section with 'package' key")
    }
    return &Config{Package: pkg}, nil
}
----

== Step 2: Manifest format

=== 2.1 Write tests for manifest serialization

Create `cmd/portsql-api-httpgen/manifest_test.go`:

[source,go]
----
func TestManifest_JSON(t *testing.T) {
    t.Run("roundtrip", func(t *testing.T) {
        m := Manifest{
            Endpoints: []ManifestEndpoint{
                {Method: "GET", Path: "/pets", HandlerPkg: "example/pets", HandlerName: "List", Shape: "ctx_resp_err"},
                {Method: "POST", Path: "/pets", HandlerPkg: "example/pets", HandlerName: "Create", Shape: "ctx_req_resp_err"},
            },
        }

        data, err := json.Marshal(m)
        require.NoError(t, err)

        var m2 Manifest
        err = json.Unmarshal(data, &m2)
        require.NoError(t, err)

        assert.Equal(t, m, m2)
    })

    t.Run("stable ordering", func(t *testing.T) {
        // Marshal twice, assert identical bytes
    })
}
----

=== 2.2 Implement manifest types

Create `cmd/portsql-api-httpgen/manifest.go`:

[source,go]
----
package main

type Manifest struct {
    Endpoints []ManifestEndpoint `json:"endpoints"`
}

type ManifestEndpoint struct {
    Method      string `json:"method"`
    Path        string `json:"path"`
    HandlerPkg  string `json:"handler_pkg"`
    HandlerName string `json:"handler_name"`
    Shape       string `json:"shape"` // ctx_req_resp_err, ctx_req_err, ctx_resp_err, ctx_err
    ReqType     string `json:"req_type,omitempty"`
    RespType    string `json:"resp_type,omitempty"`
}
----

== Step 3: Discovery runner

=== 3.1 Write tests for runner generation

Create `cmd/portsql-api-httpgen/discover_test.go`:

[source,go]
----
func TestGenerateRunnerCode(t *testing.T) {
    code := GenerateRunnerCode("example.com/app/api")

    assert.Contains(t, code, `import "example.com/app/api"`)
    assert.Contains(t, code, "api.Register(app)")
    assert.Contains(t, code, "json.NewEncoder(os.Stdout)")
}
----

=== 3.2 Write integration tests for discovery

[source,go]
----
//go:build integration

func TestDiscover_ValidPackage(t *testing.T) {
    // 1. Create temp module with valid handlers
    // 2. Run Discover(pkgPath)
    // 3. Assert manifest contains expected endpoints
}

func TestDiscover_InvalidHandler(t *testing.T) {
    // 1. Create temp module with invalid handler
    // 2. Run Discover(pkgPath)
    // 3. Assert error with clear message
}
----

=== 3.3 Implement discovery

Create `cmd/portsql-api-httpgen/discover.go`:

[source,go]
----
package main

func Discover(pkgPath string) (*Manifest, error) {
    // 1. Create temp dir
    // 2. Write runner main.go that imports pkgPath
    // 3. Execute `go run` and capture stdout
    // 4. Parse JSON manifest from stdout
    // 5. Return manifest
}

func GenerateRunnerCode(pkgPath string) string {
    // Generate main.go that:
    // - imports pkgPath
    // - creates portapi.App
    // - calls Register(app)
    // - validates all endpoints
    // - prints JSON manifest to stdout
}
----

== Step 4: Code generation

=== 4.1 Write tests for generated code

Create `cmd/portsql-api-httpgen/generate_test.go`:

[source,go]
----
func TestGenerate(t *testing.T) {
    t.Run("generates valid Go", func(t *testing.T) {
        m := Manifest{Endpoints: []ManifestEndpoint{
            {Method: "GET", Path: "/pets", HandlerPkg: "example/pets", HandlerName: "List", Shape: "ctx_resp_err"},
        }}

        code, err := Generate(m, "api")
        require.NoError(t, err)

        // Parse with go/parser
        _, err = parser.ParseFile(token.NewFileSet(), "", code, 0)
        require.NoError(t, err, "generated code must parse")
    })

    t.Run("includes DO NOT EDIT header", func(t *testing.T) {
        code, _ := Generate(Manifest{}, "api")
        assert.Contains(t, code, "DO NOT EDIT")
    })

    t.Run("registers all endpoints", func(t *testing.T) {
        m := Manifest{Endpoints: []ManifestEndpoint{
            {Method: "GET", Path: "/pets", HandlerPkg: "example/pets", HandlerName: "List", Shape: "ctx_resp_err"},
            {Method: "POST", Path: "/pets", HandlerPkg: "example/pets", HandlerName: "Create", Shape: "ctx_req_resp_err"},
        }}

        code, _ := Generate(m, "api")
        assert.Contains(t, code, `"GET /pets"`)
        assert.Contains(t, code, `"POST /pets"`)
    })

    t.Run("deterministic output", func(t *testing.T) {
        m := Manifest{Endpoints: []ManifestEndpoint{
            {Method: "POST", Path: "/b", HandlerPkg: "x", HandlerName: "B", Shape: "ctx_err"},
            {Method: "GET", Path: "/a", HandlerPkg: "x", HandlerName: "A", Shape: "ctx_err"},
        }}

        code1, _ := Generate(m, "api")
        code2, _ := Generate(m, "api")
        assert.Equal(t, code1, code2)
    })
}
----

=== 4.2 Write property tests for determinism

[source,go]
----
//go:build property

func TestProperty_Generate_Deterministic(t *testing.T) {
    // Generate random valid manifests
    // Generate code twice
    // Assert byte-identical
}

func TestProperty_Generate_AlwaysParses(t *testing.T) {
    // Generate random valid manifests
    // Generate code
    // Assert go/parser.ParseFile succeeds
}
----

=== 4.3 Implement code generation

Create `cmd/portsql-api-httpgen/generate.go`:

[source,go]
----
package main

import (
    "bytes"
    "go/format"
    "sort"
    "text/template"
)

var tmpl = template.Must(template.New("mux").Parse(`// Code generated by portsql-api-httpgen. DO NOT EDIT.

package {{.Package}}

import (
    "net/http"
{{range .Imports}}
    "{{.}}"
{{end}}
    "{{.RuntimeImport}}"
)

func NewMux() *http.ServeMux {
    mux := http.NewServeMux()
{{range .Endpoints}}
    mux.Handle("{{.Pattern}}", runtime.{{.WrapperFunc}}({{.HandlerRef}}))
{{end}}
    return mux
}
`))

func Generate(m Manifest, pkgName string) (string, error) {
    // 1. Sort endpoints for determinism
    // 2. Collect imports
    // 3. Execute template
    // 4. Run gofmt
}
----

== Step 5: Main entry point

=== 5.1 Write integration test for full pipeline

[source,go]
----
//go:build integration

func TestMain_EndToEnd(t *testing.T) {
    // 1. Create temp module with api/ package
    // 2. Create portsql-api-httpgen.ini
    // 3. Run main()
    // 4. Assert zz_generated_http.go exists
    // 5. Compile and run HTTP tests against NewMux()
}
----

=== 5.2 Implement main

Create `cmd/portsql-api-httpgen/main.go`:

[source,go]
----
package main

import (
    "fmt"
    "os"
    "path/filepath"
)

func main() {
    if err := run(); err != nil {
        fmt.Fprintf(os.Stderr, "error: %v\n", err)
        os.Exit(1)
    }
}

func run() error {
    // 1. Find and load config
    cfgPath, err := FindConfig()
    if err != nil {
        return err
    }
    cfg, err := LoadConfig(cfgPath)
    if err != nil {
        return err
    }

    // 2. Discover endpoints
    manifest, err := Discover(cfg.Package)
    if err != nil {
        return err
    }

    // 3. Generate code
    pkgName := filepath.Base(cfg.Package)
    code, err := Generate(*manifest, pkgName)
    if err != nil {
        return err
    }

    // 4. Write output
    outPath := filepath.Join(cfg.Package, "zz_generated_http.go")
    return os.WriteFile(outPath, []byte(code), 0644)
}
----

== Verification checklist

- [ ] `go test ./cmd/portsql-api-httpgen/...` passes
- [ ] `go test -tags=integration ./cmd/portsql-api-httpgen/...` passes
- [ ] Generated code compiles
- [ ] Generated code is deterministic (same input → identical bytes)
- [ ] Clear errors for missing config, invalid handlers

== Files created

----
cmd/portsql-api-httpgen/
  main.go
  config.go
  config_test.go
  discover.go
  discover_test.go
  manifest.go
  manifest_test.go
  generate.go
  generate_test.go
----
