= Phase 1: Endpoint Model + Registry
:toc:
:toclevels: 3

Implements the core data model (`Endpoint`) and the registration API (`portapi.App`).

== Goal

Build the foundation for endpoint recording—pure data structures with no HTTP logic. Everything here is unit-testable without network, filesystem, or external processes.

== Deliverables

- `api/portapi/endpoint.go` — `Endpoint` struct + method/path normalization
- `api/portapi/app.go` — `App` registry with `Get/Post/Put/Delete`
- `api/portapi/sort.go` — deterministic sorting of endpoints
- Comprehensive unit tests for all of the above

== Step 1: Define the `Endpoint` struct

=== 1.1 Write tests for `Endpoint` creation

Create `api/portapi/endpoint_test.go`.

Test cases:

[source,go]
----
func TestEndpoint_NewEndpoint(t *testing.T) {
    tests := []struct {
        name       string
        method     string
        path       string
        wantErr    bool
        wantMethod string // normalized
        wantPath   string // normalized
    }{
        // Valid cases
        {name: "GET lowercase", method: "get", path: "/pets", wantMethod: "GET", wantPath: "/pets"},
        {name: "POST mixed case", method: "Post", path: "/pets", wantMethod: "POST", wantPath: "/pets"},
        {name: "PUT uppercase", method: "PUT", path: "/pets/{id}", wantMethod: "PUT", wantPath: "/pets/{id}"},
        {name: "DELETE", method: "DELETE", path: "/pets/{id}", wantMethod: "DELETE", wantPath: "/pets/{id}"},

        // Path normalization
        {name: "trailing slash removed", method: "GET", path: "/pets/", wantMethod: "GET", wantPath: "/pets"},
        {name: "root path stays", method: "GET", path: "/", wantMethod: "GET", wantPath: "/"},

        // Invalid cases
        {name: "empty method", method: "", path: "/pets", wantErr: true},
        {name: "unsupported method", method: "PATCH", path: "/pets", wantErr: true},
        {name: "empty path", method: "GET", path: "", wantErr: true},
        {name: "path without leading slash", method: "GET", path: "pets", wantErr: true},
    }
    // ... table-driven test implementation
}
----

=== 1.2 Implement `NewEndpoint`

Create `api/portapi/endpoint.go`:

[source,go]
----
package portapi

import (
    "errors"
    "strings"
)

// Endpoint represents a registered HTTP endpoint.
type Endpoint struct {
    Method      string // normalized: GET, POST, PUT, DELETE
    Path        string // e.g. "/pets/{id}"
    HandlerPkg  string // import path, e.g. "example.com/app/pets"
    HandlerName string // symbol name, e.g. "CreatePet"
    Handler     any    // the actual handler value (used during discovery)
}

var allowedMethods = map[string]bool{
    "GET": true, "POST": true, "PUT": true, "DELETE": true,
}

func NewEndpoint(method, path string, handler any) (Endpoint, error) {
    // Normalize method
    m := strings.ToUpper(strings.TrimSpace(method))
    if m == "" {
        return Endpoint{}, errors.New("method cannot be empty")
    }
    if !allowedMethods[m] {
        return Endpoint{}, errors.New("unsupported method: " + method)
    }

    // Validate and normalize path
    p := strings.TrimSpace(path)
    if p == "" {
        return Endpoint{}, errors.New("path cannot be empty")
    }
    if !strings.HasPrefix(p, "/") {
        return Endpoint{}, errors.New("path must start with /")
    }
    // Remove trailing slash (except for root)
    if len(p) > 1 && strings.HasSuffix(p, "/") {
        p = strings.TrimSuffix(p, "/")
    }

    return Endpoint{Method: m, Path: p, Handler: handler}, nil
}
----

=== 1.3 Write tests for path variable extraction

Test cases for extracting `{x}` variables from path patterns:

[source,go]
----
func TestEndpoint_PathVariables(t *testing.T) {
    tests := []struct {
        path string
        want []string
    }{
        {"/pets", nil},
        {"/pets/{id}", []string{"id"}},
        {"/users/{user_id}/posts/{post_id}", []string{"user_id", "post_id"}},
        {"/files/{path...}", []string{"path"}}, // wildcard suffix
    }
    // ...
}
----

=== 1.4 Implement `PathVariables`

Add method to `Endpoint`:

[source,go]
----
func (e Endpoint) PathVariables() []string {
    // Parse {x} and {x...} from e.Path
}
----

== Step 2: Implement `App` registry

=== 2.1 Write tests for endpoint registration

Create `api/portapi/app_test.go`:

[source,go]
----
func TestApp_Register(t *testing.T) {
    dummyHandler := func() {}

    t.Run("Get registers GET endpoint", func(t *testing.T) {
        app := &App{}
        app.Get("/pets", dummyHandler)

        endpoints := app.Endpoints()
        require.Len(t, endpoints, 1)
        assert.Equal(t, "GET", endpoints[0].Method)
        assert.Equal(t, "/pets", endpoints[0].Path)
    })

    t.Run("Post registers POST endpoint", func(t *testing.T) {
        app := &App{}
        app.Post("/pets", dummyHandler)

        endpoints := app.Endpoints()
        require.Len(t, endpoints, 1)
        assert.Equal(t, "POST", endpoints[0].Method)
    })

    t.Run("multiple registrations", func(t *testing.T) {
        app := &App{}
        app.Get("/pets", dummyHandler)
        app.Post("/pets", dummyHandler)
        app.Get("/users", dummyHandler)

        endpoints := app.Endpoints()
        assert.Len(t, endpoints, 3)
    })
}
----

=== 2.2 Write tests for registration validation errors

[source,go]
----
func TestApp_Register_Errors(t *testing.T) {
    app := &App{}

    t.Run("panics on empty path", func(t *testing.T) {
        assert.Panics(t, func() {
            app.Get("", func() {})
        })
    })

    t.Run("panics on path without leading slash", func(t *testing.T) {
        assert.Panics(t, func() {
            app.Get("pets", func() {})
        })
    })

    t.Run("panics on nil handler", func(t *testing.T) {
        assert.Panics(t, func() {
            app.Get("/pets", nil)
        })
    })
}
----

=== 2.3 Implement `App`

Create `api/portapi/app.go`:

[source,go]
----
package portapi

// App records endpoint registrations during discovery.
// It is not used at runtime—only during build-time codegen.
type App struct {
    endpoints []Endpoint
}

func (a *App) Get(path string, handler any)    { a.register("GET", path, handler) }
func (a *App) Post(path string, handler any)   { a.register("POST", path, handler) }
func (a *App) Put(path string, handler any)    { a.register("PUT", path, handler) }
func (a *App) Delete(path string, handler any) { a.register("DELETE", path, handler) }

func (a *App) register(method, path string, handler any) {
    if handler == nil {
        panic("handler cannot be nil")
    }
    ep, err := NewEndpoint(method, path, handler)
    if err != nil {
        panic(err)
    }
    a.endpoints = append(a.endpoints, ep)
}

// Endpoints returns a copy of all registered endpoints.
func (a *App) Endpoints() []Endpoint {
    return append([]Endpoint(nil), a.endpoints...)
}
----

== Step 3: Deterministic sorting

=== 3.1 Write tests for endpoint sorting

Create `api/portapi/sort_test.go`:

[source,go]
----
func TestSortEndpoints(t *testing.T) {
    t.Run("sorts by method then path", func(t *testing.T) {
        endpoints := []Endpoint{
            {Method: "POST", Path: "/pets"},
            {Method: "GET", Path: "/users"},
            {Method: "GET", Path: "/pets"},
            {Method: "DELETE", Path: "/pets/{id}"},
        }

        sorted := SortEndpoints(endpoints)

        // Expected order: DELETE /pets/{id}, GET /pets, GET /users, POST /pets
        assert.Equal(t, "DELETE", sorted[0].Method)
        assert.Equal(t, "/pets/{id}", sorted[0].Path)
        assert.Equal(t, "GET", sorted[1].Method)
        assert.Equal(t, "/pets", sorted[1].Path)
        assert.Equal(t, "GET", sorted[2].Method)
        assert.Equal(t, "/users", sorted[2].Path)
        assert.Equal(t, "POST", sorted[3].Method)
    })

    t.Run("stable sort with same method/path uses handler identity", func(t *testing.T) {
        endpoints := []Endpoint{
            {Method: "GET", Path: "/pets", HandlerPkg: "b/pkg", HandlerName: "B"},
            {Method: "GET", Path: "/pets", HandlerPkg: "a/pkg", HandlerName: "A"},
        }

        sorted := SortEndpoints(endpoints)

        assert.Equal(t, "a/pkg", sorted[0].HandlerPkg)
        assert.Equal(t, "b/pkg", sorted[1].HandlerPkg)
    })

    t.Run("does not mutate original slice", func(t *testing.T) {
        original := []Endpoint{
            {Method: "POST", Path: "/b"},
            {Method: "GET", Path: "/a"},
        }
        originalCopy := append([]Endpoint(nil), original...)

        _ = SortEndpoints(original)

        assert.Equal(t, originalCopy, original)
    })
}
----

=== 3.2 Write property tests for sort determinism

[source,go]
----
//go:build property

func TestProperty_SortEndpoints_Deterministic(t *testing.T) {
    // Generate random valid endpoints
    // Sort twice with same input
    // Assert outputs are byte-identical
}

func TestProperty_SortEndpoints_Idempotent(t *testing.T) {
    // Sort once, sort again
    // Assert sort(sort(x)) == sort(x)
}
----

=== 3.3 Implement `SortEndpoints`

Create `api/portapi/sort.go`:

[source,go]
----
package portapi

import (
    "cmp"
    "slices"
)

// SortKey returns a stable string key for sorting.
func (e Endpoint) SortKey() string {
    return e.Method + " " + e.Path + " " + e.HandlerPkg + "." + e.HandlerName
}

// SortEndpoints returns a new slice sorted deterministically.
// Does not mutate the input.
func SortEndpoints(endpoints []Endpoint) []Endpoint {
    sorted := append([]Endpoint(nil), endpoints...)
    slices.SortFunc(sorted, func(a, b Endpoint) int {
        return cmp.Compare(a.SortKey(), b.SortKey())
    })
    return sorted
}
----

== Step 4: Mux pattern generation

=== 4.1 Write tests for Go 1.22 mux pattern format

[source,go]
----
func TestEndpoint_MuxPattern(t *testing.T) {
    tests := []struct {
        method string
        path   string
        want   string
    }{
        {"GET", "/pets", "GET /pets"},
        {"POST", "/pets", "POST /pets"},
        {"GET", "/pets/{id}", "GET /pets/{id}"},
        {"DELETE", "/users/{user_id}/posts/{post_id}", "DELETE /users/{user_id}/posts/{post_id}"},
    }

    for _, tt := range tests {
        ep := Endpoint{Method: tt.method, Path: tt.path}
        assert.Equal(t, tt.want, ep.MuxPattern())
    }
}
----

=== 4.2 Implement `MuxPattern`

[source,go]
----
// MuxPattern returns the Go 1.22+ ServeMux pattern string.
func (e Endpoint) MuxPattern() string {
    return e.Method + " " + e.Path
}
----

== Verification checklist

After completing Phase 1, verify:

- [ ] `go test ./api/portapi/...` passes
- [ ] `go test -tags=property ./api/portapi/...` passes (if property tests exist)
- [ ] `go vet ./api/portapi/...` clean
- [ ] Code coverage > 90% for endpoint.go, app.go, sort.go

== Files created

----
api/portapi/
  endpoint.go
  endpoint_test.go
  app.go
  app_test.go
  sort.go
  sort_test.go
----
