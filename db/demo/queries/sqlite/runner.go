// Code generated by portsql. DO NOT EDIT.
package sqlite

import (
	"context"
	"database/sql"

	"github.com/shipq/shipq/nanoid"
	"github.com/shipq/shipq/db/demo/queries"
)

// Querier is the interface for executing queries.
type Querier interface {
	ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error)
	QueryContext(ctx context.Context, query string, args ...any) (*sql.Rows, error)
	QueryRowContext(ctx context.Context, query string, args ...any) *sql.Row
}

// QueryRunner for sqlite.
type QueryRunner struct {
	db Querier

	// User-defined query SQL strings
	findPetsByStatusSQL       string
	getOrderByIdSQL           string
	getPetByIdSQL             string
	getPetWithPhotosSQL       string
	getUserByUsernameSQL      string
	listCategoriesWithPetsSQL string
	listPetsWithCategorySQL   string

	// Users CRUD SQL strings
	getUserSQL        string
	listUsersSQL      string
	insertUserSQL     string
	updateUserSQL     string
	deleteUserSQL     string
	hardDeleteUserSQL string
}

// NewQueryRunner creates a sqlite query runner.
func NewQueryRunner(db Querier) *QueryRunner {
	return &QueryRunner{
		db:                        db,
		findPetsByStatusSQL:       "SELECT \"pets\".\"id\", \"pets\".\"name\", \"pets\".\"category_id\", \"pets\".\"status\" FROM \"pets\" WHERE (\"pets\".\"status\" = ?)",
		getOrderByIdSQL:           "SELECT \"orders\".\"id\", \"orders\".\"pet_id\", \"orders\".\"quantity\", \"orders\".\"ship_date\", \"orders\".\"status\", \"orders\".\"complete\" FROM \"orders\" WHERE (\"orders\".\"id\" = ?)",
		getPetByIdSQL:             "SELECT \"pets\".\"id\", \"pets\".\"name\", \"pets\".\"category_id\", \"pets\".\"status\", \"pets\".\"photo_urls\" FROM \"pets\" WHERE (\"pets\".\"id\" = ?)",
		getPetWithPhotosSQL:       "SELECT \"pets\".\"id\", \"pets\".\"name\", \"pets\".\"photo_urls\", \"pets\".\"status\", \"categories\".\"name\" AS \"category_name\" FROM \"pets\" INNER JOIN \"categories\" ON (\"pets\".\"category_id\" = \"categories\".\"id\") WHERE (\"pets\".\"id\" = ?)",
		getUserByUsernameSQL:      "SELECT \"users\".\"id\", \"users\".\"public_id\", \"users\".\"username\", \"users\".\"first_name\", \"users\".\"last_name\", \"users\".\"email\", \"users\".\"created_at\" FROM \"users\" WHERE (\"users\".\"username\" = ?)",
		listCategoriesWithPetsSQL: "SELECT \"categories\".\"id\", \"categories\".\"name\", COALESCE(JSON_GROUP_ARRAY(JSON_OBJECT('id', \"pets\".\"id\", 'name', \"pets\".\"name\", 'status', \"pets\".\"status\")), '[]') AS \"pets\" FROM \"categories\" LEFT JOIN \"pets\" ON (\"categories\".\"id\" = \"pets\".\"category_id\") GROUP BY \"categories\".\"id\", \"categories\".\"name\"",
		listPetsWithCategorySQL:   "SELECT \"pets\".\"id\", \"pets\".\"name\", \"pets\".\"status\", \"categories\".\"name\" AS \"category_name\" FROM \"pets\" INNER JOIN \"categories\" ON (\"pets\".\"category_id\" = \"categories\".\"id\")",
		getUserSQL:                "SELECT \"public_id\", \"created_at\", \"updated_at\", \"username\", \"first_name\", \"last_name\", \"email\", \"password\", \"phone\", \"user_status\" FROM \"users\" WHERE \"public_id\" = ? AND \"deleted_at\" IS NULL",
		listUsersSQL:              "SELECT \"public_id\", \"created_at\", \"username\", \"first_name\", \"last_name\", \"email\", \"password\", \"phone\", \"user_status\" FROM \"users\" WHERE \"deleted_at\" IS NULL ORDER BY \"created_at\" DESC LIMIT ? OFFSET ?",
		insertUserSQL:             "INSERT INTO \"users\" (\"public_id\", \"username\", \"first_name\", \"last_name\", \"email\", \"password\", \"phone\", \"user_status\", \"created_at\", \"updated_at\") VALUES (?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now')) RETURNING \"public_id\"",
		updateUserSQL:             "UPDATE \"users\" SET \"username\" = ?, \"first_name\" = ?, \"last_name\" = ?, \"email\" = ?, \"password\" = ?, \"phone\" = ?, \"user_status\" = ?, \"updated_at\" = datetime('now') WHERE \"public_id\" = ? AND \"deleted_at\" IS NULL",
		deleteUserSQL:             "UPDATE \"users\" SET \"deleted_at\" = datetime('now') WHERE \"public_id\" = ? AND \"deleted_at\" IS NULL",
		hardDeleteUserSQL:         "DELETE FROM \"users\" WHERE \"public_id\" = ?",
	}
}

// WithTx returns a new QueryRunner using the given transaction.
func (r *QueryRunner) WithTx(tx *sql.Tx) *QueryRunner {
	return &QueryRunner{
		db:                        tx,
		findPetsByStatusSQL:       r.findPetsByStatusSQL,
		getOrderByIdSQL:           r.getOrderByIdSQL,
		getPetByIdSQL:             r.getPetByIdSQL,
		getPetWithPhotosSQL:       r.getPetWithPhotosSQL,
		getUserByUsernameSQL:      r.getUserByUsernameSQL,
		listCategoriesWithPetsSQL: r.listCategoriesWithPetsSQL,
		listPetsWithCategorySQL:   r.listPetsWithCategorySQL,
		getUserSQL:                r.getUserSQL,
		listUsersSQL:              r.listUsersSQL,
		insertUserSQL:             r.insertUserSQL,
		updateUserSQL:             r.updateUserSQL,
		deleteUserSQL:             r.deleteUserSQL,
		hardDeleteUserSQL:         r.hardDeleteUserSQL,
	}
}

// FindPetsByStatus executes the query and returns all results.
func (r *QueryRunner) FindPetsByStatus(ctx context.Context, params queries.FindPetsByStatusParams) ([]queries.FindPetsByStatusResult, error) {
	args := []any{
		params.Status,
	}

	rows, err := r.db.QueryContext(ctx, r.findPetsByStatusSQL, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []queries.FindPetsByStatusResult
	for rows.Next() {
		var item queries.FindPetsByStatusResult
		err := rows.Scan(
			&item.Id,
			&item.Name,
			&item.CategoryId,
			&item.Status,
		)
		if err != nil {
			return nil, err
		}
		results = append(results, item)
	}

	if err := rows.Err(); err != nil {
		return nil, err
	}
	return results, nil
}

// GetOrderById executes the query and returns at most one result.
func (r *QueryRunner) GetOrderById(ctx context.Context, params queries.GetOrderByIdParams) (*queries.GetOrderByIdResult, error) {
	args := []any{
		params.Id,
	}

	row := r.db.QueryRowContext(ctx, r.getOrderByIdSQL, args...)

	var result queries.GetOrderByIdResult
	err := row.Scan(
		&result.Id,
		&result.PetId,
		&result.Quantity,
		&result.ShipDate,
		&result.Status,
		&result.Complete,
	)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}
	return &result, nil
}

// GetPetById executes the query and returns at most one result.
func (r *QueryRunner) GetPetById(ctx context.Context, params queries.GetPetByIdParams) (*queries.GetPetByIdResult, error) {
	args := []any{
		params.Id,
	}

	row := r.db.QueryRowContext(ctx, r.getPetByIdSQL, args...)

	var result queries.GetPetByIdResult
	var photo_urlsStr string
	err := row.Scan(
		&result.Id,
		&result.Name,
		&result.CategoryId,
		&result.Status,
		&photo_urlsStr,
	)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}
	result.PhotoUrls = []byte(photo_urlsStr)
	return &result, nil
}

// GetPetWithPhotos executes the query and returns at most one result.
func (r *QueryRunner) GetPetWithPhotos(ctx context.Context, params queries.GetPetWithPhotosParams) (*queries.GetPetWithPhotosResult, error) {
	args := []any{
		params.Id,
	}

	row := r.db.QueryRowContext(ctx, r.getPetWithPhotosSQL, args...)

	var result queries.GetPetWithPhotosResult
	var photo_urlsStr string
	err := row.Scan(
		&result.Id,
		&result.Name,
		&photo_urlsStr,
		&result.Status,
		&result.CategoryName,
	)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}
	result.PhotoUrls = []byte(photo_urlsStr)
	return &result, nil
}

// GetUserByUsername executes the query and returns at most one result.
func (r *QueryRunner) GetUserByUsername(ctx context.Context, params queries.GetUserByUsernameParams) (*queries.GetUserByUsernameResult, error) {
	args := []any{
		params.Username,
	}

	row := r.db.QueryRowContext(ctx, r.getUserByUsernameSQL, args...)

	var result queries.GetUserByUsernameResult
	err := row.Scan(
		&result.Id,
		&result.PublicId,
		&result.Username,
		&result.FirstName,
		&result.LastName,
		&result.Email,
		&result.CreatedAt,
	)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}
	return &result, nil
}

// ListCategoriesWithPets executes the query and returns all results.
func (r *QueryRunner) ListCategoriesWithPets(ctx context.Context) ([]queries.ListCategoriesWithPetsResult, error) {
	rows, err := r.db.QueryContext(ctx, r.listCategoriesWithPetsSQL)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []queries.ListCategoriesWithPetsResult
	for rows.Next() {
		var item queries.ListCategoriesWithPetsResult
		err := rows.Scan(
			&item.Id,
			&item.Name,
			&item.Pets,
		)
		if err != nil {
			return nil, err
		}
		results = append(results, item)
	}

	if err := rows.Err(); err != nil {
		return nil, err
	}
	return results, nil
}

// ListPetsWithCategory executes the query and returns all results.
func (r *QueryRunner) ListPetsWithCategory(ctx context.Context) ([]queries.ListPetsWithCategoryResult, error) {
	rows, err := r.db.QueryContext(ctx, r.listPetsWithCategorySQL)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []queries.ListPetsWithCategoryResult
	for rows.Next() {
		var item queries.ListPetsWithCategoryResult
		err := rows.Scan(
			&item.Id,
			&item.Name,
			&item.Status,
			&item.CategoryName,
		)
		if err != nil {
			return nil, err
		}
		results = append(results, item)
	}

	if err := rows.Err(); err != nil {
		return nil, err
	}
	return results, nil
}

// GetUser fetches a single user by its identifier.
func (r *QueryRunner) GetUser(ctx context.Context, params queries.GetUserParams) (*queries.GetUserResult, error) {
	var args []any
	args = append(args, params.PublicID)

	row := r.db.QueryRowContext(ctx, r.getUserSQL, args...)

	var result queries.GetUserResult
	err := row.Scan(
		&result.PublicId,
		&result.CreatedAt,
		&result.UpdatedAt,
		&result.Username,
		&result.FirstName,
		&result.LastName,
		&result.Email,
		&result.Password,
		&result.Phone,
		&result.UserStatus,
	)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}
	return &result, nil
}

// ListUsers fetches a paginated list of users.
func (r *QueryRunner) ListUsers(ctx context.Context, params queries.ListUsersParams) ([]queries.ListUsersResult, error) {
	r.ListUsers(ctx, queries.ListUsersParams{
		
	})
	var args []any
	args = append(args, params.Limit, params.Offset)

	rows, err := r.db.QueryContext(ctx, r.listUsersSQL, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []queries.ListUsersResult
	for rows.Next() {
		var item queries.ListUsersResult
		err := rows.Scan(
			&item.PublicId,
			&item.CreatedAt,
			&item.Username,
			&item.FirstName,
			&item.LastName,
			&item.Email,
			&item.Password,
			&item.Phone,
			&item.UserStatus,
		)
		if err != nil {
			return nil, err
		}
		results = append(results, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return results, nil
}

// InsertUser inserts a new user and returns its public ID.
func (r *QueryRunner) InsertUser(ctx context.Context, params queries.InsertUserParams) (string, error) {
	publicID := nanoid.New()

	var args []any
	args = append(args, publicID)
	args = append(args, params.Username)
	args = append(args, params.FirstName)
	args = append(args, params.LastName)
	args = append(args, params.Email)
	args = append(args, params.Password)
	args = append(args, params.Phone)
	args = append(args, params.UserStatus)

	var returnedID string
	err := r.db.QueryRowContext(ctx, r.insertUserSQL, args...).Scan(&returnedID)
	if err != nil {
		return "", err
	}
	return returnedID, nil
}

// UpdateUser updates an existing user.
func (r *QueryRunner) UpdateUser(ctx context.Context, params queries.UpdateUserParams) error {
	var args []any
	args = append(args, params.Username)
	args = append(args, params.FirstName)
	args = append(args, params.LastName)
	args = append(args, params.Email)
	args = append(args, params.Password)
	args = append(args, params.Phone)
	args = append(args, params.UserStatus)
	args = append(args, params.PublicID)

	_, err := r.db.ExecContext(ctx, r.updateUserSQL, args...)
	return err
}

// DeleteUser soft-deletes a user (or hard-deletes if no deleted_at column).
func (r *QueryRunner) DeleteUser(ctx context.Context, params queries.DeleteUserParams) error {
	_, err := r.db.ExecContext(ctx, r.deleteUserSQL, params.PublicID)
	return err
}

// HardDeleteUser permanently deletes a user.
func (r *QueryRunner) HardDeleteUser(ctx context.Context, params queries.HardDeleteUserParams) error {
	_, err := r.db.ExecContext(ctx, r.hardDeleteUserSQL, params.PublicID)
	return err
}
