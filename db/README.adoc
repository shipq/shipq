= PortSQL

A database-agnostic, SQL-first code generation tool for Go.

== Motivation

Most Go database tools fall into two camps:

1. **ORMs** (GORM, ent) - Hide SQL behind an abstraction layer. You lose control over the queries that actually run, and debugging performance issues means diving into generated SQL you didn't write.

2. **SQL-first tools** (sqlc) - Write raw SQL, generate Go code. Great for control, but you're locked into one database dialect.

**PortSQL takes a different approach**: define your schema and queries in Go, and we generate type-safe, raw SQL for PostgreSQL, MySQL, and SQLite. You get:

- **Full control** over the exact SQL that runs
- **Type safety** at compile time
- **Database portability** without rewriting queries
- **No runtime reflection** or query building overhead

== The Two-Phase Workflow

PortSQL uses two code generation phases:

[source]
----
┌─────────────────────────────────────────────────────────────────┐
│                    PHASE 1: Schema Codegen                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   Define migrations in Go                                        │
│           │                                                      │
│           ▼                                                      │
│   ┌───────────────────┐                                          │
│   │  MigrationPlan    │                                          │
│   │  (Schema + SQL)   │                                          │
│   └───────────────────┘                                          │
│           │                                                      │
│           ├──────────────────┬──────────────────┐                │
│           ▼                  ▼                  ▼                │
│   ┌────────────────┐  ┌────────────────┐  ┌────────────────┐     │
│   │ Migration SQL  │  │ Table Structs  │  │ Column Types   │     │
│   │ (per database) │  │ (Users, Posts) │  │ (Int64Column,  │     │
│   │                │  │                │  │  StringColumn) │     │
│   └────────────────┘  └────────────────┘  └────────────────┘     │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    PHASE 2: Query Codegen                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   Define queries using generated schema types                    │
│           │                                                      │
│           ▼                                                      │
│   ┌───────────────────┐                                          │
│   │  Query AST        │                                          │
│   │  (type-checked)   │                                          │
│   └───────────────────┘                                          │
│           │                                                      │
│           ├──────────────────┬──────────────────┐                │
│           ▼                  ▼                  ▼                │
│   ┌────────────────┐  ┌────────────────┐  ┌────────────────┐     │
│   │ SQL Strings    │  │ Param Structs  │  │ Result Structs │     │
│   │ (per database) │  │ (typed inputs) │  │ (typed output) │     │
│   └────────────────┘  └────────────────┘  └────────────────┘     │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
----

== Quick Example

=== Step 1: Define Your Schema

[source,go]
----
package migrations

import (
    "github.com/shipq/shipq/db/portsql/ddl"
    "github.com/shipq/shipq/db/portsql/migrate"
)

func Migrate_20260111170659_create_users(plan *migrate.MigrationPlan) error {
    // AddTable includes standard columns: id, public_id, created_at, deleted_at, updated_at
    _, err := plan.AddTable("users", func(tb *ddl.TableBuilder) error {
        tb.String("name")
        tb.String("email").Unique()
        tb.Datetime("last_login").Nullable()
        return nil
    })
    return err
}

func Migrate_20260111170700_create_posts(plan *migrate.MigrationPlan) error {
    // AddEmptyTable creates a table with no default columns
    _, err := plan.AddEmptyTable("posts", func(tb *ddl.TableBuilder) error {
        tb.Bigint("id").PrimaryKey()
        tb.Bigint("author_id").Indexed()
        tb.String("title")
        tb.Text("body").Nullable()
        tb.Datetime("published_at").Nullable()
        return nil
    })
    return err
}
----

**Run `portsql migrate up`** → Generates `schematypes/tables.go`:

[source,go]
----
// Code generated by portsql. DO NOT EDIT.
package schema

import "github.com/shipq/shipq/db/portsql/query"

// UsersTable provides type-safe column references for the users table.
type UsersTable struct{}

var Users = UsersTable{}

func (UsersTable) TableName() string { return "users" }

func (UsersTable) Id() query.Int64Column       { return query.Int64Column{Table: "users", Name: "id"} }
func (UsersTable) PublicId() query.StringColumn { return query.StringColumn{Table: "users", Name: "public_id"} }
func (UsersTable) Name() query.StringColumn    { return query.StringColumn{Table: "users", Name: "name"} }
func (UsersTable) Email() query.StringColumn   { return query.StringColumn{Table: "users", Name: "email"} }
func (UsersTable) LastLogin() query.NullTimeColumn { return query.NullTimeColumn{Table: "users", Name: "last_login"} }
func (UsersTable) CreatedAt() query.TimeColumn { return query.TimeColumn{Table: "users", Name: "created_at"} }
func (UsersTable) UpdatedAt() query.TimeColumn { return query.TimeColumn{Table: "users", Name: "updated_at"} }
func (UsersTable) DeletedAt() query.TimeColumn { return query.TimeColumn{Table: "users", Name: "deleted_at"} }

// PostsTable provides type-safe column references for the posts table.
type PostsTable struct{}

var Posts = PostsTable{}

func (PostsTable) TableName() string { return "posts" }

func (PostsTable) Id() query.Int64Column            { return query.Int64Column{Table: "posts", Name: "id"} }
func (PostsTable) AuthorId() query.Int64Column      { return query.Int64Column{Table: "posts", Name: "author_id"} }
func (PostsTable) Title() query.StringColumn        { return query.StringColumn{Table: "posts", Name: "title"} }
func (PostsTable) Body() query.NullStringColumn     { return query.NullStringColumn{Table: "posts", Name: "body"} }
func (PostsTable) PublishedAt() query.NullTimeColumn { return query.NullTimeColumn{Table: "posts", Name: "published_at"} }
----

=== Step 2: Define Your Queries

Using the generated schema, define type-safe queries with explicit return types:

[source,go]
----
package querydef

import (
    "myapp/schematypes"
    "github.com/shipq/shipq/db/portsql/query"
)

func init() {
    // MustDefineOne - returns 0 or 1 row (*Result or nil)
    query.MustDefineOne("GetUserByEmail",
        query.From(schematypes.Users).
            Select(
                schematypes.Users.Id(),
                schematypes.Users.Name(),
                schematypes.Users.Email(),
            ).
            Where(schematypes.Users.Email().Eq(query.Param[string]("email"))).
            Build(),
    )

    // MustDefineOne with JSON aggregation - user with their posts
    query.MustDefineOne("GetUserWithPosts",
        query.From(schematypes.Users).
            LeftJoin(schematypes.Posts).On(schematypes.Users.Id().Eq(schematypes.Posts.AuthorId())).
            Select(
                schematypes.Users.Id(),
                schematypes.Users.Name(),
            ).
            SelectJSONAgg("posts",
                schematypes.Posts.Id(),
                schematypes.Posts.Title(),
                schematypes.Posts.PublishedAt(),
            ).
            Where(schematypes.Users.Id().Eq(query.Param[int64]("user_id"))).
            GroupBy(schematypes.Users.Id(), schematypes.Users.Name()).
            Build(),
    )

    // MustDefineMany - returns 0 to N rows
    query.MustDefineMany("ListRecentPosts",
        query.From(schematypes.Posts).
            Select(
                schematypes.Posts.Id(),
                schematypes.Posts.Title(),
                schematypes.Posts.AuthorId(),
                schematypes.Posts.PublishedAt(),
            ).
            Where(schematypes.Posts.PublishedAt().IsNotNull()).
            OrderBy(schematypes.Posts.PublishedAt().Desc()).
            Limit(query.Param[int]("limit")).
            Offset(query.Param[int]("offset")).
            Build(),
    )

    // MustDefineExec - for INSERT/UPDATE/DELETE (returns sql.Result)
    query.MustDefineExec("DeleteExpiredSessions",
        query.Delete(schematypes.Sessions).
            Where(schematypes.Sessions.ExpiresAt().Lt(query.Now())).
            Build(),
    )
}
----

=== Step 3: Use Generated Code in Your Application

**Run `portsql compile`** → Generates dialect-specific packages:

[source]
----
queries/
├── types.go           # Shared param/result structs
├── sqlite/
│   └── runner.go      # SQLite-specific QueryRunner
├── postgres/
│   └── runner.go      # PostgreSQL-specific QueryRunner
└── mysql/
    └── runner.go      # MySQL-specific QueryRunner
----

**Generated types** (`queries/types.go`):

[source,go]
----
// Code generated by portsql. DO NOT EDIT.
package queries

type GetUserByEmailParams struct {
    Email string
}

type GetUserByEmailResult struct {
    Id    int64
    Name  string
    Email string
}

type ListRecentPostsParams struct {
    Limit  int
    Offset int
}

type ListRecentPostsResult struct {
    Id          int64
    Title       string
    AuthorId    int64
    PublishedAt *time.Time
}

// JSON aggregation generates properly typed nested structs
type GetUserWithPostsResult struct {
    Id    int64
    Name  string
    Posts []GetUserWithPostsPostsItem
}

type GetUserWithPostsPostsItem struct {
    Id          int64
    Title       string
    PublishedAt *time.Time
}
----

**Use the QueryRunner in your application**:

[source,go]
----
import (
    "myapp/queries"
    "myapp/queries/sqlite"  // Import dialect-specific runner
)

func (s *Server) GetUser(ctx context.Context, email string) (*queries.GetUserByEmailResult, error) {
    runner := sqlite.NewQueryRunner(s.db)  // No dialect parameter needed!

    // Type-safe method with automatic scanning
    return runner.GetUserByEmail(ctx, queries.GetUserByEmailParams{Email: email})
}

func (s *Server) ListPosts(ctx context.Context, limit, offset int) ([]queries.ListRecentPostsResult, error) {
    runner := sqlite.NewQueryRunner(s.db)

    return runner.ListRecentPosts(ctx, queries.ListRecentPostsParams{
        Limit:  limit,
        Offset: offset,
    })
}
----

**Benefits of dialect-specific packages**:

- **Simpler API**: No dialect parameter - import the package you need
- **Optimized SQL**: Each dialect gets exactly the SQL it needs
- **Correct JSON handling**: SQLite returns JSON as strings; the SQLite runner handles conversion automatically
- **Smaller binaries**: Only include the dialect(s) you use

== Features

=== Database Support

|===
| Feature | PostgreSQL | MySQL | SQLite

| CREATE TABLE | ✓ | ✓ | ✓
| ALTER TABLE | ✓ | ✓ | ✓ (via table rebuild)
| SELECT/INSERT/UPDATE/DELETE | ✓ | ✓ | ✓
| JOINs (INNER, LEFT, RIGHT, FULL) | ✓ | ✓ | ✓
| JSON Aggregation | ✓ | ✓ | ✓
| CTEs (WITH clauses) | ✓ | ✓ | ✓
| Set Operations (UNION, INTERSECT, EXCEPT) | ✓ | ✓ | ✓
| Subqueries | ✓ | ✓ | ✓
| Aggregates (COUNT, SUM, AVG, MIN, MAX) | ✓ | ✓ | ✓
|===

=== Schema Column Types

PortSQL supports the following column types in your schema definitions:

|===
| Builder Method | SQL Type | Go Type | Nullable Go Type

| `Bigint(name)` | BIGINT | `int64` | `*int64`
| `Integer(name)` | INTEGER | `int32` | `*int32`
| `Float(name)` | FLOAT | `float64` | `*float64`
| `Decimal(name, precision, scale)` | DECIMAL(p,s) | `string` | `*string`
| `Bool(name)` | BOOLEAN | `bool` | `*bool`
| `String(name)` | VARCHAR(255) | `string` | `*string`
| `VarChar(name, length)` | VARCHAR(length) | `string` | `*string`
| `Text(name)` | TEXT | `string` | `*string`
| `Datetime(name)` | TIMESTAMP WITH TIME ZONE | `time.Time` | `*time.Time`
| `Timestamp(name)` | TIMESTAMP WITH TIME ZONE | `time.Time` | `*time.Time`
| `Binary(name)` | BLOB/BYTEA | `[]byte` | `[]byte`
| `JSON(name)` | JSON/JSONB | `json.RawMessage` | `json.RawMessage`
|===

Column modifiers:

- `.PrimaryKey()` - Mark as primary key (integers only)
- `.Nullable()` - Allow NULL values
- `.Unique()` - Add unique constraint and index
- `.Indexed()` - Add non-unique index
- `.Default(value)` - Set default value (type-specific)

=== Type-Safe Column Types

PortSQL generates typed column references that prevent invalid operations at compile time:

[source,go]
----
// Comparison operations (available on all column types)
schema.Users.Email().Eq(query.Param[string]("email"))
schema.Users.Email().Ne(query.Param[string]("other"))
schema.Users.Id().Lt(query.Param[int64]("max_id"))
schema.Users.Id().Le(query.Param[int64]("max_id"))
schema.Users.Id().Gt(query.Param[int64]("min_id"))
schema.Users.Id().Ge(query.Param[int64]("min_id"))

// IN clause
schema.Users.Status().In("active", "pending", "invited")

// Null checks
schema.Posts.PublishedAt().IsNull()
schema.Posts.PublishedAt().IsNotNull()

// String-specific operations
schema.Users.Name().Like(query.Param[string]("pattern"))
schema.Users.Email().ILike(query.Param[string]("search"))  // Case-insensitive

// Ordering
schema.Users.CreatedAt().Asc()
schema.Posts.PublishedAt().Desc()
----

=== Query Parameters

Use type-parameterized `Param[T]` to create type-safe parameters:

[source,go]
----
// String parameter
query.Param[string]("email")

// Integer parameters
query.Param[int64]("id")
query.Param[int]("limit")

// Nullable parameters
query.Param[*string]("optional_name")
query.Param[*time.Time]("optional_date")

// Literal values
query.Literal(100)
query.Literal("active")

// Current timestamp
query.Now()
----

=== Logical Operators

[source,go]
----
// AND
query.And(
    schema.Users.Status().Eq("active"),
    schema.Users.EmailVerified().Eq(true),
)

// OR
query.Or(
    schema.Users.Role().Eq("admin"),
    schema.Users.Role().Eq("moderator"),
)

// NOT
query.Not(schema.Users.Banned().Eq(true))
----

=== Aggregate Functions

[source,go]
----
// Count all rows
query.From(schema.Users).
    SelectCountAs("total").
    Build()

// Count with column
query.From(schema.Orders).
    SelectExprAs(query.CountCol(schema.Orders.Id()), "order_count").
    Build()

// Count distinct
query.From(schema.Orders).
    SelectExprAs(query.CountDistinct(schema.Orders.UserId()), "unique_customers").
    Build()

// Sum, Avg, Min, Max
query.From(schema.Orders).
    SelectSumAs(schema.Orders.Total(), "revenue").
    SelectAvgAs(schema.Orders.Total(), "avg_order").
    SelectMinAs(schema.Orders.Total(), "min_order").
    SelectMaxAs(schema.Orders.Total(), "max_order").
    Build()
----

=== CTEs (Common Table Expressions)

[source,go]
----
// Simple CTE
query.With("recent_orders",
    query.From(schema.Orders).
        Select(schema.Orders.UserId(), schema.Orders.Total()).
        Where(schema.Orders.CreatedAt().Gt(query.Param[time.Time]("since"))),
).
Select(query.CTERef("recent_orders")).
    Select(/* columns from CTE */).
    Build()

// Multiple CTEs
query.With("cte1", firstQuery).
    And("cte2", secondQuery).
    Select(query.CTERef("cte1")).
    Join(query.CTERef("cte2")).On(/* condition */).
    Build()
----

=== Cross-Database Translations

PortSQL handles database-specific syntax automatically:

|===
| Feature | PostgreSQL | MySQL | SQLite

| Identifier quoting | `"name"` | `` `name` `` | `"name"`
| Parameters | `$1, $2, $3` | `?, ?, ?` | `?, ?, ?`
| Boolean literals | `TRUE/FALSE` | `1/0` | `1/0`
| Current timestamp | `NOW()` | `NOW()` | `datetime('now')`
| Case-insensitive LIKE | `ILIKE` | `LOWER() LIKE LOWER()` | `LOWER() LIKE LOWER()`
| JSON object | `JSON_BUILD_OBJECT` | `JSON_OBJECT` | `JSON_OBJECT`
| JSON array agg | `JSON_AGG` | `JSON_ARRAYAGG` | `JSON_GROUP_ARRAY`
|===

=== JSON Aggregation

Fetch related data as nested JSON in a single query:

[source,go]
----
query.From(schematypes.Authors).
    LeftJoin(schematypes.Books).On(schematypes.Authors.Id().Eq(schematypes.Books.AuthorId())).
    Select(schematypes.Authors.Id(), schematypes.Authors.Name()).
    SelectJSONAgg("books",
        schematypes.Books.Id(),
        schematypes.Books.Title(),
        schematypes.Books.Price(),
    ).
    GroupBy(schematypes.Authors.Id(), schematypes.Authors.Name())
----

**Note on JSON columns**: SQLite returns JSON as `string`, while PostgreSQL and MySQL return `[]byte`. PortSQL's dialect-specific runners handle this automatically - your code uses `json.RawMessage` and it just works.

Generates database-specific JSON functions:

[source,sql]
----
-- PostgreSQL
SELECT "authors"."id", "authors"."name",
       COALESCE(JSON_AGG(JSON_BUILD_OBJECT('id', "books"."id", 'title', "books"."title", 'price', "books"."price"))
                FILTER (WHERE "books"."id" IS NOT NULL), '[]') AS "books"
FROM "authors"
LEFT JOIN "books" ON "authors"."id" = "books"."author_id"
GROUP BY "authors"."id", "authors"."name"

-- MySQL
SELECT `authors`.`id`, `authors`.`name`,
       COALESCE(JSON_ARRAYAGG(JSON_OBJECT('id', `books`.`id`, 'title', `books`.`title`, 'price', `books`.`price`)), JSON_ARRAY()) AS `books`
FROM `authors`
LEFT JOIN `books` ON `authors`.`id` = `books`.`author_id`
GROUP BY `authors`.`id`, `authors`.`name`

-- SQLite
SELECT "authors"."id", "authors"."name",
       COALESCE(JSON_GROUP_ARRAY(JSON_OBJECT('id', "books"."id", 'title', "books"."title", 'price', "books"."price")), '[]') AS "books"
FROM "authors"
LEFT JOIN "books" ON "authors"."id" = "books"."author_id"
GROUP BY "authors"."id", "authors"."name"
----

== Auto-Generated CRUD Operations

For tables created with `AddTable` (which includes standard columns: `id`, `public_id`, `created_at`, `updated_at`, `deleted_at`), PortSQL automatically generates CRUD operations.

=== Basic CRUD Generation

When you run `portsql compile`, CRUD is generated for eligible tables:

[source,bash]
----
$ portsql compile
Generating for dialects: [sqlite]
Found 3 registered queries
  Compiling: GetUserByEmail (one)
  Compiling: ListPosts (many)
  ...

Found 2 CRUD tables:
  users
  orders
Generated: queries/types.go
Generated: queries/sqlite/runner.go

Successfully compiled 3 queries for 1 dialect(s).
Generated CRUD for 2 tables.
----

=== Generated CRUD Methods

For each table, you get methods on the dialect-specific `QueryRunner`:

[source,go]
----
import (
    "myapp/queries"
    "myapp/queries/sqlite"
)

func main() {
    db, _ := sql.Open("sqlite", "app.db")
    runner := sqlite.NewQueryRunner(db)

    // GetUser - fetch by public_id
    user, _ := runner.GetUser(ctx, queries.GetUserParams{PublicID: "abc123"})

    // ListUsers - paginated list
    users, _ := runner.ListUsers(ctx, queries.ListUsersParams{Limit: 10, Offset: 0})

    // InsertUser - create new record (auto-generates public_id via nanoid)
    publicID, _ := runner.InsertUser(ctx, queries.InsertUserParams{
        Name:  "Alice",
        Email: "alice@example.com",
    })

    // UpdateUser - update existing record
    runner.UpdateUser(ctx, queries.UpdateUserParams{
        PublicID: "abc123",
        Name:     "Alice Updated",
    })

    // DeleteUser - soft delete (sets deleted_at)
    runner.DeleteUser(ctx, queries.DeleteUserParams{PublicID: "abc123"})

    // HardDeleteUser - permanent delete
    runner.HardDeleteUser(ctx, queries.HardDeleteUserParams{PublicID: "abc123"})
}
----

=== Scope Configuration

Scopes add tenant isolation or ownership filtering to CRUD operations. Configure in `portsql.ini`:

==== Global Scope

Set a default scope for all tables:

[source,ini]
----
[crud]
scope = org_id
----

This adds `org_id` to all CRUD operations:
- `GetUser` requires `org_id` parameter, adds `WHERE org_id = ?`
- `ListUsers` requires `org_id` parameter, filters by it
- `InsertUser` requires `org_id` parameter, includes it in INSERT
- `UpdateUser` requires `org_id` parameter, adds to WHERE clause

==== Per-Table Scope Override

Override the global scope for specific tables:

[source,ini]
----
[crud]
scope = org_id              # Default: all tables scoped by org_id

[crud.orders]
scope = user_id             # Orders scoped by user_id instead

[crud.audit_logs]
scope =                     # No scope (public table)
----

==== Scope Resolution Rules

1. If `[crud.tablename]` exists with `scope = X`, use `X` (even if empty)
2. Otherwise, use `[crud]` `scope` value (global default)
3. If no `[crud]` section exists, no scope is applied

==== Example: Multi-Tenant SaaS

[source,ini]
----
[crud]
scope = organization_id     # All tables scoped by organization

[crud.users]
scope =                     # Users table is global (admins can see all)

[crud.user_sessions]
scope = user_id             # Sessions scoped by user, not org
----

==== Generated SQL with Scope

With `scope = org_id`:

[source,sql]
----
-- GetUser
SELECT ... FROM users WHERE public_id = ? AND org_id = ? AND deleted_at IS NULL

-- ListUsers
SELECT ... FROM users WHERE org_id = ? AND deleted_at IS NULL ORDER BY created_at DESC LIMIT ? OFFSET ?

-- InsertUser
INSERT INTO users (public_id, org_id, name, email, created_at, updated_at) VALUES (?, ?, ?, ?, NOW(), NOW())

-- UpdateUser
UPDATE users SET name = ?, email = ?, updated_at = NOW() WHERE public_id = ? AND org_id = ? AND deleted_at IS NULL
----

Without scope:

[source,sql]
----
-- GetUser
SELECT ... FROM users WHERE public_id = ? AND deleted_at IS NULL

-- ListUsers
SELECT ... FROM users WHERE deleted_at IS NULL ORDER BY created_at DESC LIMIT ? OFFSET ?
----

== Configuration

PortSQL is configured via `portsql.ini` in your project root:

[source,ini]
----
[database]
url = sqlite:./app.db

# Optional: Generate for multiple dialects
# dialects = sqlite,postgres

[paths]
migrations = migrations
schematypes = schematypes
queries_in = querydef
queries_out = queries

[crud]
# Optional: Global scope for tenant isolation
# scope = org_id
----

=== Multi-Dialect Generation

By default, PortSQL generates code for the dialect inferred from your database URL. To generate for multiple databases (e.g., for testing or migration):

[source,ini]
----
[database]
url = sqlite:./app.db
dialects = sqlite,postgres
----

This generates:

[source]
----
queries/
├── types.go           # Shared types (used by all dialects)
├── sqlite/
│   └── runner.go      # SQLite runner
└── postgres/
    └── runner.go      # PostgreSQL runner
----

== CLI Commands

[source,bash]
----
# Create a new timestamped migration file
portsql migrate new create_users
# Creates: migrations/YYYYMMDDHHMMSS_create_users.go

# Run pending migrations and regenerate schematypes
portsql migrate up

# Drop all tables and re-run migrations (localhost only, for development)
portsql migrate reset

# Compile query definitions to SQL strings
portsql compile

# Show help
portsql help
----

== Project Structure

[source]
----
portsql/
├── src/
│   ├── ddl/              # Table/column definition builders
│   │   ├── types.go      # Column types, Table, Index definitions
│   │   ├── table_builder.go    # Fluent API for CREATE TABLE
│   │   └── alter_builder.go    # Fluent API for ALTER TABLE
│   │
│   ├── migrate/          # Migration planning and SQL generation
│   │   ├── plan.go       # MigrationPlan with AddTable, UpdateTable, etc.
│   │   ├── postgres_plan.go    # PostgreSQL CREATE/ALTER generators
│   │   ├── mysql_plan.go       # MySQL CREATE/ALTER generators
│   │   └── sqlite_plan.go      # SQLite CREATE/ALTER generators
│   │
│   ├── query/            # Query builder and AST
│   │   ├── builder.go    # SELECT query builder
│   │   ├── registry.go   # MustDefineOne/MustDefineMany/MustDefineExec registration
│   │   ├── columns.go    # Typed column definitions
│   │   ├── expr.go       # Expression types (conditions, operators)
│   │   ├── ast.go        # Query AST structure
│   │   └── compile/      # SQL compilers per database
│   │       ├── postgres.go
│   │       ├── mysql.go
│   │       └── sqlite.go
│   │
│   ├── codegen/          # Code generators
│   │   ├── schema_gen.go     # Phase 1: Schema → Table structs
│   │   ├── queries_gen.go    # Phase 2: Queries → Types + Runners
│   │   └── crud_gen.go       # CRUD query generation
│   │
│   └── cli/              # CLI commands
│       ├── compile.go    # portsql compile
│       ├── migrate_up.go # portsql migrate up
│       └── config.go     # Configuration loading
│
└── proptest/             # Property-based testing utilities
----

== Philosophy

=== SQL is the Interface

Your application's database queries are a critical interface. PortSQL believes you should:

1. **See the SQL** - No hidden queries. The generated SQL is readable and auditable.
2. **Control the SQL** - The query builder maps directly to SQL constructs.
3. **Trust the SQL** - Property tests verify queries work identically across databases.

=== Compile-Time Safety

Type errors should be caught at compile time, not runtime:

- Column references are typed (can't compare a string column with `>`)
- Table references prevent typos in table names
- Parameter types are explicit

=== No Runtime Magic

- No reflection for query building
- No string interpolation for SQL construction
- Generated code is straightforward and debuggable

== Portability Notes

PortSQL is designed for cross-database portability. This section documents important considerations when writing portable queries.

=== Identifier Restrictions

All table names, column names, and aliases must match the pattern `^[a-zA-Z_][a-zA-Z0-9_]*$`:

- **Must start with** a letter (a-z, A-Z) or underscore (_)
- **Can contain** letters, digits (0-9), and underscores
- **Cannot contain** hyphens, dots, spaces, or special characters

[source,go]
----
// Valid identifiers
users, user_id, _private, User123, created_at

// Invalid identifiers (will error during compilation)
user-name    // hyphen not allowed
user.name    // dot not allowed
123users     // cannot start with digit
----

**Why this restriction?** Different databases have different rules for identifiers. By enforcing a strict subset that works everywhere, PortSQL ensures your schema and queries are truly portable across PostgreSQL, MySQL, and SQLite.

=== Table Aliasing

When using JOINs with table aliases, use the `WithTable()` method on columns to reference aliased tables:

[source,go]
----
// Define your columns with aliases when needed in joins
aliasedUserId := schema.Users.Id().WithTable("u")
aliasedOrdersUserId := schema.Orders.UserId().WithTable("o")

// Use in a join query
query.From(schema.Users).As("u").
    Join(schema.Orders).As("o").On(aliasedUserId.Eq(aliasedOrdersUserId)).
    Select(aliasedUserId, aliasedOrdersUserId).
    Build()
----

The `WithTable()` method returns a copy of the column with the new table name, leaving the original unchanged.

=== JSON Aggregation Behavior

When using `SelectJSONAgg()` for nested data in LEFT JOINs:

- All dialects return `[]` (empty array) when there are no matched child rows
- PostgreSQL uses `FILTER (WHERE ... IS NOT NULL)` internally
- MySQL and SQLite use `CASE WHEN ... END` to produce the same result
- Null filtering happens during Go unmarshal, ensuring consistent behavior

[source,go]
----
// This query returns an empty array for authors with no books
query.From(schema.Authors).
    LeftJoin(schema.Books).On(schema.Authors.Id().Eq(schema.Books.AuthorId())).
    Select(schema.Authors.Id(), schema.Authors.Name()).
    SelectJSONAgg("books", schema.Books.Id(), schema.Books.Title()).
    GroupBy(schema.Authors.Id()).
    Build()
----

=== SQLite RETURNING Clause

SQLite's `RETURNING` clause requires SQLite version 3.35.0 (2021-03-12) or later. If you're using an older version, `RETURNING` queries will fail at runtime.

The generated CRUD `Insert()` methods use `RETURNING` when available. Check your SQLite version if you encounter issues.

=== Dialect-Specific Behaviors

**Boolean literals:**

- PostgreSQL: `TRUE` / `FALSE`
- MySQL: `1` / `0`
- SQLite: `1` / `0`

**NOW() function:**

- PostgreSQL: `NOW()`
- MySQL: `NOW()`
- SQLite: `datetime('now')`

**Case-insensitive search (ILIKE):**

- PostgreSQL: Native `ILIKE` support
- MySQL/SQLite: Translated to `LOWER(col) LIKE LOWER(pattern)`

**Parameter placeholders:**

- PostgreSQL: `$1`, `$2`, `$3`...
- MySQL/SQLite: `?`

== Development

[source,bash]
----
# Run tests
go test ./...

# Run integration tests (requires databases)
just start-dbs        # Start Postgres, MySQL, SQLite via Nix
go test ./... -tags=integration

# Run property tests for cross-database correctness
go test ./src/migrate/... -run Property
----

== License

MIT License - see LICENSE.adoc
