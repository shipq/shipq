= ShipQ DB CLI Design Specification

This document specifies the design of the ShipQ database command-line interface and runtime migration library.

== Overview

The CLI provides tooling for:

1. **Migration management** - Creating, running, and resetting database migrations
2. **Schema generation** - Generating type-safe Go structs from migration schemas
3. **Query compilation** - Compiling query ASTs into raw SQL strings

== Commands

[source]
----
shipq db migrate new <name>     # Create new timestamped migration file
shipq db migrate up             # Run pending migrations, generate schematypes
shipq db migrate reset          # Drop all, re-run all migrations (localhost only)
shipq db compile                # Compile query definitions to SQL strings
shipq db help                   # Show help information
shipq db version                # Show version information
----

== Project Structure

A typical project using ShipQ:

[source]
----
myapp/
├── shipq.ini                   # Optional configuration file
├── migrations/                 # User's migration files
│   ├── 20260111153000_create_users.go
│   ├── 20260111160000_create_posts.go
│   ├── schema.json             # Generated: accumulated schema state
│   └── runner.go               # Generated: embeds schema, provides Run()
├── schematypes/                # Generated by migrate up/reset
│   └── tables.go               # Table structs and typed column accessors
├── querydef/                   # User's query definitions
│   └── queries.go              # var Queries = []query.Query{...}
└── queries/                    # Generated by compile
    └── queries.go              # SQL strings, param structs, result structs
----

== Configuration

=== Config File: `shipq.ini`

Located in the project root. All paths are relative to the project root.

[source,ini]
----
[database]
url = postgres://localhost/myapp

[paths]
migrations = migrations
schematypes = schematypes
queries_in = querydef
queries_out = queries
----

=== Defaults

If `portsql.ini` does not exist, the CLI uses these defaults:

[cols="1,1"]
|===
| Setting | Default

| `database.url` | `$DATABASE_URL` environment variable
| `paths.migrations` | `migrations`
| `paths.schematypes` | `schematypes`
| `paths.queries_in` | `querydef`
| `paths.queries_out` | `queries`
|===

=== Database URL Format

The database URL determines the dialect and connection parameters:

[source]
----
postgres://user:pass@host:port/dbname?sslmode=disable
mysql://user:pass@host:port/dbname
sqlite:///path/to/database.db
----

The dialect (`postgres`, `mysql`, `sqlite`) is inferred from the URL scheme.

== Migration Files

=== File Naming

Migration files use timestamp-based naming:

[source]
----
YYYYMMDDHHMMSS_description.go
----

Example: `20260111153000_create_users.go`

=== File Structure

Each migration file contains a uniquely-named function matching the filename:

[source,go]
----
// 20260111153000_create_users.go
package migrations

import "github.com/shipq/shipq/db/portsql/migrate"
import "github.com/shipq/shipq/db/portsql/ddl"

func Migrate_20260111153000_create_users(plan *migrate.MigrationPlan) error {
    plan.AddEmptyTable("users", func(tb *ddl.TableBuilder) error {
        tb.Bigint("id").PrimaryKey()
        tb.String("name")
        tb.String("email").Unique()
        tb.Datetime("created_at").Indexed()
        return nil
    })
    return nil
}
----

=== Creating New Migrations

[source,bash]
----
$ portsql migrate new create_users
Created: migrations/20260111153000_create_users.go
----

Generated stub:

[source,go]
----
// 20260111153000_create_users.go
package migrations

import "github.com/shipq/shipq/db/portsql/migrate"

func Migrate_20260111153000_create_users(plan *migrate.MigrationPlan) error {
    // TODO: Define your migration
    return nil
}
----

== Command Details

=== `portsql migrate up`

Runs all pending migrations and generates the `schematypes` package.

**Process:**

1. Read configuration (config file or DATABASE_URL)
2. Parse database URL to determine dialect
3. Connect to database
4. Read migration tracking table (`_portsql_migrations`) to find applied migrations
5. Scan migrations directory for all migration files
6. For each unapplied migration (in timestamp order):
   a. Generate a temporary Go program that imports the migrations package
   b. Execute the migration function to build the MigrationPlan
   c. Generate and execute dialect-specific SQL
   d. Record migration in tracking table
7. Serialize accumulated schema to `schema.json`
8. Generate `migrations/runner.go` (embeds schema.json, provides `Run()` function)
9. Generate `schematypes/tables.go` from the schema

**Migration Tracking Table:**

[source,sql]
----
CREATE TABLE _portsql_migrations (
    version    VARCHAR(14) PRIMARY KEY,  -- Timestamp: "20260111153000"
    name       VARCHAR(255) NOT NULL,    -- Full filename without extension
    applied_at TIMESTAMP NOT NULL
);
----

=== `portsql migrate reset`

Drops all tables and re-runs all migrations from scratch.

**Safety Check:**

This command is **only allowed** when the database host is:

- `localhost`
- `127.0.0.1`
- SQLite (always considered safe - local file database)

If the host is anything else, the command fails with an error:

[source]
----
Error: migrate reset is not allowed on remote databases.
       Host "db.example.com" is not localhost.
       This safety check prevents accidental data loss in production.
----

**Process:**

1. Verify localhost safety check
2. Drop all tables (including `_portsql_migrations`)
3. Run `migrate up` from scratch

=== `portsql compile`

Compiles query definitions into SQL strings and Go structs.

**Process:**

1. Read configuration
2. Generate a temporary Go program that:
   a. Imports the `queries_in` package
   b. Accesses the `Queries` variable (explicitly registered queries)
   c. Serializes each query AST to stdout as JSON
3. Run the temporary program with `go run`
4. For each query AST:
   a. Generate dialect-specific SQL string
   b. Generate parameter struct (typed inputs)
   c. Generate result struct (typed outputs)
5. Write generated code to `queries_out/queries.go`

**Query Definition Format:**

Users define queries in the `queries_in` package using `query.DefineQuery()`:

[source,go]
----
// querydef/queries.go
package querydef

import (
    "myapp/schematypes"
    ql "github.com/shipq/shipq/db/portsql/query"
)

func init() {
    ql.DefineQuery("GetUserByEmail",
        ql.From(schematypes.Users).
            Select(
                schematypes.Users.Id(),
                schematypes.Users.Name(),
                schematypes.Users.Email(),
            ).
            Where(schematypes.Users.Email().Eq(ql.Param[string]("email"))).
            Build(),
    )

    ql.DefineQuery("ListRecentPosts",
        ql.From(schematypes.Posts).
            Select(
                schematypes.Posts.Id(),
                schematypes.Posts.Title(),
            ).
            OrderBy(schematypes.Posts.PublishedAt().Desc()).
            Limit(ql.Param[int64]("limit")).
            Build(),
    )
}
----

Each `DefineQuery` call registers the query in a global registry. The CLI retrieves all registered queries via `query.GetRegisteredQueries()`.

**Generated Output:**

[source,go]
----
// queries/queries.go
// Code generated by portsql. DO NOT EDIT.
package queries

// GetUserByEmailSQL contains the compiled SQL for GetUserByEmail.
// PostgreSQL: SELECT "users"."id", "users"."name", "users"."email"
//             FROM "users" WHERE "users"."email" = $1
const GetUserByEmailSQL = `SELECT "users"."id", "users"."name", "users"."email" FROM "users" WHERE "users"."email" = $1`

type GetUserByEmailParams struct {
    Email string
}

type GetUserByEmailResult struct {
    Id    int64
    Name  string
    Email string
}

// ListRecentPostsSQL contains the compiled SQL for ListRecentPosts.
const ListRecentPostsSQL = `SELECT "posts"."id", "posts"."title" FROM "posts" ORDER BY "posts"."published_at" DESC LIMIT $1`

type ListRecentPostsParams struct {
    Limit int64
}

type ListRecentPostsResult struct {
    Id    int64
    Title string
}
----

== Runtime Library

For applications that want to run migrations at startup (rather than via CLI), PortSQL generates a convenient runner.

=== Generated Runner

When `portsql migrate up` runs, it generates `migrations/runner.go` that embeds the schema and provides a simple `Run()` function:

[source,go]
----
// migrations/runner.go
// Code generated by portsql. DO NOT EDIT.
package migrations

import (
    "context"
    "database/sql"
    _ "embed"

    "github.com/shipq/shipq/db/portsql/migrate"
)

//go:embed schema.json
var schemaJSON []byte

// Plan returns the migration plan reconstructed from the embedded schema.
func Plan() (*migrate.MigrationPlan, error) {
    return migrate.PlanFromJSON(schemaJSON)
}

// Run executes all pending migrations. Safe to call on every app startup.
func Run(ctx context.Context, db *sql.DB) error {
    plan, err := Plan()
    if err != nil {
        return err
    }
    return migrate.Run(ctx, db, plan)
}
----

=== Usage

With the generated runner, migration at app startup is a one-liner:

[source,go]
----
import "myapp/migrations"

func main() {
    db, _ := sql.Open("postgres", os.Getenv("DATABASE_URL"))

    // Run migrations - idempotent, safe to call on every startup
    if err := migrations.Run(context.Background(), db); err != nil {
        log.Fatal(err)
    }

    // App continues...
}
----

=== Manual API

If you need more control, you can still build the plan manually:

[source,go]
----
import "github.com/shipq/shipq/db/portsql/migrate"

func main() {
    db, _ := sql.Open("postgres", os.Getenv("DATABASE_URL"))

    // Build the migration plan manually
    plan := migrate.NewPlan()
    migrations.Migrate_20260111153000_create_users(plan)
    migrations.Migrate_20260111160000_create_posts(plan)

    // Run migrations
    err := migrate.Run(ctx, db, plan)
    if err != nil {
        log.Fatal(err)
    }
}
----

=== Behavior

- **Idempotent**: Safe to call on every application startup
- **Tracking**: Uses `_portsql_migrations` table to track applied migrations
- **No transactions per migration**: DDL statements cannot be transactional in all databases
- **Dialect detection**: Inferred from the `*sql.DB` driver name

== CLI Implementation Details

=== Temporary Go Program Generation

Both `migrate up` and `compile` work by generating and running temporary Go programs. This approach:

- Avoids Go plugin complexity
- Works with standard `go run`
- Leverages Go's type system for validation

**Example: Migration Execution**

The CLI generates a program like:

[source,go]
----
// /tmp/portsql-migrate-xxxxx/main.go
package main

import (
    "encoding/json"
    "os"

    migrations "myapp/migrations"
    "github.com/shipq/shipq/db/portsql/migrate"
)

func main() {
    plan := migrate.NewPlan()

    // Call each migration function in order
    migrations.Migrate_20260111153000_create_users(plan)
    migrations.Migrate_20260111160000_create_posts(plan)

    // Output the plan as JSON
    json.NewEncoder(os.Stdout).Encode(plan)
}
----

The CLI runs this with `go run`, captures the JSON output, and uses it to:

1. Generate dialect-specific SQL
2. Execute against the database
3. Update the schema JSON file

=== Schema Serialization

The accumulated schema state is stored as JSON in `migrations/schema.json`:

[source,json]
----
{
  "tables": [
    {
      "name": "users",
      "columns": [
        {"name": "id", "type": "bigint", "primaryKey": true},
        {"name": "name", "type": "string"},
        {"name": "email", "type": "string", "unique": true},
        {"name": "created_at", "type": "datetime", "indexed": true}
      ]
    },
    {
      "name": "posts",
      "columns": [
        {"name": "id", "type": "bigint", "primaryKey": true},
        {"name": "title", "type": "string"},
        {"name": "body", "type": "text", "nullable": true}
      ]
    }
  ],
  "version": "20260111160000"
}
----

This file is used to:

1. Generate `schematypes` without re-running migrations
2. Reconstruct schema state for query compilation
3. Track the current schema version

== Error Handling

=== Migration Failures

If a migration fails:

1. The error is reported with the migration name and details
2. The `_portsql_migrations` table is NOT updated for that migration
3. Subsequent migrations are NOT attempted
4. The user must fix the issue and re-run `migrate up`

=== Compilation Failures

If query compilation fails:

1. Type errors are reported with the query name and location
2. No output is generated
3. Existing `queries/` package is NOT modified
