= Autoincrement Primary Keys
:toc:
:toclevels: 2

== Overview

PortSQL automatically generates auto-incrementing primary key semantics for eligible tables across PostgreSQL, MySQL, and SQLite. This document describes how autoincrement eligibility is determined and what SQL is generated for each dialect.

== Eligibility Rules

A table is eligible for autoincrement primary key behavior if:

1. The table has *exactly one* primary key column (`PrimaryKey=true`)
2. That primary key column is an integer type (`integer` or `bigint`)
3. The table is *not* marked as a junction table (`IsJunctionTable=false`)

Tables with composite primary keys (multiple `PrimaryKey=true` columns) are *not* eligible for autoincrement behavior.

=== Checking Eligibility in Code

[source,go]
----
import "github.com/shipq/shipq/db/portsql/migrate"

// Check if a table is eligible
if migrate.IsAutoincrementEligible(&table) {
    // Table will get autoincrement PK behavior
}

// Get details about the autoincrement PK
info, ok := migrate.GetAutoincrementPK(&table)
if ok {
    fmt.Printf("PK column: %s, type: %s\n", info.ColumnName, info.ColumnType)
}
----

== Generated SQL by Dialect

=== PostgreSQL

For eligible tables, PostgreSQL uses SQL-standard identity columns:

[source,sql]
----
CREATE TABLE "users" (
    "id" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "name" VARCHAR(255) NOT NULL
)
----

* Uses `GENERATED BY DEFAULT AS IDENTITY` which allows explicit ID inserts while providing auto-generation
* Works with both `INTEGER` and `BIGINT` types
* `PRIMARY KEY` is kept explicit

=== MySQL

For eligible tables, MySQL uses `AUTO_INCREMENT`:

[source,sql]
----
CREATE TABLE `users` (
    `id` BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    `name` VARCHAR(255) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
----

* Uses `AUTO_INCREMENT` on the column definition
* `NOT NULL` is explicit before `AUTO_INCREMENT`
* Works with both `INT` and `BIGINT` types

=== SQLite

For eligible tables, SQLite uses `INTEGER PRIMARY KEY` which is an alias for the `rowid`:

[source,sql]
----
CREATE TABLE "users" (
    "id" INTEGER PRIMARY KEY,
    "name" TEXT NOT NULL
)
----

* Uses exactly `INTEGER PRIMARY KEY` (not `BIGINT`) for rowid alias behavior
* The `AUTOINCREMENT` keyword is *not* used by default (see notes below)
* Provides autoincrement semantics through rowid aliasing

== Important Notes

=== SQLite AUTOINCREMENT Keyword

PortSQL does *not* emit the `AUTOINCREMENT` keyword for SQLite by default. The difference:

* `INTEGER PRIMARY KEY` (what we use): Row IDs may be reused if rows are deleted
* `INTEGER PRIMARY KEY AUTOINCREMENT`: Row IDs are never reused (monotonically increasing)

Most applications don't need the "never reuse" guarantee, and `INTEGER PRIMARY KEY` is more efficient.

=== DEFAULT Values on Autoincrement PKs

If a `DEFAULT` value is specified on an autoincrement-eligible primary key column, it is *ignored* in the generated SQL. The autoincrement mechanism is the source of truth for ID generation.

[source,go]
----
// This default will be ignored in generated SQL:
tb.Bigint("id").PrimaryKey().Default(1)
----

=== Explicit ID Inserts

All three dialects support inserting explicit ID values:

* PostgreSQL: `GENERATED BY DEFAULT` allows explicit values
* MySQL: Explicit values are allowed by default
* SQLite: `INTEGER PRIMARY KEY` allows explicit values

=== Composite Primary Keys

Tables with composite primary keys do *not* receive autoincrement behavior:

[source,go]
----
// This table will NOT have autoincrement semantics
tb.Bigint("user_id").PrimaryKey()
tb.Bigint("role_id").PrimaryKey()
----

=== Non-Integer Primary Keys

Tables with non-integer primary keys (e.g., `string`) do *not* receive autoincrement behavior:

[source,go]
----
// This table will NOT have autoincrement semantics
tb.String("key").PrimaryKey()
----

== CRUD Code Generation

The CRUD code generator is aware of autoincrement PKs:

1. **INSERT statements** omit the PK column from the column list
2. **PostgreSQL/SQLite** use `RETURNING "id"` to retrieve the generated ID
3. **MySQL** uses `LastInsertId()` on the result to retrieve the generated ID

Example generated INSERT for PostgreSQL:
[source,sql]
----
INSERT INTO "users" ("public_id", "name", "created_at", "updated_at")
VALUES ($1, $2, NOW(), NOW())
RETURNING "id", "public_id"
----

== Testing Autoincrement Behavior

=== Unit Tests

Unit tests verify that SQL generation is correct:

* `TestPostgres_CreateTable_AutoincrementPK_Bigint`
* `TestMySQL_CreateTable_AutoincrementPK_Integer`
* `TestSQLite_CreateTable_AutoincrementPK_Bigint`

=== Property Tests

Property tests verify invariants across random table configurations:

* `TestProperty_CompositePK_NoAutoincrement` - Composite PKs never get autoincrement
* `TestProperty_NonIntegerPK_NoAutoincrement` - Non-integer PKs never get autoincrement
* `TestProperty_SingleIntegerPK_HasAutoincrement` - Single integer PKs always get autoincrement
* `TestProperty_AutoincrementPK_NoDefaultInSQL` - DEFAULT values are never emitted for autoincrement PKs

=== Integration Tests

Cross-database integration tests verify actual insert behavior:

* `TestProperty_CrossDB_Autoincrement_InsertReturnsGeneratedID` - Inserts without ID return unique, monotonic IDs
* `TestProperty_CrossDB_Autoincrement_ExplicitIDAllowed` - Explicit ID inserts work

Run integration tests with:
[source,bash]
----
go test -tags=integration ./db/portsql/migrate/...
----

== Opt-Out (Future)

Currently there is no way to opt out of autoincrement behavior for eligible tables. If you need a non-autoincrement integer PK, consider:

1. Using a string PK instead
2. Using a composite PK
3. Marking the table as a junction table

Future versions may add an explicit opt-out mechanism.
