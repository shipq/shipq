package codegen

import (
	"bytes"
	"fmt"
	"go/format"
	"sort"
	"strings"

	"github.com/shipq/shipq/db/portsql/ddl"
	"github.com/shipq/shipq/db/portsql/migrate"
)

// RelationType represents the type of relationship between tables.
type RelationType string

const (
	RelationHasMany    RelationType = "has_many"
	RelationBelongsTo  RelationType = "belongs_to"
	RelationManyToMany RelationType = "many_to_many"
)

// Relation represents a relationship between two tables.
type Relation struct {
	Type           RelationType
	FromTable      string
	ToTable        string
	FKColumn       string // The foreign key column name
	JunctionTable  string // Only for ManyToMany
	JunctionFKFrom string // Only for ManyToMany: FK column pointing to FromTable
	JunctionFKTo   string // Only for ManyToMany: FK column pointing to ToTable
}

// ScanRelations scans the schema for all table relationships.
// It identifies HasMany, BelongsTo, and ManyToMany relations based on
// the References field in column definitions.
func ScanRelations(plan *migrate.MigrationPlan) []Relation {
	var relations []Relation

	for _, table := range plan.Schema.Tables {
		if table.IsJunctionTable {
			// Handle ManyToMany - generates relations in both directions
			relations = append(relations, scanManyToMany(table)...)
		} else {
			// Handle HasMany/BelongsTo
			relations = append(relations, scanDirectRelations(table)...)
		}
	}

	return relations
}

// scanDirectRelations scans a non-junction table for References columns
// and generates HasMany (on the referenced table) and BelongsTo (on this table) relations.
func scanDirectRelations(table ddl.Table) []Relation {
	var relations []Relation

	for _, col := range table.Columns {
		if col.References != "" {
			// This table belongs to the referenced table
			relations = append(relations, Relation{
				Type:      RelationBelongsTo,
				FromTable: table.Name,
				ToTable:   col.References,
				FKColumn:  col.Name,
			})

			// The referenced table has many of this table
			relations = append(relations, Relation{
				Type:      RelationHasMany,
				FromTable: col.References,
				ToTable:   table.Name,
				FKColumn:  col.Name,
			})
		}
	}

	return relations
}

// scanManyToMany scans a junction table and generates ManyToMany relations
// in both directions between the two tables it connects.
func scanManyToMany(table ddl.Table) []Relation {
	// Find the two Reference columns
	var refs []struct {
		colName   string
		tableName string
	}

	for _, col := range table.Columns {
		if col.References != "" {
			refs = append(refs, struct {
				colName   string
				tableName string
			}{col.Name, col.References})
		}
	}

	// Should have exactly 2 references (validated at table creation)
	if len(refs) != 2 {
		return nil
	}

	// Create ManyToMany relation in both directions
	return []Relation{
		{
			Type:           RelationManyToMany,
			FromTable:      refs[0].tableName,
			ToTable:        refs[1].tableName,
			JunctionTable:  table.Name,
			JunctionFKFrom: refs[0].colName,
			JunctionFKTo:   refs[1].colName,
		},
		{
			Type:           RelationManyToMany,
			FromTable:      refs[1].tableName,
			ToTable:        refs[0].tableName,
			JunctionTable:  table.Name,
			JunctionFKFrom: refs[1].colName,
			JunctionFKTo:   refs[0].colName,
		},
	}
}

// GenerateRelationTypes generates Go structs for all relation types.
// These structs represent the result types for relation queries.
func GenerateRelationTypes(plan *migrate.MigrationPlan, relations []Relation) ([]byte, error) {
	var buf bytes.Buffer

	// Write package header
	buf.WriteString("// Code generated by shipq. DO NOT EDIT.\n\n")
	buf.WriteString("package queries\n\n")

	if len(relations) == 0 {
		return format.Source(buf.Bytes())
	}

	// Collect imports
	imports := make(map[string]bool)
	imports["time"] = true // Almost always needed for created_at, updated_at

	// Check for json.RawMessage usage
	for _, rel := range relations {
		toTable := plan.Schema.Tables[rel.ToTable]
		for _, col := range toTable.Columns {
			if col.Type == ddl.JSONType {
				imports["encoding/json"] = true
				break
			}
		}
		// Also check from table for BelongsTo
		if rel.Type == RelationBelongsTo {
			fromTable := plan.Schema.Tables[rel.FromTable]
			for _, col := range fromTable.Columns {
				if col.Type == ddl.JSONType {
					imports["encoding/json"] = true
					break
				}
			}
		}
	}

	// Write imports
	if len(imports) > 0 {
		buf.WriteString("import (\n")
		sortedImports := make([]string, 0, len(imports))
		for imp := range imports {
			sortedImports = append(sortedImports, imp)
		}
		sort.Strings(sortedImports)
		for _, imp := range sortedImports {
			fmt.Fprintf(&buf, "\t%q\n", imp)
		}
		buf.WriteString(")\n\n")
	}

	// Group relations by FromTable to generate types
	// Deduplicate - we only want one type per (FromTable, RelationType, ToTable) combination
	seenTypes := make(map[string]bool)

	for _, rel := range relations {
		typeName := generateRelationTypeName(rel)
		if seenTypes[typeName] {
			continue
		}
		seenTypes[typeName] = true

		// Generate the type
		if err := generateRelationType(&buf, plan, rel); err != nil {
			return nil, err
		}
	}

	return format.Source(buf.Bytes())
}

// generateRelationTypeName creates a type name like "CategoryWithPets" or "PetWithCategory"
func generateRelationTypeName(rel Relation) string {
	fromName := toPascalCase(toSingular(rel.FromTable))
	toName := toPascalCase(rel.ToTable)

	switch rel.Type {
	case RelationHasMany, RelationManyToMany:
		return fmt.Sprintf("%sWith%s", fromName, toName)
	case RelationBelongsTo:
		return fmt.Sprintf("%sWith%s", fromName, toPascalCase(toSingular(rel.ToTable)))
	default:
		return fmt.Sprintf("%sWith%s", fromName, toName)
	}
}

// generateRelationType writes the Go struct definition for a relation type.
func generateRelationType(buf *bytes.Buffer, plan *migrate.MigrationPlan, rel Relation) error {
	fromTable := plan.Schema.Tables[rel.FromTable]
	toTable := plan.Schema.Tables[rel.ToTable]

	typeName := generateRelationTypeName(rel)
	analysis := AnalyzeTable(fromTable)

	// Write the struct comment
	fmt.Fprintf(buf, "// %s represents a %s with related %s.\n", typeName, toSingular(rel.FromTable), rel.ToTable)
	fmt.Fprintf(buf, "type %s struct {\n", typeName)

	// Write the base fields from the FromTable (ResultColumns)
	for _, col := range analysis.ResultColumns {
		fieldName := toPascalCase(col.Name)
		typeMapping := MapColumnType(col)
		fmt.Fprintf(buf, "\t%s %s `json:\"%s\"`\n", fieldName, typeMapping.GoType, col.Name)
	}

	// Write the relation field
	switch rel.Type {
	case RelationHasMany:
		// HasMany: plural field with slice of nested type
		fieldName := toPascalCase(rel.ToTable)
		nestedTypeName := generateNestedTypeName(rel)
		fmt.Fprintf(buf, "\t%s []%s `json:\"%s\"`\n", fieldName, nestedTypeName, rel.ToTable)
	case RelationBelongsTo:
		// BelongsTo: singular field with nested type
		fieldName := toPascalCase(toSingular(rel.ToTable))
		nestedTypeName := generateNestedTypeName(rel)
		fmt.Fprintf(buf, "\t%s %s `json:\"%s\"`\n", fieldName, nestedTypeName, toSingular(rel.ToTable))
	case RelationManyToMany:
		// ManyToMany: plural field with slice of nested type
		fieldName := toPascalCase(rel.ToTable)
		nestedTypeName := generateNestedTypeName(rel)
		fmt.Fprintf(buf, "\t%s []%s `json:\"%s\"`\n", fieldName, nestedTypeName, rel.ToTable)
	}

	buf.WriteString("}\n\n")

	// Generate the nested type
	if err := generateNestedType(buf, plan, rel, toTable); err != nil {
		return err
	}

	return nil
}

// generateNestedTypeName creates the name for the nested type
func generateNestedTypeName(rel Relation) string {
	parentTypeName := generateRelationTypeName(rel)
	toName := toPascalCase(toSingular(rel.ToTable))
	return fmt.Sprintf("%s%s", parentTypeName, toName)
}

// generateNestedType writes the nested struct for related data.
func generateNestedType(buf *bytes.Buffer, plan *migrate.MigrationPlan, rel Relation, toTable ddl.Table) error {
	nestedTypeName := generateNestedTypeName(rel)
	analysis := AnalyzeTable(toTable)

	fmt.Fprintf(buf, "// %s represents the nested %s data in a relation query.\n", nestedTypeName, toSingular(rel.ToTable))
	fmt.Fprintf(buf, "type %s struct {\n", nestedTypeName)

	// Write fields from the nested table (ResultColumns)
	for _, col := range analysis.ResultColumns {
		fieldName := toPascalCase(col.Name)
		typeMapping := MapColumnType(col)
		fmt.Fprintf(buf, "\t%s %s `json:\"%s\"`\n", fieldName, typeMapping.GoType, col.Name)
	}

	buf.WriteString("}\n\n")
	return nil
}

// Helper: toPlural converts singular to plural (simple implementation)
func toPlural(s string) string {
	if strings.HasSuffix(s, "y") && len(s) > 1 {
		return s[:len(s)-1] + "ies"
	}
	if strings.HasSuffix(s, "s") || strings.HasSuffix(s, "x") || strings.HasSuffix(s, "ch") || strings.HasSuffix(s, "sh") {
		return s + "es"
	}
	return s + "s"
}

// GenerateRelationSQL generates a SQL query for a specific relation.
func GenerateRelationSQL(plan *migrate.MigrationPlan, rel Relation, dialect SQLDialect) string {
	switch rel.Type {
	case RelationHasMany:
		return generateHasManySQL(plan, rel, dialect)
	case RelationBelongsTo:
		return generateBelongsToSQL(plan, rel, dialect)
	case RelationManyToMany:
		return generateManyToManySQL(plan, rel, dialect)
	default:
		return ""
	}
}

// generateHasManySQL generates SQL for a HasMany relation.
// Example: Get category with all its pets.
func generateHasManySQL(plan *migrate.MigrationPlan, rel Relation, dialect SQLDialect) string {
	fromTable := plan.Schema.Tables[rel.FromTable]
	toTable := plan.Schema.Tables[rel.ToTable]
	fromAnalysis := AnalyzeTable(fromTable)
	toAnalysis := AnalyzeTable(toTable)

	var b strings.Builder

	// SELECT base columns from FromTable
	b.WriteString("SELECT ")
	for i, col := range fromAnalysis.ResultColumns {
		if i > 0 {
			b.WriteString(", ")
		}
		b.WriteString(quoteIdentifier(rel.FromTable, dialect))
		b.WriteString(".")
		b.WriteString(quoteIdentifier(col.Name, dialect))
	}

	// Add JSON aggregate for related items
	b.WriteString(", ")
	writeJSONAgg(&b, toTable.Name, toAnalysis.ResultColumns, dialect)
	b.WriteString(" AS ")
	b.WriteString(quoteIdentifier(rel.ToTable, dialect))

	// FROM
	b.WriteString(" FROM ")
	b.WriteString(quoteIdentifier(rel.FromTable, dialect))

	// LEFT JOIN related table
	b.WriteString(" LEFT JOIN ")
	b.WriteString(quoteIdentifier(rel.ToTable, dialect))
	b.WriteString(" ON ")
	b.WriteString(quoteIdentifier(rel.ToTable, dialect))
	b.WriteString(".")
	b.WriteString(quoteIdentifier(rel.FKColumn, dialect))
	b.WriteString(" = ")
	b.WriteString(quoteIdentifier(rel.FromTable, dialect))
	b.WriteString(".")
	b.WriteString(quoteIdentifier("id", dialect))

	// WHERE clause for getting specific row
	b.WriteString(" WHERE ")
	if fromAnalysis.HasPublicID {
		b.WriteString(quoteIdentifier(rel.FromTable, dialect))
		b.WriteString(".")
		b.WriteString(quoteIdentifier("public_id", dialect))
	} else {
		b.WriteString(quoteIdentifier(rel.FromTable, dialect))
		b.WriteString(".")
		b.WriteString(quoteIdentifier("id", dialect))
	}
	b.WriteString(" = ")
	b.WriteString(placeholder(1, dialect))

	// GROUP BY to aggregate related items
	b.WriteString(" GROUP BY ")
	b.WriteString(quoteIdentifier(rel.FromTable, dialect))
	b.WriteString(".")
	b.WriteString(quoteIdentifier("id", dialect))

	return b.String()
}

// generateBelongsToSQL generates SQL for a BelongsTo relation.
// Example: Get pet with its category.
func generateBelongsToSQL(plan *migrate.MigrationPlan, rel Relation, dialect SQLDialect) string {
	fromTable := plan.Schema.Tables[rel.FromTable]
	toTable := plan.Schema.Tables[rel.ToTable]
	fromAnalysis := AnalyzeTable(fromTable)
	toAnalysis := AnalyzeTable(toTable)

	var b strings.Builder

	// SELECT base columns from FromTable
	b.WriteString("SELECT ")
	for i, col := range fromAnalysis.ResultColumns {
		if i > 0 {
			b.WriteString(", ")
		}
		b.WriteString(quoteIdentifier(rel.FromTable, dialect))
		b.WriteString(".")
		b.WriteString(quoteIdentifier(col.Name, dialect))
	}

	// Add JSON object for the related item (singular, not aggregate)
	b.WriteString(", ")
	writeJSONObject(&b, toTable.Name, toAnalysis.ResultColumns, dialect)
	b.WriteString(" AS ")
	b.WriteString(quoteIdentifier(toSingular(rel.ToTable), dialect))

	// FROM
	b.WriteString(" FROM ")
	b.WriteString(quoteIdentifier(rel.FromTable, dialect))

	// LEFT JOIN related table
	b.WriteString(" LEFT JOIN ")
	b.WriteString(quoteIdentifier(rel.ToTable, dialect))
	b.WriteString(" ON ")
	b.WriteString(quoteIdentifier(rel.FromTable, dialect))
	b.WriteString(".")
	b.WriteString(quoteIdentifier(rel.FKColumn, dialect))
	b.WriteString(" = ")
	b.WriteString(quoteIdentifier(rel.ToTable, dialect))
	b.WriteString(".")
	b.WriteString(quoteIdentifier("id", dialect))

	// WHERE clause for getting specific row
	b.WriteString(" WHERE ")
	if fromAnalysis.HasPublicID {
		b.WriteString(quoteIdentifier(rel.FromTable, dialect))
		b.WriteString(".")
		b.WriteString(quoteIdentifier("public_id", dialect))
	} else {
		b.WriteString(quoteIdentifier(rel.FromTable, dialect))
		b.WriteString(".")
		b.WriteString(quoteIdentifier("id", dialect))
	}
	b.WriteString(" = ")
	b.WriteString(placeholder(1, dialect))

	return b.String()
}

// generateManyToManySQL generates SQL for a ManyToMany relation.
// Example: Get pet with all its tags via the pet_tags junction table.
func generateManyToManySQL(plan *migrate.MigrationPlan, rel Relation, dialect SQLDialect) string {
	fromTable := plan.Schema.Tables[rel.FromTable]
	toTable := plan.Schema.Tables[rel.ToTable]
	fromAnalysis := AnalyzeTable(fromTable)
	toAnalysis := AnalyzeTable(toTable)

	var b strings.Builder

	// SELECT base columns from FromTable
	b.WriteString("SELECT ")
	for i, col := range fromAnalysis.ResultColumns {
		if i > 0 {
			b.WriteString(", ")
		}
		b.WriteString(quoteIdentifier(rel.FromTable, dialect))
		b.WriteString(".")
		b.WriteString(quoteIdentifier(col.Name, dialect))
	}

	// Add JSON aggregate for related items
	b.WriteString(", ")
	writeJSONAgg(&b, toTable.Name, toAnalysis.ResultColumns, dialect)
	b.WriteString(" AS ")
	b.WriteString(quoteIdentifier(rel.ToTable, dialect))

	// FROM
	b.WriteString(" FROM ")
	b.WriteString(quoteIdentifier(rel.FromTable, dialect))

	// LEFT JOIN junction table
	b.WriteString(" LEFT JOIN ")
	b.WriteString(quoteIdentifier(rel.JunctionTable, dialect))
	b.WriteString(" ON ")
	b.WriteString(quoteIdentifier(rel.JunctionTable, dialect))
	b.WriteString(".")
	b.WriteString(quoteIdentifier(rel.JunctionFKFrom, dialect))
	b.WriteString(" = ")
	b.WriteString(quoteIdentifier(rel.FromTable, dialect))
	b.WriteString(".")
	b.WriteString(quoteIdentifier("id", dialect))

	// LEFT JOIN target table
	b.WriteString(" LEFT JOIN ")
	b.WriteString(quoteIdentifier(rel.ToTable, dialect))
	b.WriteString(" ON ")
	b.WriteString(quoteIdentifier(rel.ToTable, dialect))
	b.WriteString(".")
	b.WriteString(quoteIdentifier("id", dialect))
	b.WriteString(" = ")
	b.WriteString(quoteIdentifier(rel.JunctionTable, dialect))
	b.WriteString(".")
	b.WriteString(quoteIdentifier(rel.JunctionFKTo, dialect))

	// WHERE clause for getting specific row
	b.WriteString(" WHERE ")
	if fromAnalysis.HasPublicID {
		b.WriteString(quoteIdentifier(rel.FromTable, dialect))
		b.WriteString(".")
		b.WriteString(quoteIdentifier("public_id", dialect))
	} else {
		b.WriteString(quoteIdentifier(rel.FromTable, dialect))
		b.WriteString(".")
		b.WriteString(quoteIdentifier("id", dialect))
	}
	b.WriteString(" = ")
	b.WriteString(placeholder(1, dialect))

	// GROUP BY to aggregate related items
	b.WriteString(" GROUP BY ")
	b.WriteString(quoteIdentifier(rel.FromTable, dialect))
	b.WriteString(".")
	b.WriteString(quoteIdentifier("id", dialect))

	return b.String()
}

// writeJSONAgg writes the JSON aggregation expression for a list of columns.
func writeJSONAgg(b *strings.Builder, tableName string, cols []ddl.ColumnDefinition, dialect SQLDialect) {
	switch dialect {
	case SQLDialectPostgres:
		writeJSONAggPostgres(b, tableName, cols)
	case SQLDialectMySQL:
		writeJSONAggMySQL(b, tableName, cols)
	case SQLDialectSQLite:
		writeJSONAggSQLite(b, tableName, cols)
	}
}

// writeJSONAggPostgres writes Postgres JSON aggregation.
// COALESCE(JSON_AGG(JSON_BUILD_OBJECT(...)) FILTER (WHERE ... IS NOT NULL), '[]')
func writeJSONAggPostgres(b *strings.Builder, tableName string, cols []ddl.ColumnDefinition) {
	b.WriteString("COALESCE(JSON_AGG(JSON_BUILD_OBJECT(")
	for i, col := range cols {
		if i > 0 {
			b.WriteString(", ")
		}
		fmt.Fprintf(b, "'%s', ", col.Name)
		b.WriteString(`"`)
		b.WriteString(tableName)
		b.WriteString(`"."`)
		b.WriteString(col.Name)
		b.WriteString(`"`)
	}
	b.WriteString(")) FILTER (WHERE ")
	b.WriteString(`"`)
	b.WriteString(tableName)
	b.WriteString(`"."`)
	b.WriteString(cols[0].Name)
	b.WriteString(`"`)
	b.WriteString(" IS NOT NULL), '[]')")
}

// writeJSONAggMySQL writes MySQL JSON aggregation.
// COALESCE(JSON_ARRAYAGG(CASE WHEN col IS NOT NULL THEN JSON_OBJECT(...) END), JSON_ARRAY())
func writeJSONAggMySQL(b *strings.Builder, tableName string, cols []ddl.ColumnDefinition) {
	b.WriteString("COALESCE(JSON_ARRAYAGG(CASE WHEN ")
	b.WriteString("`")
	b.WriteString(tableName)
	b.WriteString("`.`")
	b.WriteString(cols[0].Name)
	b.WriteString("`")
	b.WriteString(" IS NOT NULL THEN JSON_OBJECT(")
	for i, col := range cols {
		if i > 0 {
			b.WriteString(", ")
		}
		fmt.Fprintf(b, "'%s', ", col.Name)
		b.WriteString("`")
		b.WriteString(tableName)
		b.WriteString("`.`")
		b.WriteString(col.Name)
		b.WriteString("`")
	}
	b.WriteString(") END), JSON_ARRAY())")
}

// writeJSONAggSQLite writes SQLite JSON aggregation.
// Uses FILTER (WHERE ... IS NOT NULL) to exclude NULL rows from LEFT JOINs (SQLite 3.30+).
// COALESCE(JSON_GROUP_ARRAY(JSON_OBJECT(...)) FILTER (WHERE col IS NOT NULL), '[]')
func writeJSONAggSQLite(b *strings.Builder, tableName string, cols []ddl.ColumnDefinition) {
	b.WriteString("COALESCE(JSON_GROUP_ARRAY(JSON_OBJECT(")
	for i, col := range cols {
		if i > 0 {
			b.WriteString(", ")
		}
		fmt.Fprintf(b, "'%s', ", col.Name)
		b.WriteString(`"`)
		b.WriteString(tableName)
		b.WriteString(`"."`)
		b.WriteString(col.Name)
		b.WriteString(`"`)
	}
	b.WriteString(")) FILTER (WHERE ")
	b.WriteString(`"`)
	b.WriteString(tableName)
	b.WriteString(`"."`)
	b.WriteString(cols[0].Name)
	b.WriteString(`"`)
	b.WriteString(" IS NOT NULL), '[]')")
}

// writeJSONObject writes a JSON object expression for a single related item.
func writeJSONObject(b *strings.Builder, tableName string, cols []ddl.ColumnDefinition, dialect SQLDialect) {
	switch dialect {
	case SQLDialectPostgres:
		b.WriteString("JSON_BUILD_OBJECT(")
		for i, col := range cols {
			if i > 0 {
				b.WriteString(", ")
			}
			fmt.Fprintf(b, "'%s', ", col.Name)
			b.WriteString(`"`)
			b.WriteString(tableName)
			b.WriteString(`"."`)
			b.WriteString(col.Name)
			b.WriteString(`"`)
		}
		b.WriteString(")")
	case SQLDialectMySQL:
		b.WriteString("JSON_OBJECT(")
		for i, col := range cols {
			if i > 0 {
				b.WriteString(", ")
			}
			fmt.Fprintf(b, "'%s', ", col.Name)
			b.WriteString("`")
			b.WriteString(tableName)
			b.WriteString("`.`")
			b.WriteString(col.Name)
			b.WriteString("`")
		}
		b.WriteString(")")
	case SQLDialectSQLite:
		b.WriteString("JSON_OBJECT(")
		for i, col := range cols {
			if i > 0 {
				b.WriteString(", ")
			}
			fmt.Fprintf(b, "'%s', ", col.Name)
			b.WriteString(`"`)
			b.WriteString(tableName)
			b.WriteString(`"."`)
			b.WriteString(col.Name)
			b.WriteString(`"`)
		}
		b.WriteString(")")
	}
}
