package codegen

import (
	"strings"
	"testing"

	"github.com/shipq/shipq/db/portsql/query"
)

func TestGenerateSharedTypes_Queries(t *testing.T) {
	queries := []CompiledQuery{
		{
			Name: "GetUserByEmail",
			SQL:  `SELECT "users"."id", "users"."name", "users"."email" FROM "users" WHERE ("users"."email" = $1)`,
			Params: []ParamInfo{
				{Name: "email", GoType: "string"},
			},
			Results: []ResultInfo{
				{Name: "id", GoType: "int64"},
				{Name: "name", GoType: "string"},
				{Name: "email", GoType: "string"},
			},
		},
		{
			Name: "ListRecentPosts",
			SQL:  `SELECT "posts"."id", "posts"."title" FROM "posts" ORDER BY "posts"."created_at" DESC LIMIT $1`,
			Params: []ParamInfo{
				{Name: "limit", GoType: "int64"},
			},
			Results: []ResultInfo{
				{Name: "id", GoType: "int64"},
				{Name: "title", GoType: "string"},
			},
		},
	}

	code, err := GenerateSharedTypes(queries, nil, "queries", nil)
	if err != nil {
		t.Fatalf("GenerateSharedTypes failed: %v", err)
	}

	codeStr := string(code)

	// Check header
	if !strings.Contains(codeStr, "// Code generated by portsql. DO NOT EDIT.") {
		t.Error("missing generated header")
	}
	if !strings.Contains(codeStr, "package queries") {
		t.Error("missing package declaration")
	}

	// Check GetUserByEmail (no SQL constants - those are in dialect runners)
	if !strings.Contains(codeStr, "GetUserByEmailParams") {
		t.Error("missing GetUserByEmailParams struct")
	}
	if !strings.Contains(codeStr, "GetUserByEmailResult") {
		t.Error("missing GetUserByEmailResult struct")
	}
	if !strings.Contains(codeStr, "Email string") {
		t.Error("missing Email field in params")
	}

	// Check ListRecentPosts
	if !strings.Contains(codeStr, "ListRecentPostsParams") {
		t.Error("missing ListRecentPostsParams struct")
	}
	if !strings.Contains(codeStr, "Limit int64") {
		t.Error("missing Limit field in params")
	}
}

func TestGenerateQueriesWithTimeType(t *testing.T) {
	queries := []CompiledQuery{
		{
			Name: "GetUserWithTimestamp",
			SQL:  `SELECT "users"."id", "users"."created_at" FROM "users"`,
			Results: []ResultInfo{
				{Name: "id", GoType: "int64"},
				{Name: "created_at", GoType: "time.Time"},
			},
		},
	}

	code, err := GenerateSharedTypes(queries, nil, "queries", nil)
	if err != nil {
		t.Fatalf("GenerateSharedTypes failed: %v", err)
	}

	codeStr := string(code)

	// Should import time
	if !strings.Contains(codeStr, `"time"`) {
		t.Error("missing time import")
	}
	if !strings.Contains(codeStr, "CreatedAt time.Time") {
		t.Error("missing CreatedAt field with time.Time type")
	}
}

func TestGenerateQueriesUpdateNoResult(t *testing.T) {
	queries := []CompiledQuery{
		{
			Name: "UpdateUserName",
			SQL:  `UPDATE "users" SET "name" = $1 WHERE ("users"."id" = $2)`,
			Params: []ParamInfo{
				{Name: "name", GoType: "string"},
				{Name: "id", GoType: "int64"},
			},
			// No Results for UPDATE
		},
	}

	code, err := GenerateSharedTypes(queries, nil, "queries", nil)
	if err != nil {
		t.Fatalf("GenerateSharedTypes failed: %v", err)
	}

	codeStr := string(code)

	// Should have Params but no Result (no SQL constants - those are in dialect runners)
	if !strings.Contains(codeStr, "UpdateUserNameParams") {
		t.Error("missing UpdateUserNameParams struct")
	}
	if strings.Contains(codeStr, "UpdateUserNameResult") {
		t.Error("should not have UpdateUserNameResult struct for UPDATE query")
	}
}

func TestExtractResultInfo(t *testing.T) {
	ast := &query.AST{
		Kind: query.SelectQuery,
		FromTable: query.TableRef{
			Name: "users",
		},
		SelectCols: []query.SelectExpr{
			{Expr: query.ColumnExpr{Column: query.Int64Column{Table: "users", Name: "id"}}},
			{Expr: query.ColumnExpr{Column: query.StringColumn{Table: "users", Name: "name"}}},
			{Expr: query.ColumnExpr{Column: query.StringColumn{Table: "users", Name: "email"}}, Alias: "user_email"},
		},
	}

	results := ExtractResultInfo(ast)

	if len(results) != 3 {
		t.Fatalf("expected 3 results, got %d", len(results))
	}

	// Check first column
	if results[0].Name != "id" {
		t.Errorf("expected name 'id', got %q", results[0].Name)
	}
	if results[0].GoType != "int64" {
		t.Errorf("expected type 'int64', got %q", results[0].GoType)
	}

	// Check aliased column
	if results[2].Name != "user_email" {
		t.Errorf("expected name 'user_email', got %q", results[2].Name)
	}
}

func TestExtractParamInfo(t *testing.T) {
	// Create an AST with ParamExprs in the expressions
	ast := &query.AST{
		Kind: query.SelectQuery,
		FromTable: query.TableRef{
			Name: "users",
		},
		SelectCols: []query.SelectExpr{
			{Expr: query.ColumnExpr{Column: query.Int64Column{Table: "users", Name: "id"}}},
		},
		Where: query.BinaryExpr{
			Left:  query.ColumnExpr{Column: query.StringColumn{Table: "users", Name: "email"}},
			Op:    query.OpEq,
			Right: query.ParamExpr{Name: "email", GoType: "string"},
		},
		Limit: query.ParamExpr{Name: "limit", GoType: "int64"},
	}

	params := ExtractParamInfo(ast)

	if len(params) != 2 {
		t.Fatalf("expected 2 params, got %d", len(params))
	}

	// Check email param
	foundEmail := false
	foundLimit := false
	for _, p := range params {
		if p.Name == "email" && p.GoType == "string" {
			foundEmail = true
		}
		if p.Name == "limit" && p.GoType == "int64" {
			foundLimit = true
		}
	}

	if !foundEmail {
		t.Error("expected to find email param")
	}
	if !foundLimit {
		t.Error("expected to find limit param")
	}
}

func TestFormatSQLString(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		contains string
	}{
		{
			name:     "simple",
			input:    `SELECT * FROM users`,
			contains: "`SELECT * FROM users`",
		},
		{
			name:     "with quotes",
			input:    `SELECT "id" FROM "users"`,
			contains: "`SELECT \"id\" FROM \"users\"`",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := formatSQLString(tt.input)
			if result != tt.contains {
				t.Errorf("expected %s, got %s", tt.contains, result)
			}
		})
	}
}

func TestDuplicateColumnNamesError(t *testing.T) {
	// This simulates a JOIN query where both tables have a "name" column
	// and the user forgot to use aliases
	queries := []CompiledQuery{
		{
			Name: "ListPetsWithCategory",
			SQL:  `SELECT "pets"."name", "categories"."name" FROM "pets" JOIN "categories"`,
			Results: []ResultInfo{
				{Name: "name", GoType: "string"}, // pets.name
				{Name: "name", GoType: "string"}, // categories.name - DUPLICATE!
			},
		},
	}

	_, err := GenerateSharedTypes(queries, nil, "queries", nil)
	if err == nil {
		t.Fatal("expected error for duplicate column names, got nil")
	}

	// Error message should be helpful
	errStr := err.Error()
	if !strings.Contains(errStr, "ListPetsWithCategory") {
		t.Errorf("error should mention the query name, got: %s", errStr)
	}
	if !strings.Contains(errStr, "Name") || !strings.Contains(errStr, "duplicate") {
		t.Errorf("error should mention duplicate field name, got: %s", errStr)
	}
}

func TestDuplicateColumnNamesDifferentCase(t *testing.T) {
	// Test that snake_case columns that convert to the same PascalCase are caught
	// e.g., "user_name" and "userName" both become "UserName"
	queries := []CompiledQuery{
		{
			Name: "GetUserDetails",
			SQL:  `SELECT user_name, user_name FROM users`,
			Results: []ResultInfo{
				{Name: "user_name", GoType: "string"},
				{Name: "user_name", GoType: "string"},
			},
		},
	}

	_, err := GenerateSharedTypes(queries, nil, "queries", nil)
	if err == nil {
		t.Fatal("expected error for duplicate column names, got nil")
	}
}

func TestNoDuplicatesWithAliases(t *testing.T) {
	// When aliases are used, there should be no error
	queries := []CompiledQuery{
		{
			Name: "ListPetsWithCategory",
			SQL:  `SELECT "pets"."name", "categories"."name" AS "category_name" FROM "pets" JOIN "categories"`,
			Results: []ResultInfo{
				{Name: "name", GoType: "string"},
				{Name: "category_name", GoType: "string"}, // Different name via alias
			},
		},
	}

	_, err := GenerateSharedTypes(queries, nil, "queries", nil)
	if err != nil {
		t.Fatalf("unexpected error with aliases: %v", err)
	}
}

// =============================================================================
// JSON Aggregation Tests
// =============================================================================

func TestGenerateQueriesWithJSONAgg_SingleLevel(t *testing.T) {
	// Test single-level nesting: Categories with nested pets array
	queries := []CompiledQuery{
		{
			Name: "ListCategoriesWithPets",
			SQL:  `SELECT "categories"."id", "categories"."name", JSON_AGG(...) AS "pets" FROM "categories"`,
			Results: []ResultInfo{
				{Name: "id", GoType: "int64"},
				{Name: "name", GoType: "string"},
				{Name: "pets", GoType: "", NestedFields: []ResultInfo{
					{Name: "id", GoType: "int64"},
					{Name: "name", GoType: "string"},
					{Name: "status", GoType: "*string"},
				}},
			},
		},
	}

	code, err := GenerateSharedTypes(queries, nil, "queries", nil)
	if err != nil {
		t.Fatalf("GenerateSharedTypes failed: %v", err)
	}

	codeStr := string(code)

	// Should have the result struct with typed Pets field
	if !strings.Contains(codeStr, "type ListCategoriesWithPetsResult struct") {
		t.Error("missing ListCategoriesWithPetsResult struct")
	}
	if !containsField(codeStr, "Pets", "[]ListCategoriesWithPetsPetsItem") {
		t.Errorf("missing typed Pets field, got:\n%s", codeStr)
	}

	// Should have the nested item struct
	if !strings.Contains(codeStr, "type ListCategoriesWithPetsPetsItem struct") {
		t.Errorf("missing nested PetsItem struct, got:\n%s", codeStr)
	}

	// Check nested struct has correct fields (use regex-like matching for whitespace)
	if !containsField(codeStr, "Id", "int64") {
		t.Error("missing Id field in nested struct")
	}
	if !containsField(codeStr, "Name", "string") {
		t.Error("missing Name field in nested struct")
	}
	if !containsField(codeStr, "Status", "*string") {
		t.Error("missing Status field in nested struct")
	}

	// Verify generated code parses as valid Go
	assertValidGoCode(t, code)
}

func TestGenerateQueriesWithJSONAgg_MultiLevel(t *testing.T) {
	// Test multi-level nesting: Categories -> Pets -> Tags (2 levels)
	queries := []CompiledQuery{
		{
			Name: "GetCategoryTree",
			SQL:  `SELECT ... complex JSON aggregation ...`,
			Results: []ResultInfo{
				{Name: "id", GoType: "int64"},
				{Name: "name", GoType: "string"},
				{Name: "pets", GoType: "", NestedFields: []ResultInfo{
					{Name: "id", GoType: "int64"},
					{Name: "name", GoType: "string"},
					{Name: "tags", GoType: "", NestedFields: []ResultInfo{
						{Name: "id", GoType: "int64"},
						{Name: "label", GoType: "string"},
					}},
				}},
			},
		},
	}

	code, err := GenerateSharedTypes(queries, nil, "queries", nil)
	if err != nil {
		t.Fatalf("GenerateSharedTypes failed: %v", err)
	}

	codeStr := string(code)

	// Should have the main result struct
	if !strings.Contains(codeStr, "type GetCategoryTreeResult struct") {
		t.Error("missing GetCategoryTreeResult struct")
	}
	if !containsField(codeStr, "Pets", "[]GetCategoryTreePetsItem") {
		t.Errorf("missing typed Pets field, got:\n%s", codeStr)
	}

	// Should have first-level nested struct
	if !strings.Contains(codeStr, "type GetCategoryTreePetsItem struct") {
		t.Errorf("missing nested PetsItem struct, got:\n%s", codeStr)
	}

	// First-level nested struct should have tags as typed slice
	if !containsField(codeStr, "Tags", "[]GetCategoryTreePetsTagsItem") {
		t.Errorf("missing Tags field in PetsItem struct, got:\n%s", codeStr)
	}

	// Should have second-level nested struct
	if !strings.Contains(codeStr, "type GetCategoryTreePetsTagsItem struct") {
		t.Errorf("missing nested TagsItem struct, got:\n%s", codeStr)
	}

	// Check second-level nested struct has correct fields
	if !containsField(codeStr, "Label", "string") {
		t.Errorf("missing Label field in TagsItem struct, got:\n%s", codeStr)
	}

	// Verify generated code parses as valid Go
	assertValidGoCode(t, code)
}

func TestGenerateQueriesWithJSONAgg_MultipleFields(t *testing.T) {
	// Test multiple JSON agg fields in same query: Users with both pets AND orders
	queries := []CompiledQuery{
		{
			Name: "GetUserWithRelations",
			SQL:  `SELECT ... complex query ...`,
			Results: []ResultInfo{
				{Name: "id", GoType: "int64"},
				{Name: "name", GoType: "string"},
				{Name: "pets", GoType: "", NestedFields: []ResultInfo{
					{Name: "id", GoType: "int64"},
					{Name: "name", GoType: "string"},
				}},
				{Name: "orders", GoType: "", NestedFields: []ResultInfo{
					{Name: "id", GoType: "int64"},
					{Name: "total", GoType: "float64"},
					{Name: "created_at", GoType: "time.Time"},
				}},
			},
		},
	}

	code, err := GenerateSharedTypes(queries, nil, "queries", nil)
	if err != nil {
		t.Fatalf("GenerateSharedTypes failed: %v", err)
	}

	codeStr := string(code)

	// Should have both nested types
	if !containsField(codeStr, "Pets", "[]GetUserWithRelationsPetsItem") {
		t.Errorf("missing Pets field, got:\n%s", codeStr)
	}
	if !containsField(codeStr, "Orders", "[]GetUserWithRelationsOrdersItem") {
		t.Errorf("missing Orders field, got:\n%s", codeStr)
	}

	// Should have both nested structs
	if !strings.Contains(codeStr, "type GetUserWithRelationsPetsItem struct") {
		t.Error("missing PetsItem struct")
	}
	if !strings.Contains(codeStr, "type GetUserWithRelationsOrdersItem struct") {
		t.Error("missing OrdersItem struct")
	}

	// Should import time for the orders.created_at field
	if !strings.Contains(codeStr, `"time"`) {
		t.Error("missing time import for nested time.Time field")
	}

	// Verify generated code parses as valid Go
	assertValidGoCode(t, code)
}

func TestGenerateQueriesWithJSONAgg_ThreeLevels(t *testing.T) {
	// Test 3 levels of nesting: Organizations -> Departments -> Teams -> Members
	queries := []CompiledQuery{
		{
			Name: "GetOrgStructure",
			SQL:  `SELECT ...`,
			Results: []ResultInfo{
				{Name: "id", GoType: "int64"},
				{Name: "departments", GoType: "", NestedFields: []ResultInfo{
					{Name: "id", GoType: "int64"},
					{Name: "teams", GoType: "", NestedFields: []ResultInfo{
						{Name: "id", GoType: "int64"},
						{Name: "members", GoType: "", NestedFields: []ResultInfo{
							{Name: "id", GoType: "int64"},
							{Name: "name", GoType: "string"},
						}},
					}},
				}},
			},
		},
	}

	code, err := GenerateSharedTypes(queries, nil, "queries", nil)
	if err != nil {
		t.Fatalf("GenerateSharedTypes failed: %v", err)
	}

	codeStr := string(code)

	// Check all levels are generated
	if !strings.Contains(codeStr, "type GetOrgStructureDepartmentsItem struct") {
		t.Error("missing DepartmentsItem struct")
	}
	if !strings.Contains(codeStr, "type GetOrgStructureDepartmentsTeamsItem struct") {
		t.Error("missing TeamsItem struct")
	}
	if !strings.Contains(codeStr, "type GetOrgStructureDepartmentsTeamsMembersItem struct") {
		t.Error("missing MembersItem struct")
	}

	// Verify the chain of types
	if !containsField(codeStr, "Departments", "[]GetOrgStructureDepartmentsItem") {
		t.Error("missing typed Departments field")
	}
	if !containsField(codeStr, "Teams", "[]GetOrgStructureDepartmentsTeamsItem") {
		t.Error("missing typed Teams field")
	}
	if !containsField(codeStr, "Members", "[]GetOrgStructureDepartmentsTeamsMembersItem") {
		t.Error("missing typed Members field")
	}

	// Verify generated code parses as valid Go
	assertValidGoCode(t, code)
}

func TestExtractResultInfo_WithJSONAgg(t *testing.T) {
	// Test ExtractResultInfo with JSONAggExpr
	ast := &query.AST{
		Kind: query.SelectQuery,
		FromTable: query.TableRef{
			Name: "categories",
		},
		SelectCols: []query.SelectExpr{
			{Expr: query.ColumnExpr{Column: query.Int64Column{Table: "categories", Name: "id"}}},
			{Expr: query.ColumnExpr{Column: query.StringColumn{Table: "categories", Name: "name"}}},
			{
				Expr: query.JSONAggExpr{
					FieldName: "pets",
					Columns: []query.Column{
						query.Int64Column{Table: "pets", Name: "id"},
						query.StringColumn{Table: "pets", Name: "name"},
						query.NullStringColumn{Table: "pets", Name: "status"},
					},
				},
				Alias: "pets",
			},
		},
	}

	results := ExtractResultInfo(ast)

	if len(results) != 3 {
		t.Fatalf("expected 3 results, got %d", len(results))
	}

	// Check regular columns
	if results[0].Name != "id" || results[0].GoType != "int64" {
		t.Errorf("unexpected first result: %+v", results[0])
	}
	if results[1].Name != "name" || results[1].GoType != "string" {
		t.Errorf("unexpected second result: %+v", results[1])
	}

	// Check JSON agg result
	if results[2].Name != "pets" {
		t.Errorf("expected name 'pets', got %q", results[2].Name)
	}
	if len(results[2].NestedFields) != 3 {
		t.Fatalf("expected 3 nested fields, got %d", len(results[2].NestedFields))
	}
	if results[2].NestedFields[0].Name != "id" || results[2].NestedFields[0].GoType != "int64" {
		t.Errorf("unexpected nested field 0: %+v", results[2].NestedFields[0])
	}
	if results[2].NestedFields[1].Name != "name" || results[2].NestedFields[1].GoType != "string" {
		t.Errorf("unexpected nested field 1: %+v", results[2].NestedFields[1])
	}
	if results[2].NestedFields[2].Name != "status" || results[2].NestedFields[2].GoType != "*string" {
		t.Errorf("unexpected nested field 2: %+v", results[2].NestedFields[2])
	}
}

// assertValidGoCode checks that the generated code parses as valid Go
func assertValidGoCode(t *testing.T, code []byte) {
	t.Helper()
	// The code is already formatted by go/format in GenerateSharedTypes,
	// so if it got this far without error, it's valid Go
	if len(code) == 0 {
		t.Error("generated code is empty")
	}
}

// containsField checks if the code contains a struct field with the given name and type.
// It handles whitespace variations from gofmt alignment.
func containsField(code, fieldName, fieldType string) bool {
	// Match "FieldName type" with any amount of whitespace between
	// We look for the field name at the start of a line (with leading whitespace)
	// followed by whitespace and the type
	lines := strings.Split(code, "\n")
	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		if strings.HasPrefix(trimmed, fieldName) {
			rest := strings.TrimPrefix(trimmed, fieldName)
			rest = strings.TrimSpace(rest)
			if strings.HasPrefix(rest, fieldType) {
				return true
			}
		}
	}
	return false
}

// =============================================================================
// Tests for GenerateSharedTypes
// =============================================================================

func TestGenerateSharedTypes_Basic(t *testing.T) {
	queries := []CompiledQuery{
		{
			Name: "GetUserById",
			SQL:  `SELECT "id", "name", "email" FROM "users" WHERE "id" = $1`,
			Params: []ParamInfo{
				{Name: "id", GoType: "int64"},
			},
			Results: []ResultInfo{
				{Name: "id", GoType: "int64"},
				{Name: "name", GoType: "string"},
				{Name: "email", GoType: "string"},
			},
			ReturnType: "one",
		},
	}

	code, err := GenerateSharedTypes(queries, nil, "queries", make(map[string]CRUDOptions))
	if err != nil {
		t.Fatalf("GenerateSharedTypes failed: %v", err)
	}

	codeStr := string(code)

	// Check header
	if !strings.Contains(codeStr, "// Code generated by portsql. DO NOT EDIT.") {
		t.Error("missing generated header")
	}
	if !strings.Contains(codeStr, "package queries") {
		t.Error("missing package declaration")
	}

	// Check that it contains param and result structs (but NOT SQL constants)
	if !strings.Contains(codeStr, "GetUserByIdParams") {
		t.Error("missing GetUserByIdParams struct")
	}
	if !strings.Contains(codeStr, "GetUserByIdResult") {
		t.Error("missing GetUserByIdResult struct")
	}
	if !strings.Contains(codeStr, "Id int64") {
		t.Error("missing Id field in params")
	}
	if !strings.Contains(codeStr, "Email string") {
		t.Error("missing Email field in result")
	}

	// Should NOT contain SQL constants (those go in dialect-specific runners)
	if strings.Contains(codeStr, "GetUserByIdSQL") {
		t.Error("should not contain SQL constants in shared types")
	}
}

func TestGenerateSharedTypes_WithJSONAgg(t *testing.T) {
	queries := []CompiledQuery{
		{
			Name: "ListCategoriesWithPets",
			SQL:  `SELECT "categories"."id", "categories"."name", JSON_AGG(...) AS "pets" FROM "categories"`,
			Results: []ResultInfo{
				{Name: "id", GoType: "int64"},
				{Name: "name", GoType: "string"},
				{Name: "pets", GoType: "", NestedFields: []ResultInfo{
					{Name: "id", GoType: "int64"},
					{Name: "name", GoType: "string"},
					{Name: "status", GoType: "*string"},
				}},
			},
		},
	}

	code, err := GenerateSharedTypes(queries, nil, "queries", make(map[string]CRUDOptions))
	if err != nil {
		t.Fatalf("GenerateSharedTypes failed: %v", err)
	}

	codeStr := string(code)

	// Should have the result struct with typed Pets field
	if !strings.Contains(codeStr, "type ListCategoriesWithPetsResult struct") {
		t.Error("missing ListCategoriesWithPetsResult struct")
	}
	if !containsField(codeStr, "Pets", "[]ListCategoriesWithPetsPetsItem") {
		t.Errorf("missing typed Pets field, got:\n%s", codeStr)
	}

	// Should have the nested item struct
	if !strings.Contains(codeStr, "type ListCategoriesWithPetsPetsItem struct") {
		t.Errorf("missing nested PetsItem struct, got:\n%s", codeStr)
	}
}

// =============================================================================
// Tests for GenerateDialectRunner
// =============================================================================

func TestGenerateDialectRunner_OneQuery(t *testing.T) {
	queries := []CompiledQueryWithDialects{
		{
			CompiledQuery: CompiledQuery{
				Name: "GetUserById",
				Params: []ParamInfo{
					{Name: "id", GoType: "int64"},
				},
				Results: []ResultInfo{
					{Name: "id", GoType: "int64"},
					{Name: "name", GoType: "string"},
					{Name: "email", GoType: "string"},
				},
				ReturnType: "one",
			},
			SQL: DialectSQL{
				Postgres: `SELECT "id", "name", "email" FROM "users" WHERE "id" = $1`,
				MySQL:    "SELECT `id`, `name`, `email` FROM `users` WHERE `id` = ?",
				SQLite:   `SELECT "id", "name", "email" FROM "users" WHERE "id" = ?`,
			},
		},
	}

	code, err := GenerateDialectRunner(queries, nil, "sqlite", "myapp/queries", make(map[string]CRUDOptions))
	if err != nil {
		t.Fatalf("GenerateDialectRunner failed: %v", err)
	}

	codeStr := string(code)

	// Check that it's in the sqlite package
	if !strings.Contains(codeStr, "package sqlite") {
		t.Error("missing sqlite package declaration")
	}

	// Check that it contains QueryRunner struct
	if !strings.Contains(codeStr, "type QueryRunner struct") {
		t.Error("missing QueryRunner struct")
	}

	// Check that NewQueryRunner doesn't take a dialect parameter
	if !strings.Contains(codeStr, "func NewQueryRunner(db Querier) *QueryRunner") {
		t.Error("NewQueryRunner should not take dialect parameter")
	}

	// Check that method uses types from parent package
	if !strings.Contains(codeStr, "func (r *QueryRunner) GetUserById(ctx context.Context, params queries.GetUserByIdParams) (*queries.GetUserByIdResult, error)") {
		t.Error("missing GetUserById method with correct ONE signature")
	}

	// Check that sql.ErrNoRows returns nil, nil
	if !strings.Contains(codeStr, "if err == sql.ErrNoRows {") {
		t.Error("missing ErrNoRows handling for ONE query")
	}
	if !strings.Contains(codeStr, "return nil, nil") {
		t.Error("missing return nil, nil for ONE query")
	}

	// Check that SQLite-specific SQL is used (not Postgres $1)
	// The SQL is stored as a string literal, so check for the ? placeholder
	if !strings.Contains(codeStr, "?") {
		t.Error("should use SQLite SQL with ? placeholders")
	}
	if strings.Contains(codeStr, "$1") {
		t.Error("should not contain Postgres placeholders in SQLite runner")
	}
}

func TestGenerateDialectRunner_ManyQuery(t *testing.T) {
	queries := []CompiledQueryWithDialects{
		{
			CompiledQuery: CompiledQuery{
				Name: "ListUsers",
				Params: []ParamInfo{
					{Name: "limit", GoType: "int"},
				},
				Results: []ResultInfo{
					{Name: "id", GoType: "int64"},
					{Name: "name", GoType: "string"},
				},
				ReturnType: "many",
			},
			SQL: DialectSQL{
				Postgres: `SELECT "id", "name" FROM "users" LIMIT $1`,
				MySQL:    "SELECT `id`, `name` FROM `users` LIMIT ?",
				SQLite:   `SELECT "id", "name" FROM "users" LIMIT ?`,
			},
		},
	}

	code, err := GenerateDialectRunner(queries, nil, "postgres", "myapp/queries", make(map[string]CRUDOptions))
	if err != nil {
		t.Fatalf("GenerateDialectRunner failed: %v", err)
	}

	codeStr := string(code)

	// Check that method returns ([]Result, error) for MANY type
	if !strings.Contains(codeStr, "func (r *QueryRunner) ListUsers(ctx context.Context, params queries.ListUsersParams) ([]queries.ListUsersResult, error)") {
		t.Error("missing ListUsers method with correct MANY signature")
	}

	// Check that it uses QueryContext
	if !strings.Contains(codeStr, "rows, err := r.db.QueryContext") {
		t.Error("missing QueryContext for MANY query")
	}

	// Check that it iterates rows
	if !strings.Contains(codeStr, "for rows.Next()") {
		t.Error("missing rows iteration for MANY query")
	}

	// Check that Postgres-specific SQL is used
	if !strings.Contains(codeStr, `$1`) {
		t.Error("should use Postgres $1 placeholder")
	}
}

func TestGenerateDialectRunner_ExecQuery(t *testing.T) {
	queries := []CompiledQueryWithDialects{
		{
			CompiledQuery: CompiledQuery{
				Name: "UpdateUserName",
				Params: []ParamInfo{
					{Name: "id", GoType: "int64"},
					{Name: "name", GoType: "string"},
				},
				Results:    []ResultInfo{},
				ReturnType: "exec",
			},
			SQL: DialectSQL{
				Postgres: `UPDATE "users" SET "name" = $1 WHERE "id" = $2`,
				MySQL:    "UPDATE `users` SET `name` = ? WHERE `id` = ?",
				SQLite:   `UPDATE "users" SET "name" = ? WHERE "id" = ?`,
			},
		},
	}

	code, err := GenerateDialectRunner(queries, nil, "mysql", "myapp/queries", make(map[string]CRUDOptions))
	if err != nil {
		t.Fatalf("GenerateDialectRunner failed: %v", err)
	}

	codeStr := string(code)

	// Check that method returns (sql.Result, error) for EXEC type
	if !strings.Contains(codeStr, "func (r *QueryRunner) UpdateUserName(ctx context.Context, params queries.UpdateUserNameParams) (sql.Result, error)") {
		t.Error("missing UpdateUserName method with correct EXEC signature")
	}

	// Check that it uses ExecContext
	if !strings.Contains(codeStr, "return r.db.ExecContext") {
		t.Error("missing ExecContext for EXEC query")
	}

	// Check that MySQL-specific SQL is used
	if !strings.Contains(codeStr, "UPDATE `users` SET `name` = ? WHERE `id` = ?") {
		t.Error("should use MySQL SQL with backticks")
	}
}

func TestGenerateDialectRunner_DialectSpecificSQL(t *testing.T) {
	queries := []CompiledQueryWithDialects{
		{
			CompiledQuery: CompiledQuery{
				Name: "GetUser",
				Params: []ParamInfo{
					{Name: "id", GoType: "int64"},
				},
				Results: []ResultInfo{
					{Name: "id", GoType: "int64"},
				},
				ReturnType: "one",
			},
			SQL: DialectSQL{
				Postgres: `SELECT "id" FROM "users" WHERE "id" = $1`,
				MySQL:    "SELECT `id` FROM `users` WHERE `id` = ?",
				SQLite:   `SELECT "id" FROM "users" WHERE "id" = ?`,
			},
		},
	}

	// Test Postgres
	pgCode, err := GenerateDialectRunner(queries, nil, "postgres", "myapp/queries", make(map[string]CRUDOptions))
	if err != nil {
		t.Fatalf("GenerateDialectRunner(postgres) failed: %v", err)
	}
	pgCodeStr := string(pgCode)
	if !strings.Contains(pgCodeStr, "$1") {
		t.Error("Postgres runner should use $1 placeholder")
	}
	if !strings.Contains(pgCodeStr, "package postgres") {
		t.Error("Postgres runner should be in postgres package")
	}

	// Test MySQL
	mysqlCode, err := GenerateDialectRunner(queries, nil, "mysql", "myapp/queries", make(map[string]CRUDOptions))
	if err != nil {
		t.Fatalf("GenerateDialectRunner(mysql) failed: %v", err)
	}
	mysqlCodeStr := string(mysqlCode)
	if !strings.Contains(mysqlCodeStr, "?") {
		t.Error("MySQL runner should use ? placeholder")
	}
	if !strings.Contains(mysqlCodeStr, "package mysql") {
		t.Error("MySQL runner should be in mysql package")
	}

	// Test SQLite
	sqliteCode, err := GenerateDialectRunner(queries, nil, "sqlite", "myapp/queries", make(map[string]CRUDOptions))
	if err != nil {
		t.Fatalf("GenerateDialectRunner(sqlite) failed: %v", err)
	}
	sqliteCodeStr := string(sqliteCode)
	if !strings.Contains(sqliteCodeStr, "?") {
		t.Error("SQLite runner should use ? placeholder")
	}
	if !strings.Contains(sqliteCodeStr, "package sqlite") {
		t.Error("SQLite runner should be in sqlite package")
	}
	if strings.Contains(sqliteCodeStr, "$1") {
		t.Error("SQLite runner should not contain Postgres $1 placeholder")
	}
}

func TestGenerateDialectRunner_NoParams(t *testing.T) {
	queries := []CompiledQueryWithDialects{
		{
			CompiledQuery: CompiledQuery{
				Name:   "CountUsers",
				Params: []ParamInfo{},
				Results: []ResultInfo{
					{Name: "count", GoType: "int64"},
				},
				ReturnType: "one",
			},
			SQL: DialectSQL{
				Postgres: `SELECT COUNT(*) FROM "users"`,
				MySQL:    "SELECT COUNT(*) FROM `users`",
				SQLite:   `SELECT COUNT(*) FROM "users"`,
			},
		},
	}

	code, err := GenerateDialectRunner(queries, nil, "sqlite", "myapp/queries", make(map[string]CRUDOptions))
	if err != nil {
		t.Fatalf("GenerateDialectRunner failed: %v", err)
	}

	codeStr := string(code)

	// Check that method signature doesn't have params argument
	if !strings.Contains(codeStr, "func (r *QueryRunner) CountUsers(ctx context.Context) (*queries.CountUsersResult, error)") {
		t.Error("CountUsers should not require params argument when there are no parameters")
	}
}

func TestGenerateDialectRunner_WithTx(t *testing.T) {
	queries := []CompiledQueryWithDialects{
		{
			CompiledQuery: CompiledQuery{
				Name:       "GetUser",
				Params:     []ParamInfo{{Name: "id", GoType: "int64"}},
				Results:    []ResultInfo{{Name: "id", GoType: "int64"}},
				ReturnType: "one",
			},
			SQL: DialectSQL{
				Postgres: `SELECT "id" FROM "users" WHERE "id" = $1`,
				MySQL:    "SELECT `id` FROM `users` WHERE `id` = ?",
				SQLite:   `SELECT "id" FROM "users" WHERE "id" = ?`,
			},
		},
	}

	code, err := GenerateDialectRunner(queries, nil, "postgres", "myapp/queries", make(map[string]CRUDOptions))
	if err != nil {
		t.Fatalf("GenerateDialectRunner failed: %v", err)
	}

	codeStr := string(code)

	// Check that WithTx method exists
	if !strings.Contains(codeStr, "func (r *QueryRunner) WithTx(tx *sql.Tx) *QueryRunner") {
		t.Error("missing WithTx method")
	}
}

func TestGenerateDialectRunner_JSONAggWithNullFiltering(t *testing.T) {
	// Query with JSONAgg field (nested results)
	queries := []CompiledQueryWithDialects{
		{
			CompiledQuery: CompiledQuery{
				Name:   "GetAuthorWithBooks",
				Params: []ParamInfo{{Name: "id", GoType: "int64"}},
				Results: []ResultInfo{
					{Name: "id", GoType: "int64"},
					{Name: "name", GoType: "string"},
					{
						Name:   "books",
						GoType: "", // JSONAgg fields have empty GoType
						NestedFields: []ResultInfo{
							{Name: "id", GoType: "int64"},
							{Name: "title", GoType: "string"},
						},
					},
				},
				ReturnType: "one",
			},
			SQL: DialectSQL{
				Postgres: `SELECT "id", "name", books FROM "authors" WHERE "id" = $1`,
				MySQL:    "SELECT `id`, `name`, books FROM `authors` WHERE `id` = ?",
				SQLite:   `SELECT "id", "name", books FROM "authors" WHERE "id" = ?`,
			},
		},
	}

	// Test with PostgreSQL
	pgCode, err := GenerateDialectRunner(queries, nil, "postgres", "myapp/queries", make(map[string]CRUDOptions))
	if err != nil {
		t.Fatalf("GenerateDialectRunner(postgres) failed: %v", err)
	}
	pgCodeStr := string(pgCode)

	// Check that json import is present for JSONAgg handling
	if !strings.Contains(pgCodeStr, `"encoding/json"`) {
		t.Error("postgres runner should import encoding/json for JSONAgg")
	}

	// Check that JSONAgg field is scanned into intermediate []byte variable
	if !strings.Contains(pgCodeStr, "var booksJSON []byte") {
		t.Error("postgres runner should scan JSONAgg into []byte intermediate")
	}

	// Check that json.Unmarshal is called to parse the JSON
	if !strings.Contains(pgCodeStr, "json.Unmarshal") {
		t.Error("postgres runner should unmarshal JSONAgg field")
	}

	// Check for null filtering (skip "null" entries from CASE WHEN)
	if !strings.Contains(pgCodeStr, `string(raw) == "null"`) {
		t.Error("postgres runner should filter out null entries from JSON array")
	}

	// Test with SQLite (uses sql.NullString for JSON)
	sqliteCode, err := GenerateDialectRunner(queries, nil, "sqlite", "myapp/queries", make(map[string]CRUDOptions))
	if err != nil {
		t.Fatalf("GenerateDialectRunner(sqlite) failed: %v", err)
	}
	sqliteCodeStr := string(sqliteCode)

	// Check that SQLite uses sql.NullString for JSONAgg
	if !strings.Contains(sqliteCodeStr, "var booksJSON sql.NullString") {
		t.Error("sqlite runner should scan JSONAgg into sql.NullString intermediate")
	}

	// Check for proper conversion from sql.NullString to JSON
	if !strings.Contains(sqliteCodeStr, "booksJSON.Valid") {
		t.Error("sqlite runner should check NullString.Valid before unmarshaling")
	}
}
