= PortSQL

A database-agnostic, SQL-first code generation tool for Go.

== Motivation

Most Go database tools fall into two camps:

1. **ORMs** (GORM, ent) - Hide SQL behind an abstraction layer. You lose control over the queries that actually run, and debugging performance issues means diving into generated SQL you didn't write.

2. **SQL-first tools** (sqlc) - Write raw SQL, generate Go code. Great for control, but you're locked into one database dialect.

**PortSQL takes a different approach**: define your schema and queries in Go, and we generate type-safe, raw SQL for PostgreSQL, MySQL, and SQLite. You get:

- **Full control** over the exact SQL that runs
- **Type safety** at compile time
- **Database portability** without rewriting queries
- **No runtime reflection** or query building overhead

== The Two-Phase Workflow

PortSQL uses two code generation phases:

[source]
----
┌─────────────────────────────────────────────────────────────────┐
│                    PHASE 1: Schema Codegen                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   Define migrations in Go                                        │
│           │                                                      │
│           ▼                                                      │
│   ┌───────────────────┐                                          │
│   │  MigrationPlan    │                                          │
│   │  (Schema + SQL)   │                                          │
│   └───────────────────┘                                          │
│           │                                                      │
│           ├──────────────────┬──────────────────┐                │
│           ▼                  ▼                  ▼                │
│   ┌────────────────┐  ┌────────────────┐  ┌────────────────┐     │
│   │ Migration SQL  │  │ Table Structs  │  │ Column Types   │     │
│   │ (per database) │  │ (Users, Posts) │  │ (Int64Column,  │     │
│   │                │  │                │  │  StringColumn) │     │
│   └────────────────┘  └────────────────┘  └────────────────┘     │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                    PHASE 2: Query Codegen                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   Define queries using generated schema types                    │
│           │                                                      │
│           ▼                                                      │
│   ┌───────────────────┐                                          │
│   │  Query AST        │                                          │
│   │  (type-checked)   │                                          │
│   └───────────────────┘                                          │
│           │                                                      │
│           ├──────────────────┬──────────────────┐                │
│           ▼                  ▼                  ▼                │
│   ┌────────────────┐  ┌────────────────┐  ┌────────────────┐     │
│   │ SQL Strings    │  │ Param Structs  │  │ Result Structs │     │
│   │ (per database) │  │ (typed inputs) │  │ (typed output) │     │
│   └────────────────┘  └────────────────┘  └────────────────┘     │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
----

== Quick Example

=== Step 1: Define Your Schema

[source,go]
----
package migrations

import "github.com/portsql/portsql/src/ddl"

func BuildSchema(plan *migrate.MigrationPlan) error {
    // Create users table
    plan.AddEmptyTable("users", func(tb *ddl.TableBuilder) error {
        tb.Bigint("id").PrimaryKey()
        tb.String("name")
        tb.String("email").Unique()
        tb.Datetime("created_at").Indexed()
        return nil
    })

    // Create posts table
    plan.AddEmptyTable("posts", func(tb *ddl.TableBuilder) error {
        tb.Bigint("id").PrimaryKey()
        tb.Bigint("author_id").Indexed()
        tb.String("title")
        tb.Text("body").Nullable()
        tb.Datetime("published_at").Nullable()
        return nil
    })

    return nil
}
----

**Run Phase 1 codegen** → Generates `schema/tables.go`:

[source,go]
----
// Code generated by portsql. DO NOT EDIT.
package schema

import "github.com/portsql/portsql/src/query"

// UsersTable provides type-safe column references for the users table.
type UsersTable struct{}

var Users = UsersTable{}

func (UsersTable) TableName() string { return "users" }

func (UsersTable) Id() query.Int64Column       { return query.Int64Column{Table: "users", Name: "id"} }
func (UsersTable) Name() query.StringColumn    { return query.StringColumn{Table: "users", Name: "name"} }
func (UsersTable) Email() query.StringColumn   { return query.StringColumn{Table: "users", Name: "email"} }
func (UsersTable) CreatedAt() query.TimeColumn { return query.TimeColumn{Table: "users", Name: "created_at"} }

// PostsTable provides type-safe column references for the posts table.
type PostsTable struct{}

var Posts = PostsTable{}

func (PostsTable) TableName() string { return "posts" }

func (PostsTable) Id() query.Int64Column            { return query.Int64Column{Table: "posts", Name: "id"} }
func (PostsTable) AuthorId() query.Int64Column      { return query.Int64Column{Table: "posts", Name: "author_id"} }
func (PostsTable) Title() query.StringColumn        { return query.StringColumn{Table: "posts", Name: "title"} }
func (PostsTable) Body() query.NullStringColumn     { return query.NullStringColumn{Table: "posts", Name: "body"} }
func (PostsTable) PublishedAt() query.NullTimeColumn { return query.NullTimeColumn{Table: "posts", Name: "published_at"} }
----

=== Step 2: Define Your Queries

Using the generated schema, define type-safe queries:

[source,go]
----
package queries

import (
    "myapp/schema"
    "github.com/portsql/portsql/src/query"
)

// GetUserByEmail retrieves a user by email.
var GetUserByEmail = query.From(schema.Users).
    Select(
        schema.Users.Id(),
        schema.Users.Name(),
        schema.Users.Email(),
    ).
    Where(schema.Users.Email().Eq(query.Param("email"))).
    Build()

// GetUserWithPosts retrieves a user with their posts as nested JSON.
var GetUserWithPosts = query.From(schema.Users).
    LeftJoin(schema.Posts).On(schema.Users.Id().Eq(schema.Posts.AuthorId())).
    Select(
        schema.Users.Id(),
        schema.Users.Name(),
    ).
    SelectJSONAgg("posts",
        schema.Posts.Id(),
        schema.Posts.Title(),
        schema.Posts.PublishedAt(),
    ).
    Where(schema.Users.Id().Eq(query.Param("user_id"))).
    GroupBy(schema.Users.Id(), schema.Users.Name()).
    Build()

// ListRecentPosts retrieves recent published posts with pagination.
var ListRecentPosts = query.From(schema.Posts).
    Select(
        schema.Posts.Id(),
        schema.Posts.Title(),
        schema.Posts.AuthorId(),
        schema.Posts.PublishedAt(),
    ).
    Where(schema.Posts.PublishedAt().IsNotNull()).
    OrderBy(schema.Posts.PublishedAt().Desc()).
    Limit(query.Param("limit")).
    Offset(query.Param("offset")).
    Build()
----

=== Step 3: Use Generated SQL in Your Application

**Run Phase 2 codegen** → Generates raw SQL strings for each database:

[source,go]
----
// Generated SQL - you can see exactly what runs!
// Postgres:
// SELECT "users"."id", "users"."name", "users"."email"
// FROM "users" WHERE "users"."email" = $1

// MySQL:
// SELECT `users`.`id`, `users`.`name`, `users`.`email`
// FROM `users` WHERE `users`.`email` = ?

// SQLite:
// SELECT "users"."id", "users"."name", "users"."email"
// FROM "users" WHERE "users"."email" = ?
----

Use the generated code in your application:

[source,go]
----
func (s *Server) GetUser(ctx context.Context, email string) (*User, error) {
    // SQL is pre-compiled - no runtime query building
    row := s.db.QueryRowContext(ctx, queries.GetUserByEmailSQL, email)
    
    var user User
    err := row.Scan(&user.ID, &user.Name, &user.Email)
    if err == sql.ErrNoRows {
        return nil, nil
    }
    return &user, err
}
----

== Features

=== Database Support

|===
| Feature | PostgreSQL | MySQL | SQLite

| CREATE TABLE | ✓ | ✓ | ✓
| ALTER TABLE | ✓ | ✓ | ✓ (via table rebuild)
| SELECT/INSERT/UPDATE/DELETE | ✓ | ✓ | ✓
| JOINs (INNER, LEFT, RIGHT, FULL) | ✓ | ✓ | ✓
| JSON Aggregation | ✓ | ✓ | ✓
| CTEs (WITH clauses) | ✓ | ✓ | ✓
| Set Operations (UNION, INTERSECT, EXCEPT) | ✓ | ✓ | ✓
| Subqueries | ✓ | ✓ | ✓
| Aggregates (COUNT, SUM, AVG, MIN, MAX) | ✓ | ✓ | ✓
|===

=== Type-Safe Column Types

PortSQL generates typed column references that prevent invalid operations at compile time:

[source,go]
----
// This compiles - comparing strings
schema.Users.Email().Eq(query.Param("email"))

// This compiles - numeric comparison
schema.Posts.AuthorId().Gt(query.Param("min_id"))

// String-specific operations
schema.Users.Name().Like(query.Param("pattern"))
schema.Users.Email().ILike(query.Param("search"))  // Case-insensitive

// Nullable columns
schema.Posts.PublishedAt().IsNull()
schema.Posts.PublishedAt().IsNotNull()
----

=== Cross-Database Translations

PortSQL handles database-specific syntax automatically:

|===
| Feature | PostgreSQL | MySQL | SQLite

| Identifier quoting | `"name"` | `` `name` `` | `"name"`
| Parameters | `$1, $2, $3` | `?, ?, ?` | `?, ?, ?`
| Boolean literals | `TRUE/FALSE` | `1/0` | `1/0`
| Current timestamp | `NOW()` | `NOW()` | `datetime('now')`
| Case-insensitive LIKE | `ILIKE` | `LOWER() LIKE LOWER()` | `LOWER() LIKE LOWER()`
| JSON object | `JSON_BUILD_OBJECT` | `JSON_OBJECT` | `JSON_OBJECT`
| JSON array agg | `JSON_AGG` | `JSON_ARRAYAGG` | `JSON_GROUP_ARRAY`
|===

=== JSON Aggregation

Fetch related data as nested JSON in a single query:

[source,go]
----
query.From(schema.Authors).
    LeftJoin(schema.Books).On(schema.Authors.Id().Eq(schema.Books.AuthorId())).
    Select(schema.Authors.Id(), schema.Authors.Name()).
    SelectJSONAgg("books",
        schema.Books.Id(),
        schema.Books.Title(),
        schema.Books.Price(),
    ).
    GroupBy(schema.Authors.Id(), schema.Authors.Name())
----

Generates database-specific JSON functions:

[source,sql]
----
-- PostgreSQL
SELECT "authors"."id", "authors"."name",
       COALESCE(JSON_AGG(JSON_BUILD_OBJECT('id', "books"."id", 'title', "books"."title", 'price', "books"."price"))
                FILTER (WHERE "books"."id" IS NOT NULL), '[]') AS "books"
FROM "authors"
LEFT JOIN "books" ON "authors"."id" = "books"."author_id"
GROUP BY "authors"."id", "authors"."name"

-- MySQL
SELECT `authors`.`id`, `authors`.`name`,
       COALESCE(JSON_ARRAYAGG(JSON_OBJECT('id', `books`.`id`, 'title', `books`.`title`, 'price', `books`.`price`)), JSON_ARRAY()) AS `books`
FROM `authors`
LEFT JOIN `books` ON `authors`.`id` = `books`.`author_id`
GROUP BY `authors`.`id`, `authors`.`name`

-- SQLite
SELECT "authors"."id", "authors"."name",
       COALESCE(JSON_GROUP_ARRAY(JSON_OBJECT('id', "books"."id", 'title', "books"."title", 'price', "books"."price")), '[]') AS "books"
FROM "authors"
LEFT JOIN "books" ON "authors"."id" = "books"."author_id"
GROUP BY "authors"."id", "authors"."name"
----

== Project Structure

[source]
----
portsql/
├── orm/
│   ├── ddl/              # Table/column definition builders
│   │   ├── types.go      # Column types, Table, Index definitions
│   │   ├── table_builder.go    # Fluent API for CREATE TABLE
│   │   └── alter_builder.go    # Fluent API for ALTER TABLE
│   │
│   ├── migrate/          # Migration planning and SQL generation
│   │   ├── plan.go       # MigrationPlan with AddTable, UpdateTable, etc.
│   │   ├── postgres_plan.go    # PostgreSQL CREATE/ALTER generators
│   │   ├── mysql_plan.go       # MySQL CREATE/ALTER generators
│   │   └── sqlite_plan.go      # SQLite CREATE/ALTER generators
│   │
│   ├── query/            # Query builder and AST
│   │   ├── builder.go    # SELECT query builder
│   │   ├── builder_insert.go   # INSERT query builder
│   │   ├── builder_update.go   # UPDATE query builder
│   │   ├── builder_delete.go   # DELETE query builder
│   │   ├── columns.go    # Typed column definitions
│   │   ├── expr.go       # Expression types (conditions, operators)
│   │   ├── ast.go        # Query AST structure
│   │   └── compile/      # SQL compilers per database
│   │       ├── postgres.go
│   │       ├── mysql.go
│   │       └── sqlite.go
│   │
│   └── codegen/          # Code generators
│       ├── schema_gen.go # Phase 1: Schema → Table structs
│       └── crud_gen.go   # CRUD query generation
│
└── proptest/             # Property-based testing utilities
----

== Philosophy

=== SQL is the Interface

Your application's database queries are a critical interface. PortSQL believes you should:

1. **See the SQL** - No hidden queries. The generated SQL is readable and auditable.
2. **Control the SQL** - The query builder maps directly to SQL constructs.
3. **Trust the SQL** - Property tests verify queries work identically across databases.

=== Compile-Time Safety

Type errors should be caught at compile time, not runtime:

- Column references are typed (can't compare a string column with `>`)
- Table references prevent typos in table names
- Parameter types are explicit

=== No Runtime Magic

- No reflection for query building
- No string interpolation for SQL construction
- Generated code is straightforward and debuggable

== Development

[source,bash]
----
# Run tests
go test ./...

# Run integration tests (requires databases)
just start-dbs        # Start Postgres, MySQL, SQLite via Docker
go test ./... -tags=integration

# Run property tests for cross-database correctness
go test ./src/migrate/... -run Property
----

== License

MIT License - see LICENSE.adoc
