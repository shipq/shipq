// Code generated by portsql. DO NOT EDIT.
package queries

import (
	"context"
	"database/sql"
	"github.com/portsql/nanoid"
)

// Dialect identifies the target database.
type Dialect int

const (
	Postgres Dialect = iota
	MySQL
	SQLite
)

// Querier is the interface for executing queries.
type Querier interface {
	ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error)
	QueryContext(ctx context.Context, query string, args ...any) (*sql.Rows, error)
	QueryRowContext(ctx context.Context, query string, args ...any) *sql.Row
}

// QueryRunner holds pre-compiled SQL strings for a specific dialect.
type QueryRunner struct {
	dialect Dialect
	db      Querier

	// User-defined query SQL strings
	findPetsByStatusSQL       string
	getOrderByIdSQL           string
	getPetByIdSQL             string
	getPetWithPhotosSQL       string
	getUserByUsernameSQL      string
	listCategoriesWithPetsSQL string
	listPetsWithCategorySQL   string

	// Users CRUD SQL strings
	getUserSQL        string
	listUsersSQL      string
	insertUserSQL     string
	updateUserSQL     string
	deleteUserSQL     string
	hardDeleteUserSQL string
}

// NewQueryRunner creates a runner for the given dialect.
func NewQueryRunner(db Querier, dialect Dialect) *QueryRunner {
	r := &QueryRunner{
		dialect: dialect,
		db:      db,
	}

	switch dialect {
	case Postgres:
		r.findPetsByStatusSQL = "SELECT \"pets\".\"id\", \"pets\".\"name\", \"pets\".\"category_id\", \"pets\".\"status\" FROM \"pets\" WHERE (\"pets\".\"status\" = $1)"
		r.getOrderByIdSQL = "SELECT \"orders\".\"id\", \"orders\".\"pet_id\", \"orders\".\"quantity\", \"orders\".\"ship_date\", \"orders\".\"status\", \"orders\".\"complete\" FROM \"orders\" WHERE (\"orders\".\"id\" = $1)"
		r.getPetByIdSQL = "SELECT \"pets\".\"id\", \"pets\".\"name\", \"pets\".\"category_id\", \"pets\".\"status\", \"pets\".\"photo_urls\" FROM \"pets\" WHERE (\"pets\".\"id\" = $1)"
		r.getPetWithPhotosSQL = "SELECT \"pets\".\"id\", \"pets\".\"name\", \"pets\".\"photo_urls\", \"pets\".\"status\", \"categories\".\"name\" AS \"category_name\" FROM \"pets\" INNER JOIN \"categories\" ON (\"pets\".\"category_id\" = \"categories\".\"id\") WHERE (\"pets\".\"id\" = $1)"
		r.getUserByUsernameSQL = "SELECT \"users\".\"id\", \"users\".\"public_id\", \"users\".\"username\", \"users\".\"first_name\", \"users\".\"last_name\", \"users\".\"email\", \"users\".\"created_at\" FROM \"users\" WHERE (\"users\".\"username\" = $1)"
		r.listCategoriesWithPetsSQL = "SELECT \"categories\".\"id\", \"categories\".\"name\", COALESCE(JSON_AGG(JSON_BUILD_OBJECT('id', \"pets\".\"id\", 'name', \"pets\".\"name\", 'status', \"pets\".\"status\")) FILTER (WHERE \"pets\".\"id\" IS NOT NULL), '[]') AS \"pets\" FROM \"categories\" LEFT JOIN \"pets\" ON (\"categories\".\"id\" = \"pets\".\"category_id\") GROUP BY \"categories\".\"id\", \"categories\".\"name\""
		r.listPetsWithCategorySQL = "SELECT \"pets\".\"id\", \"pets\".\"name\", \"pets\".\"status\", \"categories\".\"name\" AS \"category_name\" FROM \"pets\" INNER JOIN \"categories\" ON (\"pets\".\"category_id\" = \"categories\".\"id\")"
		r.getUserSQL = "SELECT \"public_id\", \"created_at\", \"updated_at\", \"username\", \"first_name\", \"last_name\", \"email\", \"password\", \"phone\", \"user_status\" FROM \"users\" WHERE \"public_id\" = $1 AND \"deleted_at\" IS NULL"
		r.listUsersSQL = "SELECT \"public_id\", \"created_at\", \"username\", \"first_name\", \"last_name\", \"email\", \"password\", \"phone\", \"user_status\" FROM \"users\" WHERE \"deleted_at\" IS NULL ORDER BY \"created_at\" DESC LIMIT $1 OFFSET $2"
		r.insertUserSQL = "INSERT INTO \"users\" (\"public_id\", \"username\", \"first_name\", \"last_name\", \"email\", \"password\", \"phone\", \"user_status\", \"created_at\", \"updated_at\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW(), NOW()) RETURNING \"public_id\""
		r.updateUserSQL = "UPDATE \"users\" SET \"username\" = $1, \"first_name\" = $2, \"last_name\" = $3, \"email\" = $4, \"password\" = $5, \"phone\" = $6, \"user_status\" = $7, \"updated_at\" = NOW() WHERE \"public_id\" = $8 AND \"deleted_at\" IS NULL"
		r.deleteUserSQL = "UPDATE \"users\" SET \"deleted_at\" = NOW() WHERE \"public_id\" = $1 AND \"deleted_at\" IS NULL"
		r.hardDeleteUserSQL = "DELETE FROM \"users\" WHERE \"public_id\" = $1"
	case MySQL:
		r.findPetsByStatusSQL = "SELECT `pets`.`id`, `pets`.`name`, `pets`.`category_id`, `pets`.`status` FROM `pets` WHERE (`pets`.`status` = ?)"
		r.getOrderByIdSQL = "SELECT `orders`.`id`, `orders`.`pet_id`, `orders`.`quantity`, `orders`.`ship_date`, `orders`.`status`, `orders`.`complete` FROM `orders` WHERE (`orders`.`id` = ?)"
		r.getPetByIdSQL = "SELECT `pets`.`id`, `pets`.`name`, `pets`.`category_id`, `pets`.`status`, `pets`.`photo_urls` FROM `pets` WHERE (`pets`.`id` = ?)"
		r.getPetWithPhotosSQL = "SELECT `pets`.`id`, `pets`.`name`, `pets`.`photo_urls`, `pets`.`status`, `categories`.`name` AS `category_name` FROM `pets` INNER JOIN `categories` ON (`pets`.`category_id` = `categories`.`id`) WHERE (`pets`.`id` = ?)"
		r.getUserByUsernameSQL = "SELECT `users`.`id`, `users`.`public_id`, `users`.`username`, `users`.`first_name`, `users`.`last_name`, `users`.`email`, `users`.`created_at` FROM `users` WHERE (`users`.`username` = ?)"
		r.listCategoriesWithPetsSQL = "SELECT `categories`.`id`, `categories`.`name`, COALESCE(JSON_ARRAYAGG(JSON_OBJECT('id', `pets`.`id`, 'name', `pets`.`name`, 'status', `pets`.`status`)), JSON_ARRAY()) AS `pets` FROM `categories` LEFT JOIN `pets` ON (`categories`.`id` = `pets`.`category_id`) GROUP BY `categories`.`id`, `categories`.`name`"
		r.listPetsWithCategorySQL = "SELECT `pets`.`id`, `pets`.`name`, `pets`.`status`, `categories`.`name` AS `category_name` FROM `pets` INNER JOIN `categories` ON (`pets`.`category_id` = `categories`.`id`)"
		r.getUserSQL = "SELECT `public_id`, `created_at`, `updated_at`, `username`, `first_name`, `last_name`, `email`, `password`, `phone`, `user_status` FROM `users` WHERE `public_id` = ? AND `deleted_at` IS NULL"
		r.listUsersSQL = "SELECT `public_id`, `created_at`, `username`, `first_name`, `last_name`, `email`, `password`, `phone`, `user_status` FROM `users` WHERE `deleted_at` IS NULL ORDER BY `created_at` DESC LIMIT ? OFFSET ?"
		r.insertUserSQL = "INSERT INTO `users` (`public_id`, `username`, `first_name`, `last_name`, `email`, `password`, `phone`, `user_status`, `created_at`, `updated_at`) VALUES (?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())"
		r.updateUserSQL = "UPDATE `users` SET `username` = ?, `first_name` = ?, `last_name` = ?, `email` = ?, `password` = ?, `phone` = ?, `user_status` = ?, `updated_at` = NOW() WHERE `public_id` = ? AND `deleted_at` IS NULL"
		r.deleteUserSQL = "UPDATE `users` SET `deleted_at` = NOW() WHERE `public_id` = ? AND `deleted_at` IS NULL"
		r.hardDeleteUserSQL = "DELETE FROM `users` WHERE `public_id` = ?"
	case SQLite:
		r.findPetsByStatusSQL = "SELECT \"pets\".\"id\", \"pets\".\"name\", \"pets\".\"category_id\", \"pets\".\"status\" FROM \"pets\" WHERE (\"pets\".\"status\" = ?)"
		r.getOrderByIdSQL = "SELECT \"orders\".\"id\", \"orders\".\"pet_id\", \"orders\".\"quantity\", \"orders\".\"ship_date\", \"orders\".\"status\", \"orders\".\"complete\" FROM \"orders\" WHERE (\"orders\".\"id\" = ?)"
		r.getPetByIdSQL = "SELECT \"pets\".\"id\", \"pets\".\"name\", \"pets\".\"category_id\", \"pets\".\"status\", \"pets\".\"photo_urls\" FROM \"pets\" WHERE (\"pets\".\"id\" = ?)"
		r.getPetWithPhotosSQL = "SELECT \"pets\".\"id\", \"pets\".\"name\", \"pets\".\"photo_urls\", \"pets\".\"status\", \"categories\".\"name\" AS \"category_name\" FROM \"pets\" INNER JOIN \"categories\" ON (\"pets\".\"category_id\" = \"categories\".\"id\") WHERE (\"pets\".\"id\" = ?)"
		r.getUserByUsernameSQL = "SELECT \"users\".\"id\", \"users\".\"public_id\", \"users\".\"username\", \"users\".\"first_name\", \"users\".\"last_name\", \"users\".\"email\", \"users\".\"created_at\" FROM \"users\" WHERE (\"users\".\"username\" = ?)"
		r.listCategoriesWithPetsSQL = "SELECT \"categories\".\"id\", \"categories\".\"name\", COALESCE(JSON_GROUP_ARRAY(JSON_OBJECT('id', \"pets\".\"id\", 'name', \"pets\".\"name\", 'status', \"pets\".\"status\")), '[]') AS \"pets\" FROM \"categories\" LEFT JOIN \"pets\" ON (\"categories\".\"id\" = \"pets\".\"category_id\") GROUP BY \"categories\".\"id\", \"categories\".\"name\""
		r.listPetsWithCategorySQL = "SELECT \"pets\".\"id\", \"pets\".\"name\", \"pets\".\"status\", \"categories\".\"name\" AS \"category_name\" FROM \"pets\" INNER JOIN \"categories\" ON (\"pets\".\"category_id\" = \"categories\".\"id\")"
		r.getUserSQL = "SELECT \"public_id\", \"created_at\", \"updated_at\", \"username\", \"first_name\", \"last_name\", \"email\", \"password\", \"phone\", \"user_status\" FROM \"users\" WHERE \"public_id\" = ? AND \"deleted_at\" IS NULL"
		r.listUsersSQL = "SELECT \"public_id\", \"created_at\", \"username\", \"first_name\", \"last_name\", \"email\", \"password\", \"phone\", \"user_status\" FROM \"users\" WHERE \"deleted_at\" IS NULL ORDER BY \"created_at\" DESC LIMIT ? OFFSET ?"
		r.insertUserSQL = "INSERT INTO \"users\" (\"public_id\", \"username\", \"first_name\", \"last_name\", \"email\", \"password\", \"phone\", \"user_status\", \"created_at\", \"updated_at\") VALUES (?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now')) RETURNING \"public_id\""
		r.updateUserSQL = "UPDATE \"users\" SET \"username\" = ?, \"first_name\" = ?, \"last_name\" = ?, \"email\" = ?, \"password\" = ?, \"phone\" = ?, \"user_status\" = ?, \"updated_at\" = datetime('now') WHERE \"public_id\" = ? AND \"deleted_at\" IS NULL"
		r.deleteUserSQL = "UPDATE \"users\" SET \"deleted_at\" = datetime('now') WHERE \"public_id\" = ? AND \"deleted_at\" IS NULL"
		r.hardDeleteUserSQL = "DELETE FROM \"users\" WHERE \"public_id\" = ?"
	}

	return r
}

// WithTx returns a new QueryRunner using the given transaction.
func (r *QueryRunner) WithTx(tx *sql.Tx) *QueryRunner {
	return &QueryRunner{
		dialect:                   r.dialect,
		db:                        tx,
		findPetsByStatusSQL:       r.findPetsByStatusSQL,
		getOrderByIdSQL:           r.getOrderByIdSQL,
		getPetByIdSQL:             r.getPetByIdSQL,
		getPetWithPhotosSQL:       r.getPetWithPhotosSQL,
		getUserByUsernameSQL:      r.getUserByUsernameSQL,
		listCategoriesWithPetsSQL: r.listCategoriesWithPetsSQL,
		listPetsWithCategorySQL:   r.listPetsWithCategorySQL,
		getUserSQL:                r.getUserSQL,
		listUsersSQL:              r.listUsersSQL,
		insertUserSQL:             r.insertUserSQL,
		updateUserSQL:             r.updateUserSQL,
		deleteUserSQL:             r.deleteUserSQL,
		hardDeleteUserSQL:         r.hardDeleteUserSQL,
	}
}

// FindPetsByStatus executes the query and returns all results.
func (r *QueryRunner) FindPetsByStatus(ctx context.Context, params FindPetsByStatusParams) ([]FindPetsByStatusResult, error) {
	args := []any{
		params.Status,
	}

	rows, err := r.db.QueryContext(ctx, r.findPetsByStatusSQL, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []FindPetsByStatusResult
	for rows.Next() {
		var item FindPetsByStatusResult
		err := rows.Scan(
			&item.Id,
			&item.Name,
			&item.CategoryId,
			&item.Status,
		)
		if err != nil {
			return nil, err
		}
		results = append(results, item)
	}

	if err := rows.Err(); err != nil {
		return nil, err
	}
	return results, nil
}

// GetOrderById executes the query and returns at most one result.
func (r *QueryRunner) GetOrderById(ctx context.Context, params GetOrderByIdParams) (*GetOrderByIdResult, error) {
	args := []any{
		params.Id,
	}

	row := r.db.QueryRowContext(ctx, r.getOrderByIdSQL, args...)

	var result GetOrderByIdResult
	err := row.Scan(
		&result.Id,
		&result.PetId,
		&result.Quantity,
		&result.ShipDate,
		&result.Status,
		&result.Complete,
	)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}
	return &result, nil
}

// GetPetById executes the query and returns at most one result.
func (r *QueryRunner) GetPetById(ctx context.Context, params GetPetByIdParams) (*GetPetByIdResult, error) {
	args := []any{
		params.Id,
	}

	row := r.db.QueryRowContext(ctx, r.getPetByIdSQL, args...)

	var result GetPetByIdResult
	err := row.Scan(
		&result.Id,
		&result.Name,
		&result.CategoryId,
		&result.Status,
		&result.PhotoUrls,
	)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}
	return &result, nil
}

// GetPetWithPhotos executes the query and returns at most one result.
func (r *QueryRunner) GetPetWithPhotos(ctx context.Context, params GetPetWithPhotosParams) (*GetPetWithPhotosResult, error) {
	args := []any{
		params.Id,
	}

	row := r.db.QueryRowContext(ctx, r.getPetWithPhotosSQL, args...)

	var result GetPetWithPhotosResult
	err := row.Scan(
		&result.Id,
		&result.Name,
		&result.PhotoUrls,
		&result.Status,
		&result.CategoryName,
	)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}
	return &result, nil
}

// GetUserByUsername executes the query and returns at most one result.
func (r *QueryRunner) GetUserByUsername(ctx context.Context, params GetUserByUsernameParams) (*GetUserByUsernameResult, error) {
	args := []any{
		params.Username,
	}

	row := r.db.QueryRowContext(ctx, r.getUserByUsernameSQL, args...)

	var result GetUserByUsernameResult
	err := row.Scan(
		&result.Id,
		&result.PublicId,
		&result.Username,
		&result.FirstName,
		&result.LastName,
		&result.Email,
		&result.CreatedAt,
	)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}
	return &result, nil
}

// ListCategoriesWithPets executes the query and returns all results.
func (r *QueryRunner) ListCategoriesWithPets(ctx context.Context) ([]ListCategoriesWithPetsResult, error) {
	rows, err := r.db.QueryContext(ctx, r.listCategoriesWithPetsSQL)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []ListCategoriesWithPetsResult
	for rows.Next() {
		var item ListCategoriesWithPetsResult
		err := rows.Scan(
			&item.Id,
			&item.Name,
			&item.Pets,
		)
		if err != nil {
			return nil, err
		}
		results = append(results, item)
	}

	if err := rows.Err(); err != nil {
		return nil, err
	}
	return results, nil
}

// ListPetsWithCategory executes the query and returns all results.
func (r *QueryRunner) ListPetsWithCategory(ctx context.Context) ([]ListPetsWithCategoryResult, error) {
	rows, err := r.db.QueryContext(ctx, r.listPetsWithCategorySQL)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []ListPetsWithCategoryResult
	for rows.Next() {
		var item ListPetsWithCategoryResult
		err := rows.Scan(
			&item.Id,
			&item.Name,
			&item.Status,
			&item.CategoryName,
		)
		if err != nil {
			return nil, err
		}
		results = append(results, item)
	}

	if err := rows.Err(); err != nil {
		return nil, err
	}
	return results, nil
}

// GetUser fetches a single user by its identifier.
func (r *QueryRunner) GetUser(ctx context.Context, params GetUserParams) (*GetUserResult, error) {
	var args []any
	args = append(args, params.PublicID)

	row := r.db.QueryRowContext(ctx, r.getUserSQL, args...)

	var result GetUserResult
	err := row.Scan(
		&result.PublicId,
		&result.CreatedAt,
		&result.UpdatedAt,
		&result.Username,
		&result.FirstName,
		&result.LastName,
		&result.Email,
		&result.Password,
		&result.Phone,
		&result.UserStatus,
	)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}
	return &result, nil
}

// ListUsers fetches a paginated list of users.
func (r *QueryRunner) ListUsers(ctx context.Context, params ListUsersParams) ([]ListUsersResult, error) {
	var args []any
	args = append(args, params.Limit, params.Offset)

	rows, err := r.db.QueryContext(ctx, r.listUsersSQL, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []ListUsersResult
	for rows.Next() {
		var item ListUsersResult
		err := rows.Scan(
			&item.PublicId,
			&item.CreatedAt,
			&item.Username,
			&item.FirstName,
			&item.LastName,
			&item.Email,
			&item.Password,
			&item.Phone,
			&item.UserStatus,
		)
		if err != nil {
			return nil, err
		}
		results = append(results, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return results, nil
}

// InsertUser inserts a new user and returns its public ID.
func (r *QueryRunner) InsertUser(ctx context.Context, params InsertUserParams) (string, error) {
	publicID := nanoid.New()

	var args []any
	args = append(args, publicID)
	args = append(args, params.Username)
	args = append(args, params.FirstName)
	args = append(args, params.LastName)
	args = append(args, params.Email)
	args = append(args, params.Password)
	args = append(args, params.Phone)
	args = append(args, params.UserStatus)

	if r.dialect == MySQL {
		_, err := r.db.ExecContext(ctx, r.insertUserSQL, args...)
		if err != nil {
			return "", err
		}
		return publicID, nil
	}

	// Postgres/SQLite: Use RETURNING
	var returnedID string
	err := r.db.QueryRowContext(ctx, r.insertUserSQL, args...).Scan(&returnedID)
	if err != nil {
		return "", err
	}
	return returnedID, nil
}

// UpdateUser updates an existing user.
func (r *QueryRunner) UpdateUser(ctx context.Context, params UpdateUserParams) error {
	var args []any
	args = append(args, params.Username)
	args = append(args, params.FirstName)
	args = append(args, params.LastName)
	args = append(args, params.Email)
	args = append(args, params.Password)
	args = append(args, params.Phone)
	args = append(args, params.UserStatus)
	args = append(args, params.PublicID)

	_, err := r.db.ExecContext(ctx, r.updateUserSQL, args...)
	return err
}

// DeleteUser soft-deletes a user (or hard-deletes if no deleted_at column).
func (r *QueryRunner) DeleteUser(ctx context.Context, params DeleteUserParams) error {
	_, err := r.db.ExecContext(ctx, r.deleteUserSQL, params.PublicID)
	return err
}

// HardDeleteUser permanently deletes a user.
func (r *QueryRunner) HardDeleteUser(ctx context.Context, params HardDeleteUserParams) error {
	_, err := r.db.ExecContext(ctx, r.hardDeleteUserSQL, params.PublicID)
	return err
}
