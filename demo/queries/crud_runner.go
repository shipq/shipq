// Code generated by orm codegen. DO NOT EDIT.
package queries

import (
	"context"
	"database/sql"
	"github.com/portsql/nanoid"
	"time"
)

// Dialect identifies the target database.
type Dialect int

const (
	Postgres Dialect = iota
	MySQL
	SQLite
)

// Querier is the interface for executing queries.
type Querier interface {
	ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error)
	QueryContext(ctx context.Context, query string, args ...any) (*sql.Rows, error)
	QueryRowContext(ctx context.Context, query string, args ...any) *sql.Row
}

// QueryRunner holds pre-compiled SQL strings for a specific dialect.
type QueryRunner struct {
	dialect Dialect
	db      Querier

	// Users SQL strings
	getUserSQL        string
	listUsersSQL      string
	insertUserSQL     string
	updateUserSQL     string
	deleteUserSQL     string
	hardDeleteUserSQL string
}

// NewQueryRunner creates a runner for the given dialect.
func NewQueryRunner(db Querier, dialect Dialect) *QueryRunner {
	r := &QueryRunner{
		dialect: dialect,
		db:      db,
	}

	switch dialect {
	case Postgres:
		r.getUserSQL = "SELECT \"public_id\", \"created_at\", \"updated_at\", \"username\", \"first_name\", \"last_name\", \"email\", \"password\", \"phone\", \"user_status\" FROM \"users\" WHERE \"public_id\" = $1 AND \"deleted_at\" IS NULL"
		r.listUsersSQL = "SELECT \"public_id\", \"created_at\", \"username\", \"first_name\", \"last_name\", \"email\", \"password\", \"phone\", \"user_status\" FROM \"users\" WHERE \"deleted_at\" IS NULL ORDER BY \"created_at\" DESC LIMIT $1 OFFSET $2"
		r.insertUserSQL = "INSERT INTO \"users\" (\"public_id\", \"username\", \"first_name\", \"last_name\", \"email\", \"password\", \"phone\", \"user_status\", \"created_at\", \"updated_at\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW(), NOW()) RETURNING \"public_id\""
		r.updateUserSQL = "UPDATE \"users\" SET \"username\" = $1, \"first_name\" = $2, \"last_name\" = $3, \"email\" = $4, \"password\" = $5, \"phone\" = $6, \"user_status\" = $7, \"updated_at\" = NOW() WHERE \"public_id\" = $8 AND \"deleted_at\" IS NULL"
		r.deleteUserSQL = "UPDATE \"users\" SET \"deleted_at\" = NOW() WHERE \"public_id\" = $1 AND \"deleted_at\" IS NULL"
		r.hardDeleteUserSQL = "DELETE FROM \"users\" WHERE \"public_id\" = $1"
	case MySQL:
		r.getUserSQL = "SELECT `public_id`, `created_at`, `updated_at`, `username`, `first_name`, `last_name`, `email`, `password`, `phone`, `user_status` FROM `users` WHERE `public_id` = ? AND `deleted_at` IS NULL"
		r.listUsersSQL = "SELECT `public_id`, `created_at`, `username`, `first_name`, `last_name`, `email`, `password`, `phone`, `user_status` FROM `users` WHERE `deleted_at` IS NULL ORDER BY `created_at` DESC LIMIT ? OFFSET ?"
		r.insertUserSQL = "INSERT INTO `users` (`public_id`, `username`, `first_name`, `last_name`, `email`, `password`, `phone`, `user_status`, `created_at`, `updated_at`) VALUES (?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())"
		r.updateUserSQL = "UPDATE `users` SET `username` = ?, `first_name` = ?, `last_name` = ?, `email` = ?, `password` = ?, `phone` = ?, `user_status` = ?, `updated_at` = NOW() WHERE `public_id` = ? AND `deleted_at` IS NULL"
		r.deleteUserSQL = "UPDATE `users` SET `deleted_at` = NOW() WHERE `public_id` = ? AND `deleted_at` IS NULL"
		r.hardDeleteUserSQL = "DELETE FROM `users` WHERE `public_id` = ?"
	case SQLite:
		r.getUserSQL = "SELECT \"public_id\", \"created_at\", \"updated_at\", \"username\", \"first_name\", \"last_name\", \"email\", \"password\", \"phone\", \"user_status\" FROM \"users\" WHERE \"public_id\" = ? AND \"deleted_at\" IS NULL"
		r.listUsersSQL = "SELECT \"public_id\", \"created_at\", \"username\", \"first_name\", \"last_name\", \"email\", \"password\", \"phone\", \"user_status\" FROM \"users\" WHERE \"deleted_at\" IS NULL ORDER BY \"created_at\" DESC LIMIT ? OFFSET ?"
		r.insertUserSQL = "INSERT INTO \"users\" (\"public_id\", \"username\", \"first_name\", \"last_name\", \"email\", \"password\", \"phone\", \"user_status\", \"created_at\", \"updated_at\") VALUES (?, ?, ?, ?, ?, ?, ?, ?, datetime('now'), datetime('now')) RETURNING \"public_id\""
		r.updateUserSQL = "UPDATE \"users\" SET \"username\" = ?, \"first_name\" = ?, \"last_name\" = ?, \"email\" = ?, \"password\" = ?, \"phone\" = ?, \"user_status\" = ?, \"updated_at\" = datetime('now') WHERE \"public_id\" = ? AND \"deleted_at\" IS NULL"
		r.deleteUserSQL = "UPDATE \"users\" SET \"deleted_at\" = datetime('now') WHERE \"public_id\" = ? AND \"deleted_at\" IS NULL"
		r.hardDeleteUserSQL = "DELETE FROM \"users\" WHERE \"public_id\" = ?"
	}

	return r
}

// WithTx returns a new QueryRunner using the given transaction.
func (r *QueryRunner) WithTx(tx *sql.Tx) *QueryRunner {
	return &QueryRunner{
		dialect:           r.dialect,
		db:                tx,
		getUserSQL:        r.getUserSQL,
		listUsersSQL:      r.listUsersSQL,
		insertUserSQL:     r.insertUserSQL,
		updateUserSQL:     r.updateUserSQL,
		deleteUserSQL:     r.deleteUserSQL,
		hardDeleteUserSQL: r.hardDeleteUserSQL,
	}
}

// GetUser fetches a single user by its identifier.
func (r *QueryRunner) GetUser(ctx context.Context, params GetUserParams) (*GetUserResult, error) {
	var args []any
	args = append(args, params.PublicID)

	row := r.db.QueryRowContext(ctx, r.getUserSQL, args...)

	var result GetUserResult
	err := row.Scan(
		&result.PublicId,
		&result.CreatedAt,
		&result.UpdatedAt,
		&result.Username,
		&result.FirstName,
		&result.LastName,
		&result.Email,
		&result.Password,
		&result.Phone,
		&result.UserStatus,
	)
	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}
	return &result, nil
}

// ListUsers fetches a paginated list of users.
func (r *QueryRunner) ListUsers(ctx context.Context, params ListUsersParams) ([]ListUsersResult, error) {
	var args []any
	args = append(args, params.Limit, params.Offset)

	rows, err := r.db.QueryContext(ctx, r.listUsersSQL, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []ListUsersResult
	for rows.Next() {
		var item ListUsersResult
		err := rows.Scan(
			&item.PublicId,
			&item.CreatedAt,
			&item.Username,
			&item.FirstName,
			&item.LastName,
			&item.Email,
			&item.Password,
			&item.Phone,
			&item.UserStatus,
		)
		if err != nil {
			return nil, err
		}
		results = append(results, item)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return results, nil
}

// InsertUser inserts a new user and returns its public ID.
func (r *QueryRunner) InsertUser(ctx context.Context, params InsertUserParams) (string, error) {
	publicID := nanoid.New()

	var args []any
	args = append(args, publicID)
	args = append(args, params.Username)
	args = append(args, params.FirstName)
	args = append(args, params.LastName)
	args = append(args, params.Email)
	args = append(args, params.Password)
	args = append(args, params.Phone)
	args = append(args, params.UserStatus)

	if r.dialect == MySQL {
		_, err := r.db.ExecContext(ctx, r.insertUserSQL, args...)
		if err != nil {
			return "", err
		}
		return publicID, nil
	}

	// Postgres/SQLite: Use RETURNING
	var returnedID string
	err := r.db.QueryRowContext(ctx, r.insertUserSQL, args...).Scan(&returnedID)
	if err != nil {
		return "", err
	}
	return returnedID, nil
}

// UpdateUser updates an existing user.
func (r *QueryRunner) UpdateUser(ctx context.Context, params UpdateUserParams) error {
	var args []any
	args = append(args, params.Username)
	args = append(args, params.FirstName)
	args = append(args, params.LastName)
	args = append(args, params.Email)
	args = append(args, params.Password)
	args = append(args, params.Phone)
	args = append(args, params.UserStatus)
	args = append(args, params.PublicID)

	_, err := r.db.ExecContext(ctx, r.updateUserSQL, args...)
	return err
}

// DeleteUser soft-deletes a user (or hard-deletes if no deleted_at column).
func (r *QueryRunner) DeleteUser(ctx context.Context, params DeleteUserParams) error {
	_, err := r.db.ExecContext(ctx, r.deleteUserSQL, params.PublicID)
	return err
}

// HardDeleteUser permanently deletes a user.
func (r *QueryRunner) HardDeleteUser(ctx context.Context, params HardDeleteUserParams) error {
	_, err := r.db.ExecContext(ctx, r.hardDeleteUserSQL, params.PublicID)
	return err
}
